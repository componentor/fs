{"version":3,"sources":["../src/path.ts","../src/constants.ts","../src/errors.ts","../src/filesystem.ts","../src/index.ts"],"names":["isAbsolute","resolve","result"],"mappings":"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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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","file":"index.cjs","sourcesContent":["/**\n * POSIX-style path utilities for OPFS\n * Mirrors Node.js path module behavior\n */\n\nexport const sep = '/';\nexport const delimiter = ':';\n\nexport function normalize(p: string): string {\n  if (p.length === 0) return '.';\n\n  const isAbsolute = p.charCodeAt(0) === 47; // '/'\n  const trailingSlash = p.charCodeAt(p.length - 1) === 47;\n\n  const segments = p.split('/');\n  const result: string[] = [];\n\n  for (const segment of segments) {\n    if (segment === '' || segment === '.') {\n      continue;\n    }\n    if (segment === '..') {\n      if (result.length > 0 && result[result.length - 1] !== '..') {\n        result.pop();\n      } else if (!isAbsolute) {\n        result.push('..');\n      }\n    } else {\n      result.push(segment);\n    }\n  }\n\n  let normalized = result.join('/');\n\n  if (isAbsolute) {\n    normalized = '/' + normalized;\n  }\n\n  if (trailingSlash && normalized.length > 1) {\n    normalized += '/';\n  }\n\n  return normalized || (isAbsolute ? '/' : '.');\n}\n\nexport function join(...paths: string[]): string {\n  if (paths.length === 0) return '.';\n\n  let joined: string | undefined;\n\n  for (const path of paths) {\n    if (path.length > 0) {\n      if (joined === undefined) {\n        joined = path;\n      } else {\n        joined += '/' + path;\n      }\n    }\n  }\n\n  if (joined === undefined) return '.';\n\n  return normalize(joined);\n}\n\nexport function resolve(...paths: string[]): string {\n  let resolvedPath = '';\n  let resolvedAbsolute = false;\n\n  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    const path = i >= 0 ? paths[i] : '/';\n\n    // Handle undefined, null, or empty paths\n    if (path == null || path.length === 0) continue;\n\n    resolvedPath = resolvedPath ? path + '/' + resolvedPath : path;\n    resolvedAbsolute = path.charCodeAt(0) === 47; // '/'\n  }\n\n  resolvedPath = normalize(resolvedPath);\n\n  // Remove trailing slash unless it's the root\n  if (resolvedPath.length > 1 && resolvedPath.endsWith('/')) {\n    resolvedPath = resolvedPath.slice(0, -1);\n  }\n\n  if (resolvedAbsolute) {\n    return resolvedPath.length > 0 ? resolvedPath : '/';\n  }\n\n  return resolvedPath.length > 0 ? resolvedPath : '.';\n}\n\nexport function isAbsolute(p: string): boolean {\n  return p.length > 0 && p.charCodeAt(0) === 47; // '/'\n}\n\nexport function dirname(p: string): string {\n  if (p.length === 0) return '.';\n\n  const hasRoot = p.charCodeAt(0) === 47;\n  let end = -1;\n  let matchedSlash = true;\n\n  for (let i = p.length - 1; i >= 1; --i) {\n    if (p.charCodeAt(i) === 47) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) return '//';\n\n  return p.slice(0, end);\n}\n\nexport function basename(p: string, ext?: string): string {\n  let start = 0;\n  let end = -1;\n  let matchedSlash = true;\n\n  for (let i = p.length - 1; i >= 0; --i) {\n    if (p.charCodeAt(i) === 47) {\n      if (!matchedSlash) {\n        start = i + 1;\n        break;\n      }\n    } else if (end === -1) {\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n\n  const base = p.slice(start, end);\n\n  if (ext && base.endsWith(ext)) {\n    return base.slice(0, base.length - ext.length);\n  }\n\n  return base;\n}\n\nexport function extname(p: string): string {\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let preDotState = 0;\n\n  for (let i = p.length - 1; i >= 0; --i) {\n    const code = p.charCodeAt(i);\n\n    if (code === 47) {\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n\n    if (end === -1) {\n      matchedSlash = false;\n      end = i + 1;\n    }\n\n    if (code === 46) {\n      if (startDot === -1) {\n        startDot = i;\n      } else if (preDotState !== 1) {\n        preDotState = 1;\n      }\n    } else if (startDot !== -1) {\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    preDotState === 0 ||\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return '';\n  }\n\n  return p.slice(startDot, end);\n}\n\nexport function relative(from: string, to: string): string {\n  if (from === to) return '';\n\n  from = resolve(from);\n  to = resolve(to);\n\n  if (from === to) return '';\n\n  // Split into segments\n  const fromParts = from.split('/').filter(Boolean);\n  const toParts = to.split('/').filter(Boolean);\n\n  // Find common base\n  let commonLength = 0;\n  const minLength = Math.min(fromParts.length, toParts.length);\n  for (let i = 0; i < minLength; i++) {\n    if (fromParts[i] === toParts[i]) {\n      commonLength++;\n    } else {\n      break;\n    }\n  }\n\n  // Build relative path\n  const upCount = fromParts.length - commonLength;\n  const relativeParts: string[] = [];\n\n  for (let i = 0; i < upCount; i++) {\n    relativeParts.push('..');\n  }\n\n  for (let i = commonLength; i < toParts.length; i++) {\n    relativeParts.push(toParts[i]);\n  }\n\n  return relativeParts.join('/') || '.';\n}\n\nexport function parse(p: string): {\n  root: string;\n  dir: string;\n  base: string;\n  ext: string;\n  name: string;\n} {\n  const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n  if (p.length === 0) return ret;\n\n  const isAbsolutePath = p.charCodeAt(0) === 47;\n\n  if (isAbsolutePath) {\n    ret.root = '/';\n  }\n\n  let start = 0;\n  let end = -1;\n  let startDot = -1;\n  let matchedSlash = true;\n  let preDotState = 0;\n\n  for (let i = p.length - 1; i >= 0; --i) {\n    const code = p.charCodeAt(i);\n\n    if (code === 47) {\n      if (!matchedSlash) {\n        start = i + 1;\n        break;\n      }\n      continue;\n    }\n\n    if (end === -1) {\n      matchedSlash = false;\n      end = i + 1;\n    }\n\n    if (code === 46) {\n      if (startDot === -1) {\n        startDot = i;\n      } else if (preDotState !== 1) {\n        preDotState = 1;\n      }\n    } else if (startDot !== -1) {\n      preDotState = -1;\n    }\n  }\n\n  if (end !== -1) {\n    if (\n      startDot === -1 ||\n      preDotState === 0 ||\n      (preDotState === 1 && startDot === end - 1 && startDot === start + 1)\n    ) {\n      ret.base = p.slice(start, end);\n      ret.name = ret.base;\n    } else {\n      ret.name = p.slice(start, startDot);\n      ret.base = p.slice(start, end);\n      ret.ext = p.slice(startDot, end);\n    }\n  }\n\n  if (start > 0) {\n    ret.dir = p.slice(0, start - 1);\n  } else if (isAbsolutePath) {\n    ret.dir = '/';\n  }\n\n  return ret;\n}\n\nexport function format(pathObject: {\n  root?: string;\n  dir?: string;\n  base?: string;\n  ext?: string;\n  name?: string;\n}): string {\n  const dir = pathObject.dir || pathObject.root || '';\n  const base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n\n  if (!dir) return base;\n  if (dir === pathObject.root) return dir + base;\n\n  return dir + '/' + base;\n}\n\nexport const posix = {\n  sep,\n  delimiter,\n  normalize,\n  join,\n  resolve,\n  isAbsolute,\n  dirname,\n  basename,\n  extname,\n  relative,\n  parse,\n  format,\n};\n\nexport default posix;\n","/**\n * File system constants matching Node.js fs.constants\n */\n\nexport const constants = {\n  // File access constants\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n\n  // File copy constants\n  COPYFILE_EXCL: 1,\n  COPYFILE_FICLONE: 2,\n  COPYFILE_FICLONE_FORCE: 4,\n\n  // File open constants\n  O_RDONLY: 0,\n  O_WRONLY: 1,\n  O_RDWR: 2,\n  O_CREAT: 64,\n  O_EXCL: 128,\n  O_TRUNC: 512,\n  O_APPEND: 1024,\n  O_SYNC: 4096,\n\n  // File type constants\n  S_IFMT: 61440,\n  S_IFREG: 32768,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960,\n  S_IFSOCK: 49152,\n\n  // File mode constants\n  S_IRWXU: 448,\n  S_IRUSR: 256,\n  S_IWUSR: 128,\n  S_IXUSR: 64,\n  S_IRWXG: 56,\n  S_IRGRP: 32,\n  S_IWGRP: 16,\n  S_IXGRP: 8,\n  S_IRWXO: 7,\n  S_IROTH: 4,\n  S_IWOTH: 2,\n  S_IXOTH: 1,\n} as const;\n\nexport type Constants = typeof constants;\n","/**\n * Node.js compatible filesystem error classes\n */\n\nexport class FSError extends Error {\n  code: string;\n  errno: number;\n  syscall?: string;\n  path?: string;\n\n  constructor(code: string, errno: number, message: string, syscall?: string, path?: string) {\n    super(message);\n    this.name = 'FSError';\n    this.code = code;\n    this.errno = errno;\n    this.syscall = syscall;\n    this.path = path;\n\n    // Maintain proper stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, FSError);\n    }\n  }\n}\n\nexport const ErrorCodes = {\n  ENOENT: -2,\n  EEXIST: -17,\n  EISDIR: -21,\n  ENOTDIR: -20,\n  ENOTEMPTY: -39,\n  EACCES: -13,\n  EBADF: -9,\n  EINVAL: -22,\n  EMFILE: -24,\n  ENOSPC: -28,\n  EPERM: -1,\n} as const;\n\nexport function createENOENT(syscall: string, path: string): FSError {\n  return new FSError(\n    'ENOENT',\n    ErrorCodes.ENOENT,\n    `ENOENT: no such file or directory, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createEEXIST(syscall: string, path: string): FSError {\n  return new FSError(\n    'EEXIST',\n    ErrorCodes.EEXIST,\n    `EEXIST: file already exists, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createEISDIR(syscall: string, path: string): FSError {\n  return new FSError(\n    'EISDIR',\n    ErrorCodes.EISDIR,\n    `EISDIR: illegal operation on a directory, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createENOTDIR(syscall: string, path: string): FSError {\n  return new FSError(\n    'ENOTDIR',\n    ErrorCodes.ENOTDIR,\n    `ENOTDIR: not a directory, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createENOTEMPTY(syscall: string, path: string): FSError {\n  return new FSError(\n    'ENOTEMPTY',\n    ErrorCodes.ENOTEMPTY,\n    `ENOTEMPTY: directory not empty, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createEACCES(syscall: string, path: string): FSError {\n  return new FSError(\n    'EACCES',\n    ErrorCodes.EACCES,\n    `EACCES: permission denied, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createEINVAL(syscall: string, path: string): FSError {\n  return new FSError(\n    'EINVAL',\n    ErrorCodes.EINVAL,\n    `EINVAL: invalid argument, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function mapErrorCode(errorName: string, syscall: string, path: string): FSError {\n  switch (errorName) {\n    case 'NotFoundError':\n      return createENOENT(syscall, path);\n    case 'NotAllowedError':\n      return createEACCES(syscall, path);\n    case 'TypeMismatchError':\n      return createENOTDIR(syscall, path);\n    case 'InvalidModificationError':\n      return createENOTEMPTY(syscall, path);\n    case 'QuotaExceededError':\n      return new FSError('ENOSPC', ErrorCodes.ENOSPC, `ENOSPC: no space left on device, ${syscall} '${path}'`, syscall, path);\n    default:\n      return new FSError('EINVAL', ErrorCodes.EINVAL, `${errorName}: ${syscall} '${path}'`, syscall, path);\n  }\n}\n","/**\n * OPFS FileSystem - Node.js fs-compatible API\n * Supports two performance tiers:\n * - Tier 1 (Sync): SharedArrayBuffer + Atomics - requires crossOriginIsolated (COOP/COEP headers)\n * - Tier 2 (Async): Promises API using Worker kernel - always available\n */\n\nimport * as path from './path.js';\nimport { constants } from './constants.js';\nimport {\n  FSError,\n  createENOENT,\n  mapErrorCode,\n} from './errors.js';\nimport type {\n  Stats,\n  Dirent,\n  ReadOptions,\n  WriteOptions,\n  MkdirOptions,\n  RmdirOptions,\n  RmOptions,\n  ReaddirOptions,\n  Encoding,\n  FileSystemPromises,\n  KernelResponse,\n  KernelResult,\n} from './types.js';\n\n// Detect if we're running in a Worker context (where Atomics.wait and createSyncAccessHandle work)\nconst isWorkerContext = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n\n// Worker kernel source - inlined for zero-config deployment\n// Uses direct Worker postMessage for simple communication\n// Includes sync handle caching for performance (same as sync kernel)\nconst KERNEL_SOURCE = `\nconst LOCK_NAME = 'opfs_fs_lock';\nlet messageQueue = [];\nlet isReady = false;\nlet cachedRoot = null;\nconst dirCache = new Map();\n\n// Sync handle cache - MAJOR performance optimization\nconst syncHandleCache = new Map();\nconst MAX_HANDLES = 100;\n\nasync function getSyncHandle(filePath, create) {\n  const cached = syncHandleCache.get(filePath);\n  if (cached) return cached;\n\n  // Evict oldest handles if cache is full\n  if (syncHandleCache.size >= MAX_HANDLES) {\n    const keys = Array.from(syncHandleCache.keys()).slice(0, 10);\n    for (const key of keys) {\n      const h = syncHandleCache.get(key);\n      if (h) { try { h.close(); } catch {} syncHandleCache.delete(key); }\n    }\n  }\n\n  const fh = await getFileHandle(filePath, create);\n  const access = await fh.createSyncAccessHandle();\n  syncHandleCache.set(filePath, access);\n  return access;\n}\n\nfunction closeSyncHandle(filePath) {\n  const h = syncHandleCache.get(filePath);\n  if (h) { try { h.close(); } catch {} syncHandleCache.delete(filePath); }\n}\n\nfunction closeHandlesUnder(prefix) {\n  for (const [p, h] of syncHandleCache) {\n    if (p === prefix || p.startsWith(prefix + '/')) {\n      try { h.close(); } catch {}\n      syncHandleCache.delete(p);\n    }\n  }\n}\n\nasync function getRoot() {\n  if (!cachedRoot) {\n    cachedRoot = await navigator.storage.getDirectory();\n  }\n  return cachedRoot;\n}\n\nfunction parsePath(filePath) {\n  return filePath.split('/').filter(Boolean);\n}\n\nasync function getDirectoryHandle(parts, create = false) {\n  if (parts.length === 0) return getRoot();\n\n  const cacheKey = parts.join('/');\n  if (dirCache.has(cacheKey)) {\n    return dirCache.get(cacheKey);\n  }\n\n  let curr = await getRoot();\n  let pathSoFar = '';\n\n  for (const part of parts) {\n    pathSoFar += (pathSoFar ? '/' : '') + part;\n\n    if (dirCache.has(pathSoFar)) {\n      curr = dirCache.get(pathSoFar);\n    } else {\n      curr = await curr.getDirectoryHandle(part, { create });\n      dirCache.set(pathSoFar, curr);\n    }\n  }\n\n  return curr;\n}\n\nasync function getFileHandle(filePath, create = false) {\n  const parts = parsePath(filePath);\n  const fileName = parts.pop();\n  if (!fileName) throw new Error('Invalid file path');\n  const dir = parts.length > 0 ? await getDirectoryHandle(parts, create) : await getRoot();\n  return await dir.getFileHandle(fileName, { create });\n}\n\nasync function getParentAndName(filePath) {\n  const parts = parsePath(filePath);\n  const name = parts.pop();\n  if (!name) throw new Error('Invalid path');\n  const parent = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n  return { parent, name };\n}\n\nasync function handleRead(filePath, payload) {\n  const access = await getSyncHandle(filePath, false);\n  const size = access.getSize();\n  const offset = payload?.offset || 0;\n  const len = payload?.len || (size - offset);\n  const buf = new Uint8Array(len);\n  const bytesRead = access.read(buf, { at: offset });\n  return { data: buf.slice(0, bytesRead) };\n}\n\nasync function handleWrite(filePath, payload) {\n  const access = await getSyncHandle(filePath, true);\n  if (payload?.data) {\n    const offset = payload.offset ?? 0;\n    if (offset === 0) access.truncate(0);\n    access.write(payload.data, { at: offset });\n    access.flush();\n  }\n  return { success: true };\n}\n\nasync function handleAppend(filePath, payload) {\n  const access = await getSyncHandle(filePath, true);\n  if (payload?.data) {\n    const size = access.getSize();\n    access.write(payload.data, { at: size });\n    access.flush();\n  }\n  return { success: true };\n}\n\nasync function handleTruncate(filePath, payload) {\n  const access = await getSyncHandle(filePath, false);\n  access.truncate(payload?.len ?? 0);\n  access.flush();\n  return { success: true };\n}\n\nasync function handleStat(filePath) {\n  const parts = parsePath(filePath);\n  // Node.js compatible stat shape: mode 33188 = file (0o100644), 16877 = dir (0o40755)\n  if (parts.length === 0) {\n    return { size: 0, mtimeMs: Date.now(), mode: 16877, type: 'directory' };\n  }\n  const name = parts.pop();\n  const parent = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n  try {\n    const fh = await parent.getFileHandle(name);\n    // Use getFile() for metadata - faster than createSyncAccessHandle\n    const file = await fh.getFile();\n    return { size: file.size, mtimeMs: file.lastModified, mode: 33188, type: 'file' };\n  } catch {\n    try {\n      await parent.getDirectoryHandle(name);\n      return { size: 0, mtimeMs: Date.now(), mode: 16877, type: 'directory' };\n    } catch {\n      throw new Error('NotFoundError');\n    }\n  }\n}\n\nasync function handleExists(filePath) {\n  try {\n    await handleStat(filePath);\n    return { exists: true };\n  } catch {\n    return { exists: false };\n  }\n}\n\nasync function handleMkdir(filePath, payload) {\n  const parts = parsePath(filePath);\n  if (payload?.recursive) {\n    let curr = await getRoot();\n    for (const part of parts) {\n      curr = await curr.getDirectoryHandle(part, { create: true });\n    }\n  } else {\n    const name = parts.pop();\n    if (!name) throw new Error('Invalid path');\n    const parent = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n    await parent.getDirectoryHandle(name, { create: true });\n  }\n  return { success: true };\n}\n\nasync function handleRmdir(filePath, payload) {\n  closeHandlesUnder(filePath); // Close all cached handles under this directory\n  const { parent, name } = await getParentAndName(filePath);\n  if (payload?.recursive) {\n    await parent.removeEntry(name, { recursive: true });\n  } else {\n    const dir = await parent.getDirectoryHandle(name);\n    const entries = dir.entries();\n    const first = await entries.next();\n    if (!first.done) {\n      const e = new Error('InvalidModificationError');\n      e.name = 'InvalidModificationError';\n      throw e;\n    }\n    await parent.removeEntry(name);\n  }\n  return { success: true };\n}\n\nasync function handleUnlink(filePath) {\n  closeSyncHandle(filePath); // Close cached handle before deleting\n  const { parent, name } = await getParentAndName(filePath);\n  await parent.removeEntry(name);\n  return { success: true };\n}\n\nasync function handleReaddir(filePath) {\n  const parts = parsePath(filePath);\n  const dir = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n  const entries = [];\n  for await (const [name] of dir.entries()) {\n    entries.push(name);\n  }\n  return { entries };\n}\n\nasync function handleRename(oldPath, payload) {\n  if (!payload?.newPath) throw new Error('newPath required');\n  const newPath = payload.newPath;\n\n  // Close cached handles for old path (file will be deleted)\n  closeSyncHandle(oldPath);\n  closeHandlesUnder(oldPath); // For directory renames\n\n  const oldParts = parsePath(oldPath);\n  const newParts = parsePath(newPath);\n  const oldName = oldParts.pop();\n  const newName = newParts.pop();\n  const oldParent = oldParts.length > 0 ? await getDirectoryHandle(oldParts, false) : await getRoot();\n  const newParent = newParts.length > 0 ? await getDirectoryHandle(newParts, true) : await getRoot();\n\n  try {\n    const fh = await oldParent.getFileHandle(oldName);\n    const file = await fh.getFile();\n    const data = new Uint8Array(await file.arrayBuffer());\n\n    // Use cached handle for new file\n    const access = await getSyncHandle(newPath, true);\n    access.truncate(0);\n    access.write(data, { at: 0 });\n    access.flush();\n\n    await oldParent.removeEntry(oldName);\n    return { success: true };\n  } catch {\n    const oldDir = await oldParent.getDirectoryHandle(oldName);\n    async function copyDir(src, dst, dstPath) {\n      for await (const [name, handle] of src.entries()) {\n        if (handle.kind === 'file') {\n          const srcFile = await handle.getFile();\n          const data = new Uint8Array(await srcFile.arrayBuffer());\n          const filePath = dstPath + '/' + name;\n          const access = await getSyncHandle(filePath, true);\n          access.truncate(0);\n          access.write(data, { at: 0 });\n          access.flush();\n        } else {\n          const newSubDir = await dst.getDirectoryHandle(name, { create: true });\n          await copyDir(handle, newSubDir, dstPath + '/' + name);\n        }\n      }\n    }\n    const newDir = await newParent.getDirectoryHandle(newName, { create: true });\n    await copyDir(oldDir, newDir, newPath);\n    await oldParent.removeEntry(oldName, { recursive: true });\n    return { success: true };\n  }\n}\n\nasync function handleCopy(srcPath, payload) {\n  if (!payload?.newPath) throw new Error('newPath required');\n  const dstPath = payload.newPath;\n  const srcParts = parsePath(srcPath);\n  const srcName = srcParts.pop();\n  const srcParent = srcParts.length > 0 ? await getDirectoryHandle(srcParts, false) : await getRoot();\n  const srcFh = await srcParent.getFileHandle(srcName);\n  const srcFile = await srcFh.getFile();\n  const data = new Uint8Array(await srcFile.arrayBuffer());\n\n  // Use cached handle for destination\n  const access = await getSyncHandle(dstPath, true);\n  access.truncate(0);\n  access.write(data, { at: 0 });\n  access.flush();\n  return { success: true };\n}\n\nfunction handleFlush() {\n  // Flush all cached sync handles\n  for (const [, handle] of syncHandleCache) {\n    try { handle.flush(); } catch {}\n  }\n  return { success: true };\n}\n\nasync function processMessage(msg) {\n  const { type, path, payload } = msg;\n  switch (type) {\n    case 'read': return handleRead(path, payload);\n    case 'write': return handleWrite(path, payload);\n    case 'append': return handleAppend(path, payload);\n    case 'truncate': return handleTruncate(path, payload);\n    case 'stat': return handleStat(path);\n    case 'exists': return handleExists(path);\n    case 'mkdir': return handleMkdir(path, payload);\n    case 'rmdir': return handleRmdir(path, payload);\n    case 'unlink': return handleUnlink(path);\n    case 'readdir': return handleReaddir(path);\n    case 'rename': return handleRename(path, payload);\n    case 'copy': return handleCopy(path, payload);\n    case 'flush': return handleFlush();\n    default: throw new Error('Unknown operation: ' + type);\n  }\n}\n\nfunction sendAtomicsResponse(result, payload) {\n  const ctrl = payload.ctrl;\n  if (result.data && payload.dataBuffer) {\n    const view = new Uint8Array(payload.dataBuffer);\n    view.set(result.data);\n    Atomics.store(ctrl, 0, result.data.length);\n  } else if (result.entries && payload.resultBuffer) {\n    const json = JSON.stringify(result);\n    const encoded = new TextEncoder().encode(json);\n    const view = new Uint8Array(payload.resultBuffer);\n    view.set(encoded);\n    Atomics.store(ctrl, 0, encoded.length);\n  } else if (result.success) {\n    Atomics.store(ctrl, 0, 1);\n  } else if (result.exists !== undefined) {\n    Atomics.store(ctrl, 0, result.exists ? 1 : 0);\n  } else if (result.isFile !== undefined) {\n    if (payload.resultBuffer) {\n      const json = JSON.stringify(result);\n      const encoded = new TextEncoder().encode(json);\n      const view = new Uint8Array(payload.resultBuffer);\n      view.set(encoded);\n      Atomics.store(ctrl, 0, encoded.length);\n    } else {\n      Atomics.store(ctrl, 0, result.size || 0);\n    }\n  }\n  Atomics.notify(ctrl, 0);\n}\n\n// Handle incoming messages\nasync function handleMessage(msg) {\n  const { id, payload } = msg;\n  try {\n    const result = await processMessage(msg);\n    if (payload?.ctrl) {\n      sendAtomicsResponse(result, payload);\n    } else {\n      // Use Transferable for data to avoid copying\n      if (result.data) {\n        const buffer = result.data.buffer;\n        self.postMessage({ id, result }, [buffer]);\n      } else {\n        self.postMessage({ id, result });\n      }\n    }\n  } catch (e) {\n    const error = e instanceof Error ? e : new Error(String(e));\n    // Use error name if it's a specific DOM exception, otherwise use message\n    // (handleStat throws new Error('NotFoundError') where message contains the type)\n    const errorName = error.name || 'Error';\n    const errorCode = errorName !== 'Error' ? errorName : (error.message || 'Error');\n    if (payload?.ctrl) {\n      Atomics.store(payload.ctrl, 0, -1);\n      Atomics.notify(payload.ctrl, 0);\n    } else {\n      self.postMessage({ id, error: errorCode, code: errorCode });\n    }\n  }\n}\n\n// Serialize message processing to prevent race conditions with sync handle cache\n// Without this, concurrent operations could race for createSyncAccessHandle\nlet processingPromise = Promise.resolve();\n\nfunction queueMessage(msg) {\n  processingPromise = processingPromise.then(() => handleMessage(msg)).catch(() => {});\n}\n\n// Process queued messages after ready\nfunction processQueue() {\n  while (messageQueue.length > 0) {\n    const msg = messageQueue.shift();\n    queueMessage(msg);\n  }\n}\n\n// Queue messages until ready, then process sequentially\nself.onmessage = (event) => {\n  if (isReady) {\n    queueMessage(event.data);\n  } else {\n    messageQueue.push(event.data);\n  }\n};\n\n// Signal ready after a timeout to ensure main thread handler is set\nsetTimeout(() => {\n  isReady = true;\n  processQueue();\n  self.postMessage({ type: 'ready' });\n}, 10);\n`;\n\n// --- Helper functions ---\n\nfunction createStats(result: KernelResult): Stats {\n  // Support both new format (type, mtimeMs) and legacy format (isFile, isDirectory, mtime)\n  const isFile = result.type ? result.type === 'file' : (result.isFile ?? false);\n  const isDir = result.type ? result.type === 'directory' : (result.isDirectory ?? false);\n  const mtimeMs = result.mtimeMs ?? result.mtime ?? Date.now();\n  const size = result.size ?? 0;\n  const mode = result.mode ?? (isDir ? 16877 : 33188);\n\n  return {\n    isFile: () => isFile,\n    isDirectory: () => isDir,\n    isBlockDevice: () => false,\n    isCharacterDevice: () => false,\n    isSymbolicLink: () => false,\n    isFIFO: () => false,\n    isSocket: () => false,\n    dev: 0,\n    ino: 0,\n    mode,\n    nlink: 1,\n    uid: 0,\n    gid: 0,\n    rdev: 0,\n    size,\n    blksize: 4096,\n    blocks: Math.ceil(size / 512),\n    atimeMs: mtimeMs,\n    mtimeMs,\n    ctimeMs: mtimeMs,\n    birthtimeMs: mtimeMs,\n    atime: new Date(mtimeMs),\n    mtime: new Date(mtimeMs),\n    ctime: new Date(mtimeMs),\n    birthtime: new Date(mtimeMs),\n  };\n}\n\nfunction createDirent(name: string, isDir: boolean): Dirent {\n  return {\n    name,\n    isFile: () => !isDir,\n    isDirectory: () => isDir,\n    isBlockDevice: () => false,\n    isCharacterDevice: () => false,\n    isSymbolicLink: () => false,\n    isFIFO: () => false,\n    isSocket: () => false,\n  };\n}\n\nfunction generateId(): string {\n  return Math.random().toString(36).substring(2, 15);\n}\n\nfunction encodeData(data: Uint8Array | string, _encoding?: Encoding): Uint8Array {\n  if (typeof data === 'string') {\n    return new TextEncoder().encode(data);\n  }\n  return data;\n}\n\nfunction decodeData(data: Uint8Array, encoding?: Encoding | null): Uint8Array | string {\n  if (encoding === 'utf8' || encoding === 'utf-8') {\n    return new TextDecoder().decode(data);\n  }\n  return data;\n}\n\n// File descriptor entry for low-level read/write operations\ninterface FileDescriptor {\n  path: string;\n  flags: number;\n  position: number;\n}\n\nexport class OPFSFileSystem {\n  private worker: Worker | null = null;\n  private pending = new Map<string, { resolve: (v: KernelResult) => void; reject: (e: Error) => void; path: string; type: string }>();\n  private initialized = false;\n  private initPromise: Promise<void> | null = null;\n\n  // File descriptor table for openSync/readSync/writeSync/closeSync\n  private fdTable = new Map<number, FileDescriptor>();\n  private nextFd = 3; // Start at 3 (0=stdin, 1=stdout, 2=stderr)\n\n  // Stat cache - reduces FS traffic by 30-50% for git operations\n  private statCache = new Map<string, Stats>();\n\n  constructor() {\n    // Auto-initialize worker for fast async operations\n    this.initWorker();\n  }\n\n  // Invalidate stat cache for a path (and parent for directory operations)\n  private invalidateStat(filePath: string): void {\n    const absPath = path.normalize(path.resolve(filePath));\n    this.statCache.delete(absPath);\n    // Also invalidate parent directory (for readdir caching if added later)\n    const parent = path.dirname(absPath);\n    if (parent !== absPath) {\n      this.statCache.delete(parent);\n    }\n  }\n\n  // Invalidate all stats under a directory (for recursive operations)\n  private invalidateStatsUnder(dirPath: string): void {\n    const prefix = path.normalize(path.resolve(dirPath));\n    for (const key of this.statCache.keys()) {\n      if (key === prefix || key.startsWith(prefix + '/')) {\n        this.statCache.delete(key);\n      }\n    }\n  }\n\n  private async initWorker(): Promise<void> {\n    if (this.initialized) return;\n    if (this.initPromise) return this.initPromise;\n\n    this.initPromise = (async () => {\n      const blob = new Blob([KERNEL_SOURCE], { type: 'application/javascript' });\n      this.worker = new Worker(URL.createObjectURL(blob));\n\n      // Set up message handler FIRST, before worker can send 'ready'\n      const readyPromise = new Promise<void>((resolve) => {\n        this.worker!.onmessage = (event: MessageEvent<KernelResponse>) => {\n          const { id, result, error, code, type: msgType } = event.data;\n\n          // Handle ready signal\n          if (msgType === 'ready') {\n            resolve();\n            return;\n          }\n\n          const pending = this.pending.get(id);\n          if (pending) {\n            this.pending.delete(id);\n            if (error) {\n              // Map DOM exception names to Node.js-style error codes\n              // Use stored path from pending request (more reliable than extracting from error)\n              const errCode = code || 'Error';\n              if (errCode === 'NotFoundError' || errCode === 'NotAllowedError' ||\n                  errCode === 'TypeMismatchError' || errCode === 'InvalidModificationError' ||\n                  errCode === 'QuotaExceededError') {\n                pending.reject(mapErrorCode(errCode, pending.type, pending.path));\n              } else {\n                pending.reject(new FSError(errCode, -1, `${error}: ${pending.type} '${pending.path}'`));\n              }\n            } else if (result) {\n              pending.resolve(result);\n            }\n          }\n        };\n      });\n\n      await readyPromise;\n      this.initialized = true;\n    })();\n\n    return this.initPromise;\n  }\n\n  // Async call to worker - uses fast createSyncAccessHandle internally\n  private async asyncCall(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): Promise<KernelResult> {\n    await this.initWorker();\n\n    if (!this.worker) {\n      throw new Error('Worker not initialized');\n    }\n\n    const absPath = path.resolve(filePath);\n    const id = generateId();\n\n    return new Promise((resolve, reject) => {\n      this.pending.set(id, { resolve, reject, path: absPath, type });\n\n      const msg = {\n        id,\n        type,\n        path: absPath,\n        payload,\n      };\n\n      // Transfer ArrayBuffer if payload contains data (for writes)\n      if (payload?.data instanceof Uint8Array) {\n        // Clone the data since we're transferring - caller might still need original\n        const clone = new Uint8Array(payload.data);\n        const newPayload = { ...payload, data: clone };\n        this.worker!.postMessage({ ...msg, payload: newPayload }, [clone.buffer]);\n      } else {\n        this.worker!.postMessage(msg);\n      }\n    });\n  }\n\n  // Kernel worker for Tier 1 sync operations (loaded from URL, not blob)\n  private syncKernel: Worker | null = null;\n  private syncKernelReady = false;\n\n  /**\n   * Initialize sync operations with a kernel worker loaded from URL.\n   * Required for Tier 1 (SharedArrayBuffer + Atomics) to work in nested Workers.\n   * @param kernelUrl URL to the kernel.js file (defaults to '/kernel.js')\n   */\n  async initSync(kernelUrl = '/kernel.js'): Promise<void> {\n    if (this.syncKernelReady) return;\n\n    this.syncKernel = new Worker(kernelUrl, { type: 'module' });\n\n    await new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('Kernel init timeout')), 10000);\n      this.syncKernel!.onmessage = (e) => {\n        if (e.data?.type === 'ready') {\n          clearTimeout(timeout);\n          this.syncKernelReady = true;\n          resolve();\n        }\n      };\n      this.syncKernel!.onerror = (e) => {\n        clearTimeout(timeout);\n        reject(new Error(`Kernel error: ${e.message}`));\n      };\n    });\n  }\n\n  // Tier 1: SharedArrayBuffer + Atomics via kernel worker\n  // Data is transferred via SharedArrayBuffer (zero-copy)\n  // Synchronization via Atomics.wait/notify\n\n  // Buffer sizes for Tier 1 communication\n  private static readonly META_SIZE = 1024 * 64; // 64KB for metadata/results\n  private static readonly DEFAULT_DATA_SIZE = 1024 * 1024 * 10; // 10MB default buffer\n  private static readonly MAX_CHUNK_SIZE = 1024 * 1024 * 10; // 10MB max per chunk\n\n  // Reusable SharedArrayBuffer pool to prevent memory leaks\n  // SharedArrayBuffers are expensive to allocate and don't get GC'd quickly\n  private syncBufferPool: {\n    ctrl: SharedArrayBuffer;\n    meta: SharedArrayBuffer;\n    data: SharedArrayBuffer;\n    dataSize: number;\n  } | null = null;\n\n  private getSyncBuffers(requiredDataSize: number): {\n    ctrlBuffer: SharedArrayBuffer;\n    ctrl: Int32Array;\n    metaBuffer: SharedArrayBuffer;\n    dataBuffer: SharedArrayBuffer;\n  } {\n    // Reuse existing buffers if they're large enough\n    if (this.syncBufferPool && this.syncBufferPool.dataSize >= requiredDataSize) {\n      return {\n        ctrlBuffer: this.syncBufferPool.ctrl,\n        ctrl: new Int32Array(this.syncBufferPool.ctrl),\n        metaBuffer: this.syncBufferPool.meta,\n        dataBuffer: this.syncBufferPool.data,\n      };\n    }\n\n    // Allocate new buffers (or larger ones if needed)\n    const dataSize = Math.max(\n      OPFSFileSystem.DEFAULT_DATA_SIZE,\n      Math.min(requiredDataSize + 1024, 1024 * 1024 * 64) // Up to 64MB\n    );\n\n    const ctrlBuffer = new SharedArrayBuffer(4);\n    const metaBuffer = new SharedArrayBuffer(OPFSFileSystem.META_SIZE);\n    const dataBuffer = new SharedArrayBuffer(dataSize);\n\n    // Store in pool for reuse\n    this.syncBufferPool = {\n      ctrl: ctrlBuffer,\n      meta: metaBuffer,\n      data: dataBuffer,\n      dataSize,\n    };\n\n    return {\n      ctrlBuffer,\n      ctrl: new Int32Array(ctrlBuffer),\n      metaBuffer,\n      dataBuffer,\n    };\n  }\n\n  private syncCallTier1(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): KernelResult {\n    if (!this.syncKernel || !this.syncKernelReady) {\n      throw new Error('Sync kernel not initialized. Call initSync() first.');\n    }\n\n    // Path normalization: resolve and normalize to ensure consistent paths\n    // e.g., /foo/bar, foo/bar/, and /foo//bar all become /foo/bar\n    const absPath = path.normalize(path.resolve(filePath));\n\n    const data = payload?.data instanceof Uint8Array ? payload.data : null;\n    const dataSize = data?.length ?? 0;\n\n    // For large writes, use chunked approach\n    if (type === 'write' && data && dataSize > OPFSFileSystem.MAX_CHUNK_SIZE) {\n      return this.syncCallTier1Chunked(absPath, data);\n    }\n\n    // Get reusable SharedArrayBuffers from pool (prevents memory leaks)\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(dataSize);\n\n    // Initialize control signal to \"waiting\"\n    Atomics.store(ctrl, 0, 0);\n\n    // For write operations, copy data to SharedArrayBuffer\n    let dataLength = 0;\n    if (data) {\n      const view = new Uint8Array(dataBuffer);\n      view.set(data);\n      dataLength = data.length;\n    }\n\n    // Send command to kernel with SharedArrayBuffers\n    this.syncKernel.postMessage({\n      type,\n      path: absPath,\n      ctrlBuffer,\n      metaBuffer,\n      dataBuffer,\n      dataLength,\n      payload: payload ? { ...payload, data: undefined } : undefined,\n    });\n\n    // Block until kernel signals completion\n    const waitResult = Atomics.wait(ctrl, 0, 0, 30000);\n    if (waitResult === 'timed-out') {\n      throw new Error('Operation timed out');\n    }\n\n    const status = Atomics.load(ctrl, 0);\n\n    // Status codes:\n    // > 0: success, value indicates data length or result\n    // -1: error (error message in metaBuffer)\n    // -2: not found\n\n    if (status === -1) {\n      const metaView = new Uint8Array(metaBuffer);\n      let end = metaView.indexOf(0);\n      if (end === -1) end = OPFSFileSystem.META_SIZE;\n      const errorMsg = new TextDecoder().decode(metaView.slice(0, end));\n      throw mapErrorCode(errorMsg || 'Error', type, absPath);\n    }\n\n    if (status === -2) {\n      throw createENOENT(type, absPath);\n    }\n\n    // Parse result based on operation type\n    if (type === 'read') {\n      const bytesRead = status;\n      const bufferSize = dataBuffer.byteLength;\n\n      // If we filled the buffer completely, there might be more data\n      // Use stat to check total size and switch to chunked read if needed\n      if (bytesRead === bufferSize) {\n        const stat = this.syncStatTier1(absPath);\n        if (stat && stat.size > bytesRead) {\n          // File is larger than buffer, use chunked read from the beginning\n          return this.syncCallTier1ChunkedRead(absPath, stat.size);\n        }\n      }\n\n      const dataView = new Uint8Array(dataBuffer);\n      return { data: dataView.slice(0, bytesRead) };\n    }\n\n    if (type === 'stat') {\n      // Binary stat: [type:u8] [pad:3] [mode:u32] [size:f64] [mtimeMs:f64]\n      const view = new DataView(metaBuffer);\n      const typeVal = view.getUint8(0);\n      return {\n        type: typeVal === 0 ? 'file' : 'directory',\n        mode: view.getUint32(4, true),\n        size: view.getFloat64(8, true),\n        mtimeMs: view.getFloat64(16, true),\n      };\n    }\n\n    if (type === 'readdir') {\n      // Binary readdir: [count:u32] [len:u16 + utf8]...\n      const view = new DataView(metaBuffer);\n      const bytes = new Uint8Array(metaBuffer);\n      const count = view.getUint32(0, true);\n      const entries: string[] = [];\n      let offset = 4;\n      for (let i = 0; i < count; i++) {\n        const len = view.getUint16(offset, true);\n        offset += 2;\n        // Use slice() instead of subarray() to copy from SharedArrayBuffer (TextDecoder requires regular ArrayBuffer)\n        const name = new TextDecoder().decode(bytes.slice(offset, offset + len));\n        entries.push(name);\n        offset += len;\n      }\n      return { entries };\n    }\n\n    if (type === 'exists') {\n      return { exists: status === 1 };\n    }\n\n    return { success: status === 1 };\n  }\n\n  // Async version of syncCallTier1 using Atomics.waitAsync (works on main thread)\n  // This allows the main thread to use the fast SharedArrayBuffer path without blocking\n  private async syncCallTier1Async(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): Promise<KernelResult> {\n    if (!this.syncKernel || !this.syncKernelReady) {\n      throw new Error('Sync kernel not initialized. Call initSync() first.');\n    }\n\n    const absPath = path.normalize(path.resolve(filePath));\n    const data = payload?.data instanceof Uint8Array ? payload.data : null;\n    const dataSize = data?.length ?? 0;\n\n    // For large writes, use chunked approach (async version)\n    if (type === 'write' && data && dataSize > OPFSFileSystem.MAX_CHUNK_SIZE) {\n      return this.syncCallTier1ChunkedAsync(absPath, data);\n    }\n\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(dataSize);\n\n    Atomics.store(ctrl, 0, 0);\n\n    let dataLength = 0;\n    if (data) {\n      const view = new Uint8Array(dataBuffer);\n      view.set(data);\n      dataLength = data.length;\n    }\n\n    this.syncKernel.postMessage({\n      type,\n      path: absPath,\n      ctrlBuffer,\n      metaBuffer,\n      dataBuffer,\n      dataLength,\n      payload: payload ? { ...payload, data: undefined } : undefined,\n    });\n\n    // Use Atomics.waitAsync for non-blocking wait (works on main thread)\n    const waitResult = await Atomics.waitAsync(ctrl, 0, 0, 30000).value;\n    if (waitResult === 'timed-out') {\n      throw new Error('Operation timed out');\n    }\n\n    const status = Atomics.load(ctrl, 0);\n\n    if (status === -1) {\n      const metaView = new Uint8Array(metaBuffer);\n      let end = metaView.indexOf(0);\n      if (end === -1) end = OPFSFileSystem.META_SIZE;\n      const errorMsg = new TextDecoder().decode(metaView.slice(0, end));\n      throw mapErrorCode(errorMsg || 'Error', type, absPath);\n    }\n\n    if (status === -2) {\n      throw createENOENT(type, absPath);\n    }\n\n    // Parse result based on operation type\n    if (type === 'read') {\n      const bytesRead = status;\n      const bufferSize = dataBuffer.byteLength;\n\n      if (bytesRead === bufferSize) {\n        const stat = await this.syncStatTier1Async(absPath);\n        if (stat && stat.size > bytesRead) {\n          return this.syncCallTier1ChunkedReadAsync(absPath, stat.size);\n        }\n      }\n\n      const dataView = new Uint8Array(dataBuffer);\n      return { data: dataView.slice(0, bytesRead) };\n    }\n\n    if (type === 'stat') {\n      const view = new DataView(metaBuffer);\n      const typeVal = view.getUint8(0);\n      return {\n        type: typeVal === 0 ? 'file' : 'directory',\n        mode: view.getUint32(4, true),\n        size: view.getFloat64(8, true),\n        mtimeMs: view.getFloat64(16, true),\n      };\n    }\n\n    if (type === 'readdir') {\n      const view = new DataView(metaBuffer);\n      const bytes = new Uint8Array(metaBuffer);\n      const count = view.getUint32(0, true);\n      const entries: string[] = [];\n      let offset = 4;\n      for (let i = 0; i < count; i++) {\n        const len = view.getUint16(offset, true);\n        offset += 2;\n        // Use slice() instead of subarray() to copy from SharedArrayBuffer (TextDecoder requires regular ArrayBuffer)\n        const name = new TextDecoder().decode(bytes.slice(offset, offset + len));\n        entries.push(name);\n        offset += len;\n      }\n      return { entries };\n    }\n\n    if (type === 'exists') {\n      return { exists: status === 1 };\n    }\n\n    return { success: status === 1 };\n  }\n\n  // Async stat helper for main thread\n  private async syncStatTier1Async(absPath: string): Promise<{ size: number } | null> {\n    try {\n      const result = await this.syncCallTier1Async('stat', absPath);\n      return { size: result.size as number };\n    } catch {\n      return null;\n    }\n  }\n\n  // Async chunked write for main thread\n  private async syncCallTier1ChunkedAsync(\n    absPath: string,\n    data: Uint8Array\n  ): Promise<KernelResult> {\n    const totalSize = data.length;\n    let offset = 0;\n\n    while (offset < totalSize) {\n      const remaining = totalSize - offset;\n      const currentChunkSize = Math.min(remaining, OPFSFileSystem.MAX_CHUNK_SIZE);\n      const chunk = data.subarray(offset, offset + currentChunkSize);\n\n      const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(currentChunkSize);\n      Atomics.store(ctrl, 0, 0);\n\n      const view = new Uint8Array(dataBuffer);\n      view.set(chunk);\n\n      const isFirstChunk = offset === 0;\n      this.syncKernel!.postMessage({\n        type: isFirstChunk ? 'write' : 'append',\n        path: absPath,\n        ctrlBuffer,\n        metaBuffer,\n        dataBuffer,\n        dataLength: currentChunkSize,\n        payload: { flush: false },\n      });\n\n      const waitResult = await Atomics.waitAsync(ctrl, 0, 0, 30000).value;\n      if (waitResult === 'timed-out') {\n        throw new Error('Chunked write timed out');\n      }\n\n      const status = Atomics.load(ctrl, 0);\n      if (status === -1 || status === -2) {\n        throw createENOENT('write', absPath);\n      }\n\n      offset += currentChunkSize;\n    }\n\n    return { success: true };\n  }\n\n  // Async chunked read for main thread\n  private async syncCallTier1ChunkedReadAsync(\n    absPath: string,\n    totalSize: number\n  ): Promise<KernelResult> {\n    const result = new Uint8Array(totalSize);\n    let offset = 0;\n\n    while (offset < totalSize) {\n      const remaining = totalSize - offset;\n      const currentChunkSize = Math.min(remaining, OPFSFileSystem.MAX_CHUNK_SIZE);\n\n      const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(currentChunkSize);\n      Atomics.store(ctrl, 0, 0);\n\n      this.syncKernel!.postMessage({\n        type: 'readChunk',\n        path: absPath,\n        ctrlBuffer,\n        metaBuffer,\n        dataBuffer,\n        dataLength: 0,\n        payload: { offset, length: currentChunkSize },\n      });\n\n      const waitResult = await Atomics.waitAsync(ctrl, 0, 0, 30000).value;\n      if (waitResult === 'timed-out') {\n        throw new Error('Chunked read timed out');\n      }\n\n      const status = Atomics.load(ctrl, 0);\n      if (status === -1 || status === -2) {\n        throw createENOENT('read', absPath);\n      }\n\n      const bytesRead = status;\n      const dataView = new Uint8Array(dataBuffer);\n      result.set(dataView.subarray(0, bytesRead), offset);\n      offset += bytesRead;\n    }\n\n    return { data: result };\n  }\n\n  // Chunked write for files larger than MAX_CHUNK_SIZE\n  private syncCallTier1Chunked(\n    absPath: string,\n    data: Uint8Array\n  ): KernelResult {\n    const totalSize = data.length;\n    const chunkSize = OPFSFileSystem.MAX_CHUNK_SIZE;\n\n    // Reuse buffers from pool (prevents memory leaks)\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(chunkSize);\n    const dataView = new Uint8Array(dataBuffer);\n\n    let offset = 0;\n    while (offset < totalSize) {\n      const remaining = totalSize - offset;\n      const currentChunkSize = Math.min(chunkSize, remaining);\n      const chunk = data.subarray(offset, offset + currentChunkSize);\n\n      // Reset control signal\n      Atomics.store(ctrl, 0, 0);\n\n      // Copy chunk to SharedArrayBuffer\n      dataView.set(chunk);\n\n      // First chunk: truncate file (offset 0), subsequent chunks: append at offset\n      this.syncKernel!.postMessage({\n        type: 'write',\n        path: absPath,\n        ctrlBuffer,\n        metaBuffer,\n        dataBuffer,\n        dataLength: currentChunkSize,\n        payload: { offset }, // Kernel writes at this offset\n      });\n\n      // Wait for completion\n      const waitResult = Atomics.wait(ctrl, 0, 0, 60000); // Longer timeout for large chunks\n      if (waitResult === 'timed-out') {\n        throw new Error(`Chunked write timed out at offset ${offset}`);\n      }\n\n      const status = Atomics.load(ctrl, 0);\n      if (status === -1) {\n        const metaView = new Uint8Array(metaBuffer);\n        let end = metaView.indexOf(0);\n        if (end === -1) end = OPFSFileSystem.META_SIZE;\n        const errorMsg = new TextDecoder().decode(metaView.slice(0, end));\n        throw mapErrorCode(errorMsg || 'Error', 'write', absPath);\n      }\n      if (status === -2) {\n        throw createENOENT('write', absPath);\n      }\n\n      offset += currentChunkSize;\n    }\n\n    return { success: true };\n  }\n\n  // Chunked read for files larger than buffer size\n  private syncCallTier1ChunkedRead(\n    absPath: string,\n    totalSize: number\n  ): KernelResult {\n    const chunkSize = OPFSFileSystem.MAX_CHUNK_SIZE;\n\n    // Allocate result buffer on main thread\n    const result = new Uint8Array(totalSize);\n\n    // Reuse buffers from pool (prevents memory leaks)\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(chunkSize);\n\n    let offset = 0;\n    while (offset < totalSize) {\n      const remaining = totalSize - offset;\n      const currentChunkSize = Math.min(chunkSize, remaining);\n\n      // Reset control signal\n      Atomics.store(ctrl, 0, 0);\n\n      // Request chunk from kernel\n      this.syncKernel!.postMessage({\n        type: 'read',\n        path: absPath,\n        ctrlBuffer,\n        metaBuffer,\n        dataBuffer,\n        dataLength: 0,\n        payload: { offset, len: currentChunkSize },\n      });\n\n      // Wait for completion\n      const waitResult = Atomics.wait(ctrl, 0, 0, 60000);\n      if (waitResult === 'timed-out') {\n        throw new Error(`Chunked read timed out at offset ${offset}`);\n      }\n\n      const status = Atomics.load(ctrl, 0);\n      if (status === -1) {\n        const metaView = new Uint8Array(metaBuffer);\n        let end = metaView.indexOf(0);\n        if (end === -1) end = OPFSFileSystem.META_SIZE;\n        const errorMsg = new TextDecoder().decode(metaView.slice(0, end));\n        throw mapErrorCode(errorMsg || 'Error', 'read', absPath);\n      }\n      if (status === -2) {\n        throw createENOENT('read', absPath);\n      }\n\n      // Copy chunk from SharedArrayBuffer to result\n      const bytesRead = status;\n      const dataView = new Uint8Array(dataBuffer, 0, bytesRead);\n      result.set(dataView, offset);\n\n      offset += bytesRead;\n\n      // If we read less than requested, we've reached EOF\n      if (bytesRead < currentChunkSize) {\n        break;\n      }\n    }\n\n    return { data: result.subarray(0, offset) };\n  }\n\n  // Get file size via stat (used for chunked reads)\n  private syncStatTier1(absPath: string): { size: number } | null {\n    // Reuse buffers from pool (prevents memory leaks)\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(1024);\n\n    Atomics.store(ctrl, 0, 0);\n\n    this.syncKernel!.postMessage({\n      type: 'stat',\n      path: absPath,\n      ctrlBuffer,\n      metaBuffer,\n      dataBuffer,\n      dataLength: 0,\n    });\n\n    const waitResult = Atomics.wait(ctrl, 0, 0, 10000);\n    if (waitResult === 'timed-out') {\n      return null;\n    }\n\n    const status = Atomics.load(ctrl, 0);\n    if (status <= 0) {\n      return null;\n    }\n\n    // Binary stat: [type:u8] [pad:3] [mode:u32] [size:f64] [mtimeMs:f64]\n    const view = new DataView(metaBuffer);\n    return { size: view.getFloat64(8, true) };\n  }\n\n  private syncCall(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): KernelResult {\n    // Sync operations require SharedArrayBuffer + Atomics\n    // This requires crossOriginIsolated (COOP/COEP headers) and initSync() to be called\n    if (\n      isWorkerContext &&\n      typeof SharedArrayBuffer !== 'undefined' &&\n      this.syncKernelReady\n    ) {\n      return this.syncCallTier1(type, filePath, payload);\n    }\n\n    // No sync tier available - throw helpful error\n    throw new Error(\n      `Sync operations require crossOriginIsolated environment (COOP/COEP headers) and initSync() to be called. ` +\n      `Current state: crossOriginIsolated=${typeof crossOriginIsolated !== 'undefined' ? crossOriginIsolated : 'N/A'}, ` +\n      `isWorkerContext=${isWorkerContext}, syncKernelReady=${this.syncKernelReady}. ` +\n      `Use fs.promises.* for async operations that work everywhere.`\n    );\n  }\n\n  // --- Synchronous API (Node.js fs compatible) ---\n\n  readFileSync(filePath: string, options?: ReadOptions | Encoding | null): Uint8Array | string {\n    const encoding = typeof options === 'string' ? options : options?.encoding;\n    const result = this.syncCall('read', filePath);\n    if (!result.data) throw createENOENT('read', filePath);\n    return decodeData(result.data, encoding);\n  }\n\n  writeFileSync(filePath: string, data: Uint8Array | string, options?: WriteOptions | Encoding): void {\n    const opts = typeof options === 'string' ? { encoding: options } : options;\n    const encoded = encodeData(data, opts?.encoding);\n    // Pass flush option (defaults to true in kernel for safety)\n    this.syncCall('write', filePath, { data: encoded, flush: opts?.flush });\n    this.invalidateStat(filePath);\n  }\n\n  appendFileSync(filePath: string, data: Uint8Array | string, options?: WriteOptions | Encoding): void {\n    const encoding = typeof options === 'string' ? options : options?.encoding;\n    const encoded = encodeData(data, encoding);\n    this.syncCall('append', filePath, { data: encoded });\n    this.invalidateStat(filePath);\n  }\n\n  existsSync(filePath: string): boolean {\n    try {\n      const result = this.syncCall('exists', filePath);\n      return result.exists ?? false;\n    } catch {\n      return false;\n    }\n  }\n\n  mkdirSync(filePath: string, options?: MkdirOptions | number): string | undefined {\n    const recursive = typeof options === 'object' ? options?.recursive : false;\n    this.syncCall('mkdir', filePath, { recursive });\n    this.invalidateStat(filePath);\n    return recursive ? filePath : undefined;\n  }\n\n  rmdirSync(filePath: string, options?: RmdirOptions): void {\n    this.syncCall('rmdir', filePath, { recursive: options?.recursive });\n    if (options?.recursive) {\n      this.invalidateStatsUnder(filePath);\n    } else {\n      this.invalidateStat(filePath);\n    }\n  }\n\n  rmSync(filePath: string, options?: RmOptions): void {\n    try {\n      const result = this.syncCall('stat', filePath);\n      try {\n        if (result.isDirectory || result.type === 'directory') {\n          this.syncCall('rmdir', filePath, { recursive: options?.recursive });\n          if (options?.recursive) {\n            this.invalidateStatsUnder(filePath);\n          } else {\n            this.invalidateStat(filePath);\n          }\n        } else {\n          this.syncCall('unlink', filePath);\n          this.invalidateStat(filePath);\n        }\n      } catch (e) {\n        // Handle errors from rmdir/unlink with force option\n        if (!options?.force) throw e;\n      }\n    } catch (e) {\n      // Handle errors from stat with force option\n      if (!options?.force) throw e;\n    }\n  }\n\n  unlinkSync(filePath: string): void {\n    this.syncCall('unlink', filePath);\n    this.invalidateStat(filePath);\n  }\n\n  readdirSync(filePath: string, options?: ReaddirOptions | Encoding | null): string[] | Dirent[] {\n    const result = this.syncCall('readdir', filePath);\n    const entries = result.entries || [];\n\n    const opts = typeof options === 'object' ? options : { encoding: options };\n\n    if (opts?.withFileTypes) {\n      return entries.map((name) => {\n        try {\n          const stat = this.syncCall('stat', path.join(filePath, name));\n          // Check type first (from kernel result), fall back to isDirectory boolean\n          const isDir = stat.type === 'directory' || stat.isDirectory === true;\n          return createDirent(name, isDir);\n        } catch {\n          return createDirent(name, false);\n        }\n      });\n    }\n\n    return entries;\n  }\n\n  statSync(filePath: string): Stats {\n    const absPath = path.normalize(path.resolve(filePath));\n\n    // Check cache first\n    const cached = this.statCache.get(absPath);\n    if (cached) return cached;\n\n    const result = this.syncCall('stat', filePath);\n    // Check for both new format (type) and legacy format (isFile/isDirectory)\n    if (result.type === undefined && result.isFile === undefined && result.isDirectory === undefined) {\n      throw createENOENT('stat', filePath);\n    }\n    const stats = createStats(result);\n\n    // Cache the result\n    this.statCache.set(absPath, stats);\n    return stats;\n  }\n\n  lstatSync(filePath: string): Stats {\n    return this.statSync(filePath);\n  }\n\n  renameSync(oldPath: string, newPath: string): void {\n    this.syncCall('rename', oldPath, { newPath });\n    this.invalidateStat(oldPath);\n    this.invalidateStat(newPath);\n  }\n\n  copyFileSync(src: string, dest: string): void {\n    this.syncCall('copy', src, { newPath: dest });\n    this.invalidateStat(dest);\n  }\n\n  truncateSync(filePath: string, len = 0): void {\n    this.syncCall('truncate', filePath, { len });\n    this.invalidateStat(filePath);\n  }\n\n  /**\n   * Flush all pending writes to storage.\n   * Use this after writes with { flush: false } to ensure data is persisted.\n   */\n  flushSync(): void {\n    this.syncCall('flush', '/');\n  }\n\n  /**\n   * Alias for flushSync() - matches Node.js fdatasync behavior\n   */\n  fdatasyncSync(): void {\n    this.flushSync();\n  }\n\n  accessSync(filePath: string, _mode?: number): void {\n    const exists = this.existsSync(filePath);\n    if (!exists) {\n      throw createENOENT('access', filePath);\n    }\n  }\n\n  // --- Low-level File Descriptor API ---\n  // For efficient packfile access (read specific offsets without loading entire file)\n\n  openSync(filePath: string, flags: string | number = 'r'): number {\n    // Verify file exists for read modes\n    const flagNum = typeof flags === 'string' ? this.parseFlags(flags) : flags;\n    const isReadOnly = (flagNum & constants.O_WRONLY) === 0 && (flagNum & constants.O_RDWR) === 0;\n\n    if (isReadOnly && !this.existsSync(filePath)) {\n      throw createENOENT('open', filePath);\n    }\n\n    const fd = this.nextFd++;\n    this.fdTable.set(fd, {\n      path: path.normalize(path.resolve(filePath)),\n      flags: flagNum,\n      position: 0,\n    });\n    return fd;\n  }\n\n  closeSync(fd: number): void {\n    if (!this.fdTable.has(fd)) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n    this.fdTable.delete(fd);\n  }\n\n  readSync(\n    fd: number,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number | null\n  ): number {\n    const entry = this.fdTable.get(fd);\n    if (!entry) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n\n    const readPos = position !== null ? position : entry.position;\n    const result = this.syncCall('read', entry.path, { offset: readPos, len: length });\n\n    if (!result.data) {\n      return 0; // EOF or error\n    }\n\n    // Copy data into the provided buffer at the specified offset\n    const bytesRead = Math.min(result.data.length, length);\n    buffer.set(result.data.subarray(0, bytesRead), offset);\n\n    // Update position if not using explicit position\n    if (position === null) {\n      entry.position += bytesRead;\n    }\n\n    return bytesRead;\n  }\n\n  writeSync(\n    fd: number,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number | null\n  ): number {\n    const entry = this.fdTable.get(fd);\n    if (!entry) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n\n    const writePos = position !== null ? position : entry.position;\n    const data = buffer.subarray(offset, offset + length);\n\n    // Use truncate: false to avoid truncating on positional writes\n    this.syncCall('write', entry.path, {\n      data,\n      offset: writePos,\n      truncate: false,\n    });\n\n    // Invalidate stat cache after write\n    this.invalidateStat(entry.path);\n\n    // Update position if not using explicit position\n    if (position === null) {\n      entry.position += length;\n    }\n\n    return length;\n  }\n\n  fstatSync(fd: number): Stats {\n    const entry = this.fdTable.get(fd);\n    if (!entry) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n    return this.statSync(entry.path);\n  }\n\n  private parseFlags(flags: string): number {\n    switch (flags) {\n      case 'r': return constants.O_RDONLY;\n      case 'r+': return constants.O_RDWR;\n      case 'w': return constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC;\n      case 'w+': return constants.O_RDWR | constants.O_CREAT | constants.O_TRUNC;\n      case 'a': return constants.O_WRONLY | constants.O_CREAT | constants.O_APPEND;\n      case 'a+': return constants.O_RDWR | constants.O_CREAT | constants.O_APPEND;\n      default: return constants.O_RDONLY;\n    }\n  }\n\n  // --- Async Promises API ---\n  // When Tier 1 sync kernel is available, use it for better performance (wrapped in Promise)\n  // Otherwise fall back to async worker\n\n  // Helper: Use sync kernel if available (in worker context), otherwise async worker\n  private async fastCall(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): Promise<KernelResult> {\n    // Use sync kernel when available for best performance\n    // Benefits of sync kernel:\n    // 1. SharedArrayBuffer zero-copy data transfer\n    // 2. Optimized sync handle caching\n    // 3. No postMessage serialization overhead\n    if (this.syncKernelReady) {\n      if (isWorkerContext) {\n        // In Worker: use blocking Atomics.wait (fastest)\n        return Promise.resolve(this.syncCallTier1(type, filePath, payload));\n      } else {\n        // Main thread: use Atomics.waitAsync (non-blocking but still fast)\n        return this.syncCallTier1Async(type, filePath, payload);\n      }\n    }\n    // Fallback to async worker\n    return this.asyncCall(type, filePath, payload);\n  }\n\n  promises: FileSystemPromises = {\n    readFile: async (filePath: string, options?: ReadOptions | Encoding | null) => {\n      // Validate path - isomorphic-git sometimes calls with no args\n      if (!filePath) {\n        throw createENOENT('read', filePath || '');\n      }\n      const encoding = typeof options === 'string' ? options : options?.encoding;\n\n      // Use sync kernel if available (faster than async worker)\n      if (this.syncKernelReady) {\n        if (isWorkerContext) {\n          // Worker: blocking wait (fastest)\n          const result = this.syncCallTier1('read', filePath);\n          if (!result.data) throw createENOENT('read', filePath);\n          return decodeData(result.data, encoding);\n        } else {\n          // Main thread: use Atomics.waitAsync (non-blocking)\n          const result = await this.syncCallTier1Async('read', filePath);\n          if (!result.data) throw createENOENT('read', filePath);\n          return decodeData(result.data, encoding);\n        }\n      }\n\n      // Fallback to async worker (no sync kernel) - ensures consistent read/write path\n      // Using asyncCall ensures reads go through same worker as writes,\n      // which is important for file locking and cache consistency\n      const result = await this.asyncCall('read', filePath);\n      if (!result.data) throw createENOENT('read', filePath);\n      return decodeData(result.data, encoding);\n    },\n\n    writeFile: async (filePath: string, data: Uint8Array | string, options?: WriteOptions | Encoding) => {\n      const encoding = typeof options === 'string' ? options : options?.encoding;\n      const encoded = encodeData(data, encoding);\n      await this.fastCall('write', filePath, { data: encoded });\n    },\n\n    appendFile: async (filePath: string, data: Uint8Array | string, options?: WriteOptions | Encoding) => {\n      const encoding = typeof options === 'string' ? options : options?.encoding;\n      const encoded = encodeData(data, encoding);\n      await this.fastCall('append', filePath, { data: encoded });\n    },\n\n    mkdir: async (filePath: string, options?: MkdirOptions | number) => {\n      const recursive = typeof options === 'object' ? options?.recursive : false;\n      await this.fastCall('mkdir', filePath, { recursive });\n      return recursive ? filePath : undefined;\n    },\n\n    rmdir: async (filePath: string, options?: RmdirOptions) => {\n      await this.fastCall('rmdir', filePath, { recursive: options?.recursive });\n    },\n\n    rm: async (filePath: string, options?: RmOptions) => {\n      try {\n        const result = await this.fastCall('stat', filePath);\n        try {\n          if (result.isDirectory || result.type === 'directory') {\n            await this.fastCall('rmdir', filePath, { recursive: options?.recursive });\n          } else {\n            await this.fastCall('unlink', filePath);\n          }\n        } catch (e) {\n          // Handle errors from rmdir/unlink with force option\n          if (!options?.force) throw e;\n        }\n      } catch (e) {\n        // Handle errors from stat with force option\n        if (!options?.force) throw e;\n      }\n    },\n\n    unlink: async (filePath: string) => {\n      await this.fastCall('unlink', filePath);\n    },\n\n    readdir: async (filePath: string, options?: ReaddirOptions | Encoding | null) => {\n      const result = await this.fastCall('readdir', filePath);\n      const entries = result.entries || [];\n      const opts = typeof options === 'object' ? options : { encoding: options };\n\n      if (opts?.withFileTypes) {\n        const dirents: Dirent[] = [];\n        for (const name of entries) {\n          try {\n            const stat = await this.fastCall('stat', path.join(filePath, name));\n            // Check type first (from kernel result), fall back to isDirectory boolean\n            const isDir = stat.type === 'directory' || stat.isDirectory === true;\n            dirents.push(createDirent(name, isDir));\n          } catch {\n            dirents.push(createDirent(name, false));\n          }\n        }\n        return dirents;\n      }\n\n      return entries;\n    },\n\n    stat: async (filePath: string) => {\n      const result = await this.fastCall('stat', filePath);\n      return createStats(result);\n    },\n\n    access: async (filePath: string, _mode?: number) => {\n      const result = await this.fastCall('exists', filePath);\n      if (!result.exists) {\n        throw createENOENT('access', filePath);\n      }\n    },\n\n    rename: async (oldFilePath: string, newFilePath: string) => {\n      await this.fastCall('rename', oldFilePath, { newPath: path.resolve(newFilePath) });\n    },\n\n    copyFile: async (srcPath: string, destPath: string) => {\n      await this.fastCall('copy', srcPath, { newPath: path.resolve(destPath) });\n    },\n  };\n\n  // Constants\n  constants = constants;\n}\n","/**\n * OPFS-FS: Battle-tested OPFS-based Node.js fs polyfill\n *\n * Provides a Node.js-compatible filesystem API that works in browsers using OPFS.\n *\n * Features:\n * - Synchronous API: fs.readFileSync, fs.writeFileSync, etc. (requires crossOriginIsolated)\n * - Async Promises API: fs.promises.readFile, fs.promises.writeFile, etc.\n * - Cross-tab safety via navigator.locks\n *\n * Performance Tiers:\n * - Tier 1 (Sync): SharedArrayBuffer + Atomics - requires crossOriginIsolated (COOP/COEP headers)\n * - Tier 2 (Async): Promises API - always available\n *\n * @example\n * ```typescript\n * import { fs } from 'opfs-fs';\n *\n * // Sync API (requires crossOriginIsolated)\n * fs.writeFileSync('/hello.txt', 'Hello World!');\n * const data = fs.readFileSync('/hello.txt', 'utf8');\n *\n * // Async API (always available)\n * await fs.promises.writeFile('/async.txt', 'Async data');\n * const content = await fs.promises.readFile('/async.txt', 'utf8');\n * ```\n */\n\nexport { OPFSFileSystem } from './filesystem.js';\nexport { constants } from './constants.js';\nexport { FSError, createENOENT, createEEXIST, createEISDIR, createENOTDIR, createENOTEMPTY, createEACCES, createEINVAL, mapErrorCode } from './errors.js';\nexport * as path from './path.js';\nexport type {\n  Stats,\n  Dirent,\n  ReadOptions,\n  WriteOptions,\n  MkdirOptions,\n  RmdirOptions,\n  RmOptions,\n  ReaddirOptions,\n  Encoding,\n  FileSystemPromises,\n  PathLike,\n} from './types.js';\n\nimport { OPFSFileSystem } from './filesystem.js';\n\n// Default singleton instance\nexport const fs = new OPFSFileSystem();\n\n// Default export for convenience\nexport default fs;\n"]}