{"version":3,"sources":["../src/src/protocol/opcodes.ts","../src/src/errors.ts","../src/src/methods/readFile.ts","../src/src/methods/writeFile.ts","../src/src/methods/appendFile.ts","../src/src/methods/exists.ts","../src/src/methods/mkdir.ts","../src/src/methods/rmdir.ts","../src/src/methods/rm.ts","../src/src/methods/unlink.ts","../src/src/vfs/layout.ts","../src/src/stats.ts","../src/src/methods/readdir.ts","../src/src/methods/stat.ts","../src/src/methods/rename.ts","../src/src/methods/copyFile.ts","../src/src/methods/truncate.ts","../src/src/constants.ts","../src/src/methods/access.ts","../src/src/methods/realpath.ts","../src/src/methods/chmod.ts","../src/src/methods/chown.ts","../src/src/methods/utimes.ts","../src/src/methods/symlink.ts","../src/src/methods/link.ts","../src/src/methods/mkdtemp.ts","../src/src/methods/open.ts","../src/src/methods/opendir.ts","../src/src/path.ts","../src/src/methods/watch.ts","../src/src/filesystem.ts","../src/src/vfs/engine.ts","../src/src/helpers.ts","../src/src/index.ts"],"names":["decoder","encoder","status","isAbsolute","resolve","bc","inode","data","totalSize","buf","view","offset","basename","file"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * Binary protocol operation codes and header encoding/decoding.\n * All inter-worker messages use this minimal binary protocol  no JSON, no strings.\n */\n\n// Operation codes\nexport const OP = {\n  READ: 1,\n  WRITE: 2,\n  UNLINK: 3,\n  STAT: 4,\n  LSTAT: 5,\n  MKDIR: 6,\n  RMDIR: 7,\n  READDIR: 8,\n  RENAME: 9,\n  EXISTS: 10,\n  TRUNCATE: 11,\n  APPEND: 12,\n  COPY: 13,\n  ACCESS: 14,\n  REALPATH: 15,\n  CHMOD: 16,\n  CHOWN: 17,\n  UTIMES: 18,\n  SYMLINK: 19,\n  READLINK: 20,\n  LINK: 21,\n  OPEN: 22,\n  CLOSE: 23,\n  FREAD: 24,\n  FWRITE: 25,\n  FSTAT: 26,\n  FTRUNCATE: 27,\n  FSYNC: 28,\n  OPENDIR: 29,\n  MKDTEMP: 30,\n} as const;\n\nexport type OpCode = (typeof OP)[keyof typeof OP];\n\n// Response status codes\nexport const STATUS = {\n  OK: 0,\n  ENOENT: 1,\n  EEXIST: 2,\n  EISDIR: 3,\n  ENOTDIR: 4,\n  ENOTEMPTY: 5,\n  EACCES: 6,\n  EINVAL: 7,\n  EBADF: 8,\n  ELOOP: 9,\n  ENOSPC: 10,\n} as const;\n\n// SAB layout offsets\nexport const SAB_OFFSETS = {\n  CONTROL: 0,       // Int32 - signal (0=idle, 1=request, 2=response, 3=chunk, 4=ack)\n  OPCODE: 4,        // Int32 - operation code\n  STATUS: 8,        // Int32 - response status / error\n  CHUNK_LEN: 12,    // Int32 - bytes in this chunk\n  TOTAL_LEN: 16,    // BigUint64 - full data size across all chunks\n  CHUNK_IDX: 24,    // Int32 - 0-based chunk index\n  RESERVED: 28,     // Int32 - reserved\n  HEADER_SIZE: 32,  // Data payload starts here\n} as const;\n\n// SAB control signals\nexport const SIGNAL = {\n  IDLE: 0,\n  REQUEST: 1,\n  RESPONSE: 2,\n  CHUNK: 3,\n  CHUNK_ACK: 4,\n} as const;\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\n/**\n * Encode a request into an ArrayBuffer for MessageChannel transfer.\n *\n * Request format (16-byte header + path + data):\n *   bytes 0-3:   operation (uint32)\n *   bytes 4-7:   flags (uint32)\n *   bytes 8-11:  pathLen (uint32)\n *   bytes 12-15: dataLen (uint32)\n *   bytes 16+:   path (UTF-8)\n *   bytes 16+pathLen: data payload\n */\nexport function encodeRequest(\n  op: number,\n  path: string,\n  flags: number = 0,\n  data?: Uint8Array\n): ArrayBuffer {\n  const pathBytes = encoder.encode(path);\n  const dataLen = data ? data.byteLength : 0;\n  const totalLen = 16 + pathBytes.byteLength + dataLen;\n  const buf = new ArrayBuffer(totalLen);\n  const view = new DataView(buf);\n\n  view.setUint32(0, op, true);\n  view.setUint32(4, flags, true);\n  view.setUint32(8, pathBytes.byteLength, true);\n  view.setUint32(12, dataLen, true);\n\n  const bytes = new Uint8Array(buf);\n  bytes.set(pathBytes, 16);\n  if (data) {\n    bytes.set(data, 16 + pathBytes.byteLength);\n  }\n\n  return buf;\n}\n\n/**\n * Decode a request ArrayBuffer.\n */\nexport function decodeRequest(buf: ArrayBuffer): {\n  op: number;\n  flags: number;\n  path: string;\n  data: Uint8Array | null;\n} {\n  const view = new DataView(buf);\n  const op = view.getUint32(0, true);\n  const flags = view.getUint32(4, true);\n  const pathLen = view.getUint32(8, true);\n  const dataLen = view.getUint32(12, true);\n\n  const bytes = new Uint8Array(buf);\n  const path = decoder.decode(bytes.subarray(16, 16 + pathLen));\n  const data = dataLen > 0\n    ? bytes.subarray(16 + pathLen, 16 + pathLen + dataLen)\n    : null;\n\n  return { op, flags, path, data };\n}\n\n/**\n * Encode a response into an ArrayBuffer.\n *\n * Response format (8-byte header + data):\n *   bytes 0-3: status (uint32)\n *   bytes 4-7: dataLen (uint32)\n *   bytes 8+:  data payload\n */\nexport function encodeResponse(status: number, data?: Uint8Array): ArrayBuffer {\n  const dataLen = data ? data.byteLength : 0;\n  const buf = new ArrayBuffer(8 + dataLen);\n  const view = new DataView(buf);\n\n  view.setUint32(0, status, true);\n  view.setUint32(4, dataLen, true);\n\n  if (data) {\n    new Uint8Array(buf).set(data, 8);\n  }\n\n  return buf;\n}\n\n/**\n * Decode a response ArrayBuffer.\n */\nexport function decodeResponse(buf: ArrayBuffer): {\n  status: number;\n  data: Uint8Array | null;\n} {\n  const view = new DataView(buf);\n  const status = view.getUint32(0, true);\n  const dataLen = view.getUint32(4, true);\n\n  const data = dataLen > 0\n    ? new Uint8Array(buf, 8, dataLen)\n    : null;\n\n  return { status, data };\n}\n\n/**\n * Encode a two-path request (rename, copy, symlink, link).\n * Data payload contains: [pathLen2:u32] [path2 bytes]\n */\nexport function encodeTwoPathRequest(\n  op: number,\n  path1: string,\n  path2: string,\n  flags: number = 0\n): ArrayBuffer {\n  const path2Bytes = encoder.encode(path2);\n  const payload = new Uint8Array(4 + path2Bytes.byteLength);\n  const pv = new DataView(payload.buffer);\n  pv.setUint32(0, path2Bytes.byteLength, true);\n  payload.set(path2Bytes, 4);\n\n  return encodeRequest(op, path1, flags, payload);\n}\n\n/**\n * Decode the second path from a two-path request's data payload.\n */\nexport function decodeSecondPath(data: Uint8Array): string {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  const pathLen = view.getUint32(0, true);\n  return decoder.decode(data.subarray(4, 4 + pathLen));\n}\n","/**\n * Node.js compatible filesystem error classes\n */\n\nexport class FSError extends Error {\n  code: string;\n  errno: number;\n  syscall?: string;\n  path?: string;\n\n  constructor(code: string, errno: number, message: string, syscall?: string, path?: string) {\n    super(message);\n    this.name = 'FSError';\n    this.code = code;\n    this.errno = errno;\n    this.syscall = syscall;\n    this.path = path;\n  }\n}\n\nexport const ErrorCodes = {\n  ENOENT: -2,\n  EEXIST: -17,\n  EISDIR: -21,\n  ENOTDIR: -20,\n  ENOTEMPTY: -39,\n  EACCES: -13,\n  EBADF: -9,\n  EINVAL: -22,\n  EMFILE: -24,\n  ENOSPC: -28,\n  EPERM: -1,\n  ENOSYS: -38,\n  ELOOP: -40,\n} as const;\n\n/** Binary protocol status codes  error code mapping */\nexport const STATUS_TO_CODE: Record<number, string> = {\n  0: 'OK',\n  1: 'ENOENT',\n  2: 'EEXIST',\n  3: 'EISDIR',\n  4: 'ENOTDIR',\n  5: 'ENOTEMPTY',\n  6: 'EACCES',\n  7: 'EINVAL',\n  8: 'EBADF',\n  9: 'ELOOP',\n  10: 'ENOSPC',\n};\n\n/** Error code  binary protocol status mapping */\nexport const CODE_TO_STATUS: Record<string, number> = {\n  OK: 0,\n  ENOENT: 1,\n  EEXIST: 2,\n  EISDIR: 3,\n  ENOTDIR: 4,\n  ENOTEMPTY: 5,\n  EACCES: 6,\n  EINVAL: 7,\n  EBADF: 8,\n  ELOOP: 9,\n  ENOSPC: 10,\n};\n\nexport function createError(code: string, syscall: string, path: string): FSError {\n  const errno = ErrorCodes[code as keyof typeof ErrorCodes] ?? -1;\n  const messages: Record<string, string> = {\n    ENOENT: 'no such file or directory',\n    EEXIST: 'file already exists',\n    EISDIR: 'illegal operation on a directory',\n    ENOTDIR: 'not a directory',\n    ENOTEMPTY: 'directory not empty',\n    EACCES: 'permission denied',\n    EINVAL: 'invalid argument',\n    EBADF: 'bad file descriptor',\n    ELOOP: 'too many symbolic links encountered',\n    ENOSPC: 'no space left on device',\n  };\n  const msg = messages[code] ?? 'unknown error';\n  return new FSError(code, errno, `${code}: ${msg}, ${syscall} '${path}'`, syscall, path);\n}\n\nexport function statusToError(status: number, syscall: string, path: string): FSError {\n  const code = STATUS_TO_CODE[status] ?? 'EINVAL';\n  return createError(code, syscall, path);\n}\n","import type { ReadOptions, Encoding } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst decoder = new TextDecoder();\n\nexport function readFileSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  options?: ReadOptions | Encoding | null\n): string | Uint8Array {\n  const encoding = typeof options === 'string' ? options : options?.encoding;\n  const buf = encodeRequest(OP.READ, filePath);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'read', filePath);\n  const result = data ?? new Uint8Array(0);\n  if (encoding) return decoder.decode(result);\n  return result;\n}\n\nexport async function readFile(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  options?: ReadOptions | Encoding | null\n): Promise<string | Uint8Array> {\n  const encoding = typeof options === 'string' ? options : options?.encoding;\n  const { status, data } = await asyncRequest(OP.READ, filePath);\n  if (status !== 0) throw statusToError(status, 'read', filePath);\n  const result = data ?? new Uint8Array(0);\n  if (encoding) return decoder.decode(result);\n  return result;\n}\n","import type { WriteOptions, Encoding } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst encoder = new TextEncoder();\n\nexport function writeFileSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  data: string | Uint8Array,\n  options?: WriteOptions | Encoding\n): void {\n  const opts = typeof options === 'string' ? { encoding: options } : options;\n  const encoded = typeof data === 'string' ? encoder.encode(data) : data;\n  const flags = opts?.flush === true ? 1 : 0;\n  const buf = encodeRequest(OP.WRITE, filePath, flags, encoded);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'write', filePath);\n}\n\nexport async function writeFile(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  data: string | Uint8Array,\n  options?: WriteOptions | Encoding\n): Promise<void> {\n  const opts = typeof options === 'string' ? { encoding: options } : options;\n  const flags = opts?.flush === true ? 1 : 0;\n  const encoded = typeof data === 'string' ? encoder.encode(data) : data;\n  const { status } = await asyncRequest(OP.WRITE, filePath, flags, encoded);\n  if (status !== 0) throw statusToError(status, 'write', filePath);\n}\n","import type { WriteOptions, Encoding } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst encoder = new TextEncoder();\n\nexport function appendFileSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  data: string | Uint8Array,\n  options?: WriteOptions | Encoding\n): void {\n  const encoded = typeof data === 'string' ? encoder.encode(data) : data;\n  const buf = encodeRequest(OP.APPEND, filePath, 0, encoded);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'appendFile', filePath);\n}\n\nexport async function appendFile(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  data: string | Uint8Array,\n  options?: WriteOptions | Encoding\n): Promise<void> {\n  const encoded = typeof data === 'string' ? encoder.encode(data) : data;\n  const { status } = await asyncRequest(OP.APPEND, filePath, 0, encoded);\n  if (status !== 0) throw statusToError(status, 'appendFile', filePath);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\n\nexport function existsSync(\n  syncRequest: SyncRequestFn,\n  filePath: string\n): boolean {\n  const buf = encodeRequest(OP.EXISTS, filePath);\n  const { data } = syncRequest(buf);\n  return data ? data[0] === 1 : false;\n}\n\nexport async function exists(\n  asyncRequest: AsyncRequestFn,\n  filePath: string\n): Promise<boolean> {\n  const { data } = await asyncRequest(OP.EXISTS, filePath);\n  return data ? data[0] === 1 : false;\n}\n","import type { MkdirOptions } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst decoder = new TextDecoder();\n\nexport function mkdirSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  options?: MkdirOptions | number\n): string | undefined {\n  const opts = typeof options === 'number' ? { mode: options } : options;\n  const flags = opts?.recursive ? 1 : 0;\n  const buf = encodeRequest(OP.MKDIR, filePath, flags);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'mkdir', filePath);\n  return data ? decoder.decode(data) : undefined;\n}\n\nexport async function mkdir(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  options?: MkdirOptions | number\n): Promise<string | undefined> {\n  const opts = typeof options === 'number' ? { mode: options } : options;\n  const flags = opts?.recursive ? 1 : 0;\n  const { status, data } = await asyncRequest(OP.MKDIR, filePath, flags);\n  if (status !== 0) throw statusToError(status, 'mkdir', filePath);\n  return data ? decoder.decode(data) : undefined;\n}\n","import type { RmdirOptions } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nexport function rmdirSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  options?: RmdirOptions\n): void {\n  const flags = options?.recursive ? 1 : 0;\n  const buf = encodeRequest(OP.RMDIR, filePath, flags);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'rmdir', filePath);\n}\n\nexport async function rmdir(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  options?: RmdirOptions\n): Promise<void> {\n  const flags = options?.recursive ? 1 : 0;\n  const { status } = await asyncRequest(OP.RMDIR, filePath, flags);\n  if (status !== 0) throw statusToError(status, 'rmdir', filePath);\n}\n","import type { RmOptions } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nexport function rmSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  options?: RmOptions\n): void {\n  const flags = (options?.recursive ? 1 : 0) | (options?.force ? 2 : 0);\n  const buf = encodeRequest(OP.UNLINK, filePath, flags);\n  const { status } = syncRequest(buf);\n  if (status === 3) {\n    // EISDIR  it's a directory, use rmdir\n    const rmdirBuf = encodeRequest(OP.RMDIR, filePath, flags);\n    const rmdirResult = syncRequest(rmdirBuf);\n    if (rmdirResult.status !== 0) {\n      if (options?.force && rmdirResult.status === 1) return;\n      throw statusToError(rmdirResult.status, 'rm', filePath);\n    }\n    return;\n  }\n  if (status !== 0) {\n    if (options?.force && status === 1) return;\n    throw statusToError(status, 'rm', filePath);\n  }\n}\n\nexport async function rm(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  options?: RmOptions\n): Promise<void> {\n  const flags = (options?.recursive ? 1 : 0) | (options?.force ? 2 : 0);\n  const { status } = await asyncRequest(OP.UNLINK, filePath, flags);\n  if (status === 3) {\n    const { status: s2 } = await asyncRequest(OP.RMDIR, filePath, flags);\n    if (s2 !== 0) {\n      if (options?.force && s2 === 1) return;\n      throw statusToError(s2, 'rm', filePath);\n    }\n    return;\n  }\n  if (status !== 0) {\n    if (options?.force && status === 1) return;\n    throw statusToError(status, 'rm', filePath);\n  }\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nexport function unlinkSync(\n  syncRequest: SyncRequestFn,\n  filePath: string\n): void {\n  const buf = encodeRequest(OP.UNLINK, filePath);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'unlink', filePath);\n}\n\nexport async function unlink(\n  asyncRequest: AsyncRequestFn,\n  filePath: string\n): Promise<void> {\n  const { status } = await asyncRequest(OP.UNLINK, filePath);\n  if (status !== 0) throw statusToError(status, 'unlink', filePath);\n}\n","/**\n * VFS Binary Layout Constants\n *\n * Defines the on-disk structure of the virtual filesystem binary file.\n * All reads/writes go through a FileSystemSyncAccessHandle.\n */\n\n// Magic number: \"VFS!\" in ASCII\nexport const VFS_MAGIC = 0x56465321;\nexport const VFS_VERSION = 1;\n\n// Default sizes\nexport const DEFAULT_BLOCK_SIZE = 4096;\nexport const DEFAULT_INODE_COUNT = 10000;\nexport const INODE_SIZE = 64; // bytes per inode entry\n\n// Superblock layout (64 bytes)\nexport const SUPERBLOCK = {\n  SIZE: 64,\n  MAGIC: 0,           // uint32 - 0x56465321\n  VERSION: 4,         // uint32\n  INODE_COUNT: 8,     // uint32 - total inodes allocated\n  BLOCK_SIZE: 12,     // uint32 - data block size (default 4096)\n  TOTAL_BLOCKS: 16,   // uint32 - total data blocks\n  FREE_BLOCKS: 20,    // uint32 - available data blocks\n  INODE_OFFSET: 24,   // float64 - byte offset to inode table\n  PATH_OFFSET: 32,    // float64 - byte offset to path table\n  DATA_OFFSET: 40,    // float64 - byte offset to data region\n  BITMAP_OFFSET: 48,  // float64 - byte offset to free block bitmap\n  PATH_USED: 56,      // uint32 - bytes used in path table\n  RESERVED: 60,       // uint32\n} as const;\n\n// Inode entry layout (64 bytes each)\nexport const INODE = {\n  TYPE: 0,            // uint8 - 0=free, 1=file, 2=directory, 3=symlink\n  FLAGS: 1,           // uint8[3] - reserved\n  PATH_OFFSET: 4,     // uint32 - byte offset into path table\n  PATH_LENGTH: 8,     // uint16 - length of path string\n  RESERVED_10: 10,    // uint16\n  MODE: 12,           // uint32 - permissions (e.g. 0o100644)\n  SIZE: 16,           // float64 - file content size in bytes (using f64 for >4GB)\n  FIRST_BLOCK: 24,    // uint32 - index of first data block\n  BLOCK_COUNT: 28,    // uint32 - number of contiguous data blocks\n  MTIME: 32,          // float64 - last modification time (ms since epoch)\n  CTIME: 40,          // float64 - creation/change time (ms since epoch)\n  ATIME: 48,          // float64 - last access time (ms since epoch)\n  UID: 56,            // uint32 - owner\n  GID: 60,            // uint32 - group\n} as const;\n\n// Inode type constants\nexport const INODE_TYPE = {\n  FREE: 0,\n  FILE: 1,\n  DIRECTORY: 2,\n  SYMLINK: 3,\n} as const;\n\n// Default file modes\nexport const DEFAULT_FILE_MODE = 0o100644;\nexport const DEFAULT_DIR_MODE = 0o040755;\nexport const DEFAULT_SYMLINK_MODE = 0o120777;\nexport const DEFAULT_UMASK = 0o022;\n\n// POSIX file type bits\nexport const S_IFMT = 0o170000;\nexport const S_IFREG = 0o100000;\nexport const S_IFDIR = 0o040000;\nexport const S_IFLNK = 0o120000;\n\n// Max symlink depth for cycle detection\nexport const MAX_SYMLINK_DEPTH = 40;\n\n// Path table compaction threshold (25% dead space)\nexport const PATH_COMPACTION_THRESHOLD = 0.25;\n\n// Initial path table size (256KB)\nexport const INITIAL_PATH_TABLE_SIZE = 256 * 1024;\n\n// Initial data blocks (1024 blocks = 4MB with 4KB blocks)\nexport const INITIAL_DATA_BLOCKS = 1024;\n\n/**\n * Calculate section offsets for a fresh VFS.\n */\nexport function calculateLayout(inodeCount: number = DEFAULT_INODE_COUNT, blockSize: number = DEFAULT_BLOCK_SIZE, totalBlocks: number = INITIAL_DATA_BLOCKS) {\n  const inodeTableOffset = SUPERBLOCK.SIZE;\n  const inodeTableSize = inodeCount * INODE_SIZE;\n  const pathTableOffset = inodeTableOffset + inodeTableSize;\n  const pathTableSize = INITIAL_PATH_TABLE_SIZE;\n  const bitmapOffset = pathTableOffset + pathTableSize;\n  const bitmapSize = Math.ceil(totalBlocks / 8);\n  // Align data region to block boundary\n  const dataOffset = Math.ceil((bitmapOffset + bitmapSize) / blockSize) * blockSize;\n  const totalSize = dataOffset + totalBlocks * blockSize;\n\n  return {\n    inodeTableOffset,\n    inodeTableSize,\n    pathTableOffset,\n    pathTableSize,\n    bitmapOffset,\n    bitmapSize,\n    dataOffset,\n    totalSize,\n    totalBlocks,\n  };\n}\n","/**\n * Stats and Dirent object construction.\n * Decodes binary stat responses from the server into Node.js-compatible objects.\n */\n\nimport type { Stats, Dirent } from './types.js';\nimport { INODE_TYPE } from './vfs/layout.js';\n\n/**\n * Decode a binary stat response (49 bytes) into a Stats object.\n *\n * Format:\n *   byte 0:    type (uint8)\n *   bytes 1-4: mode (uint32)\n *   bytes 5-12: size (float64)\n *   bytes 13-20: mtime (float64)\n *   bytes 21-28: ctime (float64)\n *   bytes 29-36: atime (float64)\n *   bytes 37-40: uid (uint32)\n *   bytes 41-44: gid (uint32)\n *   bytes 45-48: ino (uint32)\n */\nexport function decodeStats(data: Uint8Array): Stats {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  const type = view.getUint8(0);\n  const mode = view.getUint32(1, true);\n  const size = view.getFloat64(5, true);\n  const mtimeMs = view.getFloat64(13, true);\n  const ctimeMs = view.getFloat64(21, true);\n  const atimeMs = view.getFloat64(29, true);\n  const uid = view.getUint32(37, true);\n  const gid = view.getUint32(41, true);\n  const ino = view.getUint32(45, true);\n\n  const isFile = type === INODE_TYPE.FILE;\n  const isDirectory = type === INODE_TYPE.DIRECTORY;\n  const isSymlink = type === INODE_TYPE.SYMLINK;\n\n  return {\n    isFile: () => isFile,\n    isDirectory: () => isDirectory,\n    isBlockDevice: () => false,\n    isCharacterDevice: () => false,\n    isSymbolicLink: () => isSymlink,\n    isFIFO: () => false,\n    isSocket: () => false,\n    dev: 0,\n    ino,\n    mode,\n    nlink: 1,\n    uid,\n    gid,\n    rdev: 0,\n    size,\n    blksize: 4096,\n    blocks: Math.ceil(size / 512),\n    atimeMs,\n    mtimeMs,\n    ctimeMs,\n    birthtimeMs: ctimeMs,\n    atime: new Date(atimeMs),\n    mtime: new Date(mtimeMs),\n    ctime: new Date(ctimeMs),\n    birthtime: new Date(ctimeMs),\n  };\n}\n\n/**\n * Decode a readdir response with file types.\n *\n * Format:\n *   bytes 0-3: count (uint32)\n *   Then for each entry:\n *     bytes 0-1: nameLen (uint16)\n *     bytes 2+: name (UTF-8)\n *     byte after name: type (uint8)\n */\nexport function decodeDirents(data: Uint8Array): Dirent[] {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  const count = view.getUint32(0, true);\n  const decoder = new TextDecoder();\n  const entries: Dirent[] = [];\n  let offset = 4;\n\n  for (let i = 0; i < count; i++) {\n    const nameLen = view.getUint16(offset, true);\n    offset += 2;\n    const name = decoder.decode(data.subarray(offset, offset + nameLen));\n    offset += nameLen;\n    const type = data[offset++];\n\n    const isFile = type === INODE_TYPE.FILE;\n    const isDirectory = type === INODE_TYPE.DIRECTORY;\n    const isSymlink = type === INODE_TYPE.SYMLINK;\n\n    entries.push({\n      name,\n      isFile: () => isFile,\n      isDirectory: () => isDirectory,\n      isBlockDevice: () => false,\n      isCharacterDevice: () => false,\n      isSymbolicLink: () => isSymlink,\n      isFIFO: () => false,\n      isSocket: () => false,\n    });\n  }\n\n  return entries;\n}\n\n/**\n * Decode a simple readdir response (names only).\n *\n * Format:\n *   bytes 0-3: count (uint32)\n *   Then for each entry:\n *     bytes 0-1: nameLen (uint16)\n *     bytes 2+: name (UTF-8)\n */\nexport function decodeNames(data: Uint8Array): string[] {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n  const count = view.getUint32(0, true);\n  const decoder = new TextDecoder();\n  const names: string[] = [];\n  let offset = 4;\n\n  for (let i = 0; i < count; i++) {\n    const nameLen = view.getUint16(offset, true);\n    offset += 2;\n    names.push(decoder.decode(data.subarray(offset, offset + nameLen)));\n    offset += nameLen;\n  }\n\n  return names;\n}\n","import type { ReaddirOptions, Encoding, Dirent } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\nimport { decodeDirents, decodeNames } from '../stats.js';\n\nexport function readdirSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  options?: ReaddirOptions | Encoding | null\n): string[] | Dirent[] {\n  const opts = typeof options === 'string' ? { encoding: options } : options;\n  const flags = opts?.withFileTypes ? 1 : 0;\n  const buf = encodeRequest(OP.READDIR, filePath, flags);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'readdir', filePath);\n  if (!data) return [];\n  return opts?.withFileTypes ? decodeDirents(data) : decodeNames(data);\n}\n\nexport async function readdir(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  options?: ReaddirOptions | Encoding | null\n): Promise<string[] | Dirent[]> {\n  const opts = typeof options === 'string' ? { encoding: options } : options;\n  const flags = opts?.withFileTypes ? 1 : 0;\n  const { status, data } = await asyncRequest(OP.READDIR, filePath, flags);\n  if (status !== 0) throw statusToError(status, 'readdir', filePath);\n  if (!data) return [];\n  return opts?.withFileTypes ? decodeDirents(data) : decodeNames(data);\n}\n","import type { Stats } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\nimport { decodeStats } from '../stats.js';\n\nexport function statSync(\n  syncRequest: SyncRequestFn,\n  filePath: string\n): Stats {\n  const buf = encodeRequest(OP.STAT, filePath);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'stat', filePath);\n  return decodeStats(data!);\n}\n\nexport function lstatSync(\n  syncRequest: SyncRequestFn,\n  filePath: string\n): Stats {\n  const buf = encodeRequest(OP.LSTAT, filePath);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'lstat', filePath);\n  return decodeStats(data!);\n}\n\nexport async function stat(\n  asyncRequest: AsyncRequestFn,\n  filePath: string\n): Promise<Stats> {\n  const { status, data } = await asyncRequest(OP.STAT, filePath);\n  if (status !== 0) throw statusToError(status, 'stat', filePath);\n  return decodeStats(data!);\n}\n\nexport async function lstat(\n  asyncRequest: AsyncRequestFn,\n  filePath: string\n): Promise<Stats> {\n  const { status, data } = await asyncRequest(OP.LSTAT, filePath);\n  if (status !== 0) throw statusToError(status, 'lstat', filePath);\n  return decodeStats(data!);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeTwoPathRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst encoder = new TextEncoder();\n\nexport function renameSync(\n  syncRequest: SyncRequestFn,\n  oldPath: string,\n  newPath: string\n): void {\n  const buf = encodeTwoPathRequest(OP.RENAME, oldPath, newPath);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'rename', oldPath);\n}\n\nexport async function rename(\n  asyncRequest: AsyncRequestFn,\n  oldPath: string,\n  newPath: string\n): Promise<void> {\n  const path2Bytes = encoder.encode(newPath);\n  const payload = new Uint8Array(4 + path2Bytes.byteLength);\n  new DataView(payload.buffer).setUint32(0, path2Bytes.byteLength, true);\n  payload.set(path2Bytes, 4);\n  const { status } = await asyncRequest(OP.RENAME, oldPath, 0, payload);\n  if (status !== 0) throw statusToError(status, 'rename', oldPath);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeTwoPathRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst encoder = new TextEncoder();\n\nexport function copyFileSync(\n  syncRequest: SyncRequestFn,\n  src: string,\n  dest: string,\n  mode?: number\n): void {\n  const buf = encodeTwoPathRequest(OP.COPY, src, dest, mode ?? 0);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'copyFile', src);\n}\n\nexport async function copyFile(\n  asyncRequest: AsyncRequestFn,\n  src: string,\n  dest: string,\n  mode?: number\n): Promise<void> {\n  const path2Bytes = encoder.encode(dest);\n  const payload = new Uint8Array(4 + path2Bytes.byteLength);\n  new DataView(payload.buffer).setUint32(0, path2Bytes.byteLength, true);\n  payload.set(path2Bytes, 4);\n  const { status } = await asyncRequest(OP.COPY, src, mode ?? 0, payload);\n  if (status !== 0) throw statusToError(status, 'copyFile', src);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nexport function truncateSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  len: number = 0\n): void {\n  const lenBuf = new Uint8Array(4);\n  new DataView(lenBuf.buffer).setUint32(0, len, true);\n  const buf = encodeRequest(OP.TRUNCATE, filePath, 0, lenBuf);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'truncate', filePath);\n}\n\nexport async function truncate(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  len?: number\n): Promise<void> {\n  const lenBuf = new Uint8Array(4);\n  new DataView(lenBuf.buffer).setUint32(0, len ?? 0, true);\n  const { status } = await asyncRequest(OP.TRUNCATE, filePath, 0, lenBuf);\n  if (status !== 0) throw statusToError(status, 'truncate', filePath);\n}\n","/**\n * File system constants matching Node.js fs.constants\n */\n\nexport const constants = {\n  // File access constants\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n\n  // File copy constants\n  COPYFILE_EXCL: 1,\n  COPYFILE_FICLONE: 2,\n  COPYFILE_FICLONE_FORCE: 4,\n\n  // File open constants\n  O_RDONLY: 0,\n  O_WRONLY: 1,\n  O_RDWR: 2,\n  O_CREAT: 64,\n  O_EXCL: 128,\n  O_TRUNC: 512,\n  O_APPEND: 1024,\n  O_SYNC: 4096,\n\n  // File type constants\n  S_IFMT: 0o170000,\n  S_IFREG: 0o100000,\n  S_IFDIR: 0o040000,\n  S_IFCHR: 0o020000,\n  S_IFBLK: 0o060000,\n  S_IFIFO: 0o010000,\n  S_IFLNK: 0o120000,\n  S_IFSOCK: 0o140000,\n\n  // File mode constants\n  S_IRWXU: 0o700,\n  S_IRUSR: 0o400,\n  S_IWUSR: 0o200,\n  S_IXUSR: 0o100,\n  S_IRWXG: 0o070,\n  S_IRGRP: 0o040,\n  S_IWGRP: 0o020,\n  S_IXGRP: 0o010,\n  S_IRWXO: 0o007,\n  S_IROTH: 0o004,\n  S_IWOTH: 0o002,\n  S_IXOTH: 0o001,\n} as const;\n\nexport type Constants = typeof constants;\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\nimport { constants } from '../constants.js';\n\nexport function accessSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  mode: number = constants.F_OK\n): void {\n  const buf = encodeRequest(OP.ACCESS, filePath, mode);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'access', filePath);\n}\n\nexport async function access(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  mode?: number\n): Promise<void> {\n  const { status } = await asyncRequest(OP.ACCESS, filePath, mode ?? 0);\n  if (status !== 0) throw statusToError(status, 'access', filePath);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst decoder = new TextDecoder();\n\nexport function realpathSync(\n  syncRequest: SyncRequestFn,\n  filePath: string\n): string {\n  const buf = encodeRequest(OP.REALPATH, filePath);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'realpath', filePath);\n  return decoder.decode(data!);\n}\n\nexport async function realpath(\n  asyncRequest: AsyncRequestFn,\n  filePath: string\n): Promise<string> {\n  const { status, data } = await asyncRequest(OP.REALPATH, filePath);\n  if (status !== 0) throw statusToError(status, 'realpath', filePath);\n  return decoder.decode(data!);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nexport function chmodSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  mode: number\n): void {\n  const modeBuf = new Uint8Array(4);\n  new DataView(modeBuf.buffer).setUint32(0, mode, true);\n  const buf = encodeRequest(OP.CHMOD, filePath, 0, modeBuf);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'chmod', filePath);\n}\n\nexport async function chmod(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  mode: number\n): Promise<void> {\n  const modeBuf = new Uint8Array(4);\n  new DataView(modeBuf.buffer).setUint32(0, mode, true);\n  const { status } = await asyncRequest(OP.CHMOD, filePath, 0, modeBuf);\n  if (status !== 0) throw statusToError(status, 'chmod', filePath);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nexport function chownSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  uid: number,\n  gid: number\n): void {\n  const ownerBuf = new Uint8Array(8);\n  const dv = new DataView(ownerBuf.buffer);\n  dv.setUint32(0, uid, true);\n  dv.setUint32(4, gid, true);\n  const buf = encodeRequest(OP.CHOWN, filePath, 0, ownerBuf);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'chown', filePath);\n}\n\nexport async function chown(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  uid: number,\n  gid: number\n): Promise<void> {\n  const buf = new Uint8Array(8);\n  const dv = new DataView(buf.buffer);\n  dv.setUint32(0, uid, true);\n  dv.setUint32(4, gid, true);\n  const { status } = await asyncRequest(OP.CHOWN, filePath, 0, buf);\n  if (status !== 0) throw statusToError(status, 'chown', filePath);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nexport function utimesSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  atime: Date | number,\n  mtime: Date | number\n): void {\n  const timesBuf = new Uint8Array(16);\n  const dv = new DataView(timesBuf.buffer);\n  dv.setFloat64(0, typeof atime === 'number' ? atime : atime.getTime(), true);\n  dv.setFloat64(8, typeof mtime === 'number' ? mtime : mtime.getTime(), true);\n  const buf = encodeRequest(OP.UTIMES, filePath, 0, timesBuf);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'utimes', filePath);\n}\n\nexport async function utimes(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  atime: Date | number,\n  mtime: Date | number\n): Promise<void> {\n  const buf = new Uint8Array(16);\n  const dv = new DataView(buf.buffer);\n  dv.setFloat64(0, typeof atime === 'number' ? atime : atime.getTime(), true);\n  dv.setFloat64(8, typeof mtime === 'number' ? mtime : mtime.getTime(), true);\n  const { status } = await asyncRequest(OP.UTIMES, filePath, 0, buf);\n  if (status !== 0) throw statusToError(status, 'utimes', filePath);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nexport function symlinkSync(\n  syncRequest: SyncRequestFn,\n  target: string,\n  linkPath: string\n): void {\n  const targetBytes = encoder.encode(target);\n  const buf = encodeRequest(OP.SYMLINK, linkPath, 0, targetBytes);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'symlink', linkPath);\n}\n\nexport function readlinkSync(\n  syncRequest: SyncRequestFn,\n  filePath: string\n): string {\n  const buf = encodeRequest(OP.READLINK, filePath);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'readlink', filePath);\n  return decoder.decode(data!);\n}\n\nexport async function symlink(\n  asyncRequest: AsyncRequestFn,\n  target: string,\n  linkPath: string\n): Promise<void> {\n  const targetBytes = encoder.encode(target);\n  const { status } = await asyncRequest(OP.SYMLINK, linkPath, 0, targetBytes);\n  if (status !== 0) throw statusToError(status, 'symlink', linkPath);\n}\n\nexport async function readlink(\n  asyncRequest: AsyncRequestFn,\n  filePath: string\n): Promise<string> {\n  const { status, data } = await asyncRequest(OP.READLINK, filePath);\n  if (status !== 0) throw statusToError(status, 'readlink', filePath);\n  return decoder.decode(data!);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeTwoPathRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst encoder = new TextEncoder();\n\nexport function linkSync(\n  syncRequest: SyncRequestFn,\n  existingPath: string,\n  newPath: string\n): void {\n  const buf = encodeTwoPathRequest(OP.LINK, existingPath, newPath);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'link', existingPath);\n}\n\nexport async function link(\n  asyncRequest: AsyncRequestFn,\n  existingPath: string,\n  newPath: string\n): Promise<void> {\n  const path2Bytes = encoder.encode(newPath);\n  const payload = new Uint8Array(4 + path2Bytes.byteLength);\n  new DataView(payload.buffer).setUint32(0, path2Bytes.byteLength, true);\n  payload.set(path2Bytes, 4);\n  const { status } = await asyncRequest(OP.LINK, existingPath, 0, payload);\n  if (status !== 0) throw statusToError(status, 'link', existingPath);\n}\n","import type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\n\nconst decoder = new TextDecoder();\n\nexport function mkdtempSync(\n  syncRequest: SyncRequestFn,\n  prefix: string\n): string {\n  const buf = encodeRequest(OP.MKDTEMP, prefix);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'mkdtemp', prefix);\n  return decoder.decode(data!);\n}\n\nexport async function mkdtemp(\n  asyncRequest: AsyncRequestFn,\n  prefix: string\n): Promise<string> {\n  const { status, data } = await asyncRequest(OP.MKDTEMP, prefix);\n  if (status !== 0) throw statusToError(status, 'mkdtemp', prefix);\n  return decoder.decode(data!);\n}\n","import type { Stats, FileHandle, ReadOptions, WriteOptions, Encoding } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { OP, encodeRequest } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\nimport { decodeStats } from '../stats.js';\nimport { constants } from '../constants.js';\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nexport function parseFlags(flags: string): number {\n  switch (flags) {\n    case 'r': return constants.O_RDONLY;\n    case 'r+': return constants.O_RDWR;\n    case 'w': return constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC;\n    case 'w+': return constants.O_RDWR | constants.O_CREAT | constants.O_TRUNC;\n    case 'a': return constants.O_WRONLY | constants.O_CREAT | constants.O_APPEND;\n    case 'a+': return constants.O_RDWR | constants.O_CREAT | constants.O_APPEND;\n    case 'wx': return constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC | constants.O_EXCL;\n    case 'wx+': return constants.O_RDWR | constants.O_CREAT | constants.O_TRUNC | constants.O_EXCL;\n    case 'ax': return constants.O_WRONLY | constants.O_CREAT | constants.O_APPEND | constants.O_EXCL;\n    case 'ax+': return constants.O_RDWR | constants.O_CREAT | constants.O_APPEND | constants.O_EXCL;\n    default: return constants.O_RDONLY;\n  }\n}\n\nexport function openSync(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  flags: string | number = 'r',\n  _mode?: number\n): number {\n  const numFlags = typeof flags === 'string' ? parseFlags(flags) : flags;\n  const buf = encodeRequest(OP.OPEN, filePath, numFlags);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'open', filePath);\n  return new DataView(data!.buffer, data!.byteOffset, data!.byteLength).getUint32(0, true);\n}\n\nexport function closeSync(\n  syncRequest: SyncRequestFn,\n  fd: number\n): void {\n  const fdBuf = new Uint8Array(4);\n  new DataView(fdBuf.buffer).setUint32(0, fd, true);\n  const buf = encodeRequest(OP.CLOSE, '', 0, fdBuf);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'close', String(fd));\n}\n\nexport function readSync(\n  syncRequest: SyncRequestFn,\n  fd: number,\n  buffer: Uint8Array,\n  offset: number = 0,\n  length: number = buffer.byteLength,\n  position: number | null = null\n): number {\n  const fdBuf = new Uint8Array(12);\n  const dv = new DataView(fdBuf.buffer);\n  dv.setUint32(0, fd, true);\n  dv.setUint32(4, length, true);\n  dv.setInt32(8, position ?? -1, true);\n  const buf = encodeRequest(OP.FREAD, '', 0, fdBuf);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'read', String(fd));\n  if (data) {\n    buffer.set(data.subarray(0, Math.min(data.byteLength, length)), offset);\n    return data.byteLength;\n  }\n  return 0;\n}\n\nexport function writeSyncFd(\n  syncRequest: SyncRequestFn,\n  fd: number,\n  buffer: Uint8Array,\n  offset: number = 0,\n  length: number = buffer.byteLength,\n  position: number | null = null\n): number {\n  const writeData = buffer.subarray(offset, offset + length);\n  const fdBuf = new Uint8Array(8 + writeData.byteLength);\n  const dv = new DataView(fdBuf.buffer);\n  dv.setUint32(0, fd, true);\n  dv.setInt32(4, position ?? -1, true);\n  fdBuf.set(writeData, 8);\n  const buf = encodeRequest(OP.FWRITE, '', 0, fdBuf);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'write', String(fd));\n  return data ? new DataView(data.buffer, data.byteOffset, data.byteLength).getUint32(0, true) : 0;\n}\n\nexport function fstatSync(\n  syncRequest: SyncRequestFn,\n  fd: number\n): Stats {\n  const fdBuf = new Uint8Array(4);\n  new DataView(fdBuf.buffer).setUint32(0, fd, true);\n  const buf = encodeRequest(OP.FSTAT, '', 0, fdBuf);\n  const { status, data } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'fstat', String(fd));\n  return decodeStats(data!);\n}\n\nexport function ftruncateSync(\n  syncRequest: SyncRequestFn,\n  fd: number,\n  len: number = 0\n): void {\n  const fdBuf = new Uint8Array(8);\n  const dv = new DataView(fdBuf.buffer);\n  dv.setUint32(0, fd, true);\n  dv.setUint32(4, len, true);\n  const buf = encodeRequest(OP.FTRUNCATE, '', 0, fdBuf);\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'ftruncate', String(fd));\n}\n\nexport function fdatasyncSync(\n  syncRequest: SyncRequestFn,\n  fd: number\n): void {\n  const buf = encodeRequest(OP.FSYNC, '');\n  const { status } = syncRequest(buf);\n  if (status !== 0) throw statusToError(status, 'fdatasync', String(fd));\n}\n\n// ========== Async FileHandle ==========\n\nexport async function open(\n  asyncRequest: AsyncRequestFn,\n  filePath: string,\n  flags?: string | number,\n  _mode?: number\n): Promise<FileHandle> {\n  const numFlags = typeof flags === 'string' ? parseFlags(flags ?? 'r') : (flags ?? 0);\n  const { status, data } = await asyncRequest(OP.OPEN, filePath, numFlags);\n  if (status !== 0) throw statusToError(status, 'open', filePath);\n  const fd = new DataView(data!.buffer, data!.byteOffset, data!.byteLength).getUint32(0, true);\n  return createFileHandle(fd, asyncRequest);\n}\n\nfunction createFileHandle(fd: number, asyncRequest: AsyncRequestFn): FileHandle {\n  return {\n    fd,\n\n    async read(buffer: Uint8Array, offset = 0, length = buffer.byteLength, position: number | null = null) {\n      const { status, data } = await asyncRequest(OP.FREAD, '', 0, null, undefined, { fd, length, position: position ?? -1 });\n      if (status !== 0) throw statusToError(status, 'read', String(fd));\n      const bytesRead = data ? data.byteLength : 0;\n      if (data) buffer.set(data.subarray(0, Math.min(bytesRead, length)), offset);\n      return { bytesRead, buffer };\n    },\n\n    async write(buffer: Uint8Array, offset = 0, length = buffer.byteLength, position: number | null = null) {\n      const writeData = buffer.subarray(offset, offset + length);\n      const { status, data } = await asyncRequest(OP.FWRITE, '', 0, null, undefined, { fd, data: writeData, position: position ?? -1 });\n      if (status !== 0) throw statusToError(status, 'write', String(fd));\n      const bytesWritten = data ? new DataView(data.buffer, data.byteOffset, data.byteLength).getUint32(0, true) : 0;\n      return { bytesWritten, buffer };\n    },\n\n    async readFile(options?: ReadOptions | Encoding | null) {\n      const encoding = typeof options === 'string' ? options : options?.encoding;\n      const { status, data } = await asyncRequest(OP.FREAD, '', 0, null, undefined, { fd, length: Number.MAX_SAFE_INTEGER, position: 0 });\n      if (status !== 0) throw statusToError(status, 'read', String(fd));\n      const result = data ?? new Uint8Array(0);\n      if (encoding) return decoder.decode(result);\n      return result;\n    },\n\n    async writeFile(data: string | Uint8Array, _options?: WriteOptions | Encoding) {\n      const encoded = typeof data === 'string' ? encoder.encode(data) : data;\n      const { status } = await asyncRequest(OP.FWRITE, '', 0, null, undefined, { fd, data: encoded, position: 0 });\n      if (status !== 0) throw statusToError(status, 'write', String(fd));\n    },\n\n    async truncate(len = 0) {\n      const { status } = await asyncRequest(OP.FTRUNCATE, '', 0, null, undefined, { fd, length: len });\n      if (status !== 0) throw statusToError(status, 'ftruncate', String(fd));\n    },\n\n    async stat() {\n      const { status, data } = await asyncRequest(OP.FSTAT, '', 0, null, undefined, { fd });\n      if (status !== 0) throw statusToError(status, 'fstat', String(fd));\n      return decodeStats(data!);\n    },\n\n    async sync() {\n      await asyncRequest(OP.FSYNC, '');\n    },\n\n    async datasync() {\n      await asyncRequest(OP.FSYNC, '');\n    },\n\n    async close() {\n      const { status } = await asyncRequest(OP.CLOSE, '', 0, null, undefined, { fd });\n      if (status !== 0) throw statusToError(status, 'close', String(fd));\n    },\n  };\n}\n","import type { Dir, Dirent } from '../types.js';\nimport type { AsyncRequestFn } from './context.js';\nimport { OP } from '../protocol/opcodes.js';\nimport { statusToError } from '../errors.js';\nimport { readdir } from './readdir.js';\n\nexport async function opendir(\n  asyncRequest: AsyncRequestFn,\n  filePath: string\n): Promise<Dir> {\n  const { status, data } = await asyncRequest(OP.OPENDIR, filePath);\n  if (status !== 0) throw statusToError(status, 'opendir', filePath);\n  const fd = new DataView(data!.buffer, data!.byteOffset, data!.byteLength).getUint32(0, true);\n\n  let entries: Dirent[] | null = null;\n  let index = 0;\n\n  const loadEntries = async () => {\n    if (entries === null) {\n      entries = await readdir(asyncRequest, filePath, { withFileTypes: true }) as Dirent[];\n    }\n  };\n\n  return {\n    path: filePath,\n\n    async read(): Promise<Dirent | null> {\n      await loadEntries();\n      if (index >= entries!.length) return null;\n      return entries![index++];\n    },\n\n    async close(): Promise<void> {\n      const { status } = await asyncRequest(OP.CLOSE, '', 0, null, undefined, { fd });\n      if (status !== 0) throw statusToError(status, 'close', String(fd));\n    },\n\n    async *[Symbol.asyncIterator](): AsyncIterableIterator<Dirent> {\n      await loadEntries();\n      for (const entry of entries!) {\n        yield entry;\n      }\n    },\n  };\n}\n","/**\n * POSIX path utilities (browser-compatible).\n * No Node.js dependencies.\n */\n\nexport const sep = '/';\nexport const delimiter = ':';\n\nexport function normalize(p: string): string {\n  if (p.length === 0) return '.';\n\n  const isAbsolute = p.charCodeAt(0) === 47; // '/'\n  const segments = p.split('/');\n  const result: string[] = [];\n\n  for (const seg of segments) {\n    if (seg === '' || seg === '.') continue;\n    if (seg === '..') {\n      if (result.length > 0 && result[result.length - 1] !== '..') {\n        result.pop();\n      } else if (!isAbsolute) {\n        result.push('..');\n      }\n    } else {\n      result.push(seg);\n    }\n  }\n\n  let out = result.join('/');\n  if (isAbsolute) out = '/' + out;\n  return out || (isAbsolute ? '/' : '.');\n}\n\nexport function join(...paths: string[]): string {\n  return normalize(paths.filter(Boolean).join('/'));\n}\n\nexport function resolve(...paths: string[]): string {\n  let resolved = '';\n  for (let i = paths.length - 1; i >= 0; i--) {\n    const p = paths[i];\n    if (!p) continue;\n    resolved = p + (resolved ? '/' + resolved : '');\n    if (p.charCodeAt(0) === 47) break; // absolute\n  }\n  return normalize(resolved || '/');\n}\n\nexport function dirname(p: string): string {\n  if (p.length === 0) return '.';\n  const i = p.lastIndexOf('/');\n  if (i < 0) return '.';\n  if (i === 0) return '/';\n  return p.substring(0, i);\n}\n\nexport function basename(p: string, ext?: string): string {\n  let base = p;\n  const i = p.lastIndexOf('/');\n  if (i >= 0) base = p.substring(i + 1);\n  if (ext && base.endsWith(ext)) {\n    base = base.substring(0, base.length - ext.length);\n  }\n  return base;\n}\n\nexport function extname(p: string): string {\n  const base = basename(p);\n  const i = base.lastIndexOf('.');\n  if (i <= 0) return '';\n  return base.substring(i);\n}\n\nexport function isAbsolute(p: string): boolean {\n  return p.length > 0 && p.charCodeAt(0) === 47;\n}\n\nexport function relative(from: string, to: string): string {\n  const fromParts = resolve(from).split('/').filter(Boolean);\n  const toParts = resolve(to).split('/').filter(Boolean);\n\n  let common = 0;\n  while (common < fromParts.length && common < toParts.length && fromParts[common] === toParts[common]) {\n    common++;\n  }\n\n  const ups = fromParts.length - common;\n  const result = [...Array(ups).fill('..'), ...toParts.slice(common)];\n  return result.join('/') || '.';\n}\n\nexport function parse(p: string): { root: string; dir: string; base: string; ext: string; name: string } {\n  const dir = dirname(p);\n  const base = basename(p);\n  const ext = extname(p);\n  const name = ext ? base.substring(0, base.length - ext.length) : base;\n  const root = isAbsolute(p) ? '/' : '';\n  return { root, dir, base, ext, name };\n}\n\nexport function format(obj: { root?: string; dir?: string; base?: string; ext?: string; name?: string }): string {\n  const dir = obj.dir || obj.root || '';\n  const base = obj.base || ((obj.name || '') + (obj.ext || ''));\n  return dir ? (dir === '/' ? '/' + base : dir + '/' + base) : base;\n}\n","import type { WatchOptions, WatchEventType, FSWatcher, WatchListener, WatchFileListener, WatchFileOptions, Stats } from '../types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './context.js';\nimport { statSync } from './stat.js';\nimport * as path from '../path.js';\n\n// ========== Watcher Registry ==========\n\ninterface WatchEntry {\n  absPath: string;\n  recursive: boolean;\n  listener: WatchListener;\n  signal?: AbortSignal;\n}\n\ninterface WatchFileEntry {\n  absPath: string;\n  listener: WatchFileListener;\n  interval: number;\n  prevStats: Stats | null;\n  syncRequest: SyncRequestFn;\n  timerId: ReturnType<typeof setInterval> | null;\n}\n\n// fs.watch() entries\nconst watchers = new Set<WatchEntry>();\n\n// fs.watchFile() entries, keyed by absolute path\nconst fileWatchers = new Map<string, Set<WatchFileEntry>>();\n\n// Lazy BroadcastChannel with ref counting\nlet bc: BroadcastChannel | null = null;\nlet bcRefCount = 0;\n\nfunction ensureBc(): void {\n  if (bc) { bcRefCount++; return; }\n  bc = new BroadcastChannel('vfs-watch');\n  bcRefCount = 1;\n  bc.onmessage = onBroadcast;\n}\n\nfunction releaseBc(): void {\n  if (--bcRefCount <= 0 && bc) {\n    bc.close();\n    bc = null;\n    bcRefCount = 0;\n  }\n}\n\n// ========== BroadcastChannel handler ==========\n\nfunction onBroadcast(event: MessageEvent<{ eventType: 'change' | 'rename'; path: string }>): void {\n  const { eventType, path: mutatedPath } = event.data;\n\n  // Notify fs.watch() watchers\n  for (const entry of watchers) {\n    const filename = matchWatcher(entry, mutatedPath);\n    if (filename !== null) {\n      try { entry.listener(eventType, filename); } catch { /* swallow */ }\n    }\n  }\n\n  // Notify fs.watchFile() watchers\n  const fileSet = fileWatchers.get(mutatedPath);\n  if (fileSet) {\n    for (const entry of fileSet) {\n      triggerWatchFile(entry);\n    }\n  }\n}\n\n// ========== Path matching ==========\n\nfunction matchWatcher(entry: WatchEntry, mutatedPath: string): string | null {\n  const { absPath, recursive } = entry;\n\n  // Exact match (watching a specific file, or the directory itself was modified)\n  if (mutatedPath === absPath) {\n    return path.basename(mutatedPath);\n  }\n\n  // Check if mutatedPath is inside absPath (directory watching)\n  if (!mutatedPath.startsWith(absPath) || mutatedPath.charAt(absPath.length) !== '/') {\n    return null;\n  }\n\n  const relativePath = mutatedPath.substring(absPath.length + 1);\n\n  if (recursive) return relativePath;\n\n  // Non-recursive: only direct children (no '/' in relative path)\n  return relativePath.indexOf('/') === -1 ? relativePath : null;\n}\n\n// ========== fs.watch() ==========\n\nexport function watch(\n  filePath: string,\n  options?: WatchOptions | string,\n  listener?: WatchListener\n): FSWatcher {\n  const opts: WatchOptions = typeof options === 'string'\n    ? { encoding: options as any }\n    : (options ?? {});\n\n  const cb: WatchListener = listener ?? (() => {});\n  const absPath = path.resolve(filePath);\n  const signal = opts.signal;\n\n  const entry: WatchEntry = {\n    absPath,\n    recursive: opts.recursive ?? false,\n    listener: cb,\n    signal,\n  };\n\n  ensureBc();\n  watchers.add(entry);\n\n  // AbortSignal support\n  if (signal) {\n    const onAbort = () => {\n      watchers.delete(entry);\n      releaseBc();\n      signal.removeEventListener('abort', onAbort);\n    };\n    if (signal.aborted) {\n      onAbort();\n    } else {\n      signal.addEventListener('abort', onAbort);\n    }\n  }\n\n  const watcher: FSWatcher = {\n    close() {\n      watchers.delete(entry);\n      releaseBc();\n    },\n    ref() { return watcher; },\n    unref() { return watcher; },\n  };\n\n  return watcher;\n}\n\n// ========== fs.watchFile() ==========\n\nexport function watchFile(\n  syncRequest: SyncRequestFn,\n  filePath: string,\n  optionsOrListener?: WatchFileOptions | WatchFileListener,\n  listener?: WatchFileListener\n): void {\n  let opts: WatchFileOptions;\n  let cb: WatchFileListener;\n\n  if (typeof optionsOrListener === 'function') {\n    cb = optionsOrListener;\n    opts = {};\n  } else {\n    opts = optionsOrListener ?? {};\n    cb = listener!;\n  }\n\n  if (!cb) return;\n\n  const absPath = path.resolve(filePath);\n  const interval = opts.interval ?? 5007; // Node.js default\n\n  let prevStats: Stats | null = null;\n  try { prevStats = statSync(syncRequest, absPath); } catch { /* file may not exist */ }\n\n  const entry: WatchFileEntry = {\n    absPath,\n    listener: cb,\n    interval,\n    prevStats,\n    syncRequest,\n    timerId: null,\n  };\n\n  ensureBc();\n  let set = fileWatchers.get(absPath);\n  if (!set) {\n    set = new Set();\n    fileWatchers.set(absPath, set);\n  }\n  set.add(entry);\n\n  // Fallback polling (Node.js watchFile uses stat polling)\n  entry.timerId = setInterval(() => triggerWatchFile(entry), interval);\n}\n\n// ========== fs.unwatchFile() ==========\n\nexport function unwatchFile(\n  filePath: string,\n  listener?: WatchFileListener\n): void {\n  const absPath = path.resolve(filePath);\n  const set = fileWatchers.get(absPath);\n  if (!set) return;\n\n  if (listener) {\n    for (const entry of set) {\n      if (entry.listener === listener) {\n        if (entry.timerId !== null) clearInterval(entry.timerId);\n        set.delete(entry);\n        releaseBc();\n        break;\n      }\n    }\n    if (set.size === 0) fileWatchers.delete(absPath);\n  } else {\n    for (const entry of set) {\n      if (entry.timerId !== null) clearInterval(entry.timerId);\n      releaseBc();\n    }\n    fileWatchers.delete(absPath);\n  }\n}\n\n// ========== watchFile trigger ==========\n\nfunction triggerWatchFile(entry: WatchFileEntry): void {\n  let currStats: Stats | null = null;\n  try { currStats = statSync(entry.syncRequest, entry.absPath); } catch { /* file gone */ }\n\n  const prev = entry.prevStats ?? emptyStats();\n  const curr = currStats ?? emptyStats();\n\n  if (prev.mtimeMs !== curr.mtimeMs || prev.size !== curr.size || prev.ino !== curr.ino) {\n    entry.prevStats = currStats;\n    try { entry.listener(curr, prev); } catch { /* swallow */ }\n  }\n}\n\nfunction emptyStats(): Stats {\n  const zero = new Date(0);\n  return {\n    isFile: () => false,\n    isDirectory: () => false,\n    isBlockDevice: () => false,\n    isCharacterDevice: () => false,\n    isSymbolicLink: () => false,\n    isFIFO: () => false,\n    isSocket: () => false,\n    dev: 0, ino: 0, mode: 0, nlink: 0, uid: 0, gid: 0, rdev: 0,\n    size: 0, blksize: 4096, blocks: 0,\n    atimeMs: 0, mtimeMs: 0, ctimeMs: 0, birthtimeMs: 0,\n    atime: zero, mtime: zero, ctime: zero, birthtime: zero,\n  };\n}\n\n// ========== promises.watch() ==========\n\nexport async function* watchAsync(\n  _asyncRequest: AsyncRequestFn,\n  filePath: string,\n  options?: WatchOptions\n): AsyncIterable<WatchEventType> {\n  const absPath = path.resolve(filePath);\n  const recursive = options?.recursive ?? false;\n  const signal = options?.signal;\n\n  const queue: WatchEventType[] = [];\n  let resolve: (() => void) | null = null;\n\n  const entry: WatchEntry = {\n    absPath,\n    recursive,\n    listener: (eventType, filename) => {\n      queue.push({ eventType, filename });\n      if (resolve) { resolve(); resolve = null; }\n    },\n    signal,\n  };\n\n  ensureBc();\n  watchers.add(entry);\n\n  try {\n    while (!signal?.aborted) {\n      if (queue.length === 0) {\n        await new Promise<void>(r => { resolve = r; });\n      }\n      while (queue.length > 0) {\n        yield queue.shift()!;\n      }\n    }\n  } finally {\n    watchers.delete(entry);\n    releaseBc();\n  }\n}\n","/**\n * VFSFileSystem  main thread API.\n *\n * Provides Node.js-compatible sync and async filesystem methods.\n * Sync methods use SAB + Atomics to block until the server responds.\n * Async methods use postMessage to the async relay worker.\n *\n * On import, workers are spawned immediately. Every method blocks\n * (or waits) until the worker is ready. This is by design  the library\n * primarily runs inside workers where blocking is fine.\n */\n\nimport type {\n  Encoding, ReadOptions, WriteOptions, MkdirOptions, RmdirOptions, RmOptions,\n  ReaddirOptions, Stats, Dirent, VFSConfig,\n  WatchOptions, WatchFileOptions, WatchEventType, FSWatcher, WatchListener, WatchFileListener,\n  ReadStreamOptions, WriteStreamOptions,\n} from './types.js';\nimport type { SyncRequestFn, AsyncRequestFn } from './methods/context.js';\nimport { SAB_OFFSETS, SIGNAL, OP, encodeRequest, decodeResponse } from './protocol/opcodes.js';\n\n// ---- Method imports ----\nimport { readFileSync as _readFileSync, readFile as _readFile } from './methods/readFile.js';\nimport { writeFileSync as _writeFileSync, writeFile as _writeFile } from './methods/writeFile.js';\nimport { appendFileSync as _appendFileSync, appendFile as _appendFile } from './methods/appendFile.js';\nimport { existsSync as _existsSync, exists as _exists } from './methods/exists.js';\nimport { mkdirSync as _mkdirSync, mkdir as _mkdir } from './methods/mkdir.js';\nimport { rmdirSync as _rmdirSync, rmdir as _rmdir } from './methods/rmdir.js';\nimport { rmSync as _rmSync, rm as _rm } from './methods/rm.js';\nimport { unlinkSync as _unlinkSync, unlink as _unlink } from './methods/unlink.js';\nimport { readdirSync as _readdirSync, readdir as _readdir } from './methods/readdir.js';\nimport { statSync as _statSync, lstatSync as _lstatSync, stat as _stat, lstat as _lstat } from './methods/stat.js';\nimport { renameSync as _renameSync, rename as _rename } from './methods/rename.js';\nimport { copyFileSync as _copyFileSync, copyFile as _copyFile } from './methods/copyFile.js';\nimport { truncateSync as _truncateSync, truncate as _truncate } from './methods/truncate.js';\nimport { accessSync as _accessSync, access as _access } from './methods/access.js';\nimport { realpathSync as _realpathSync, realpath as _realpath } from './methods/realpath.js';\nimport { chmodSync as _chmodSync, chmod as _chmod } from './methods/chmod.js';\nimport { chownSync as _chownSync, chown as _chown } from './methods/chown.js';\nimport { utimesSync as _utimesSync, utimes as _utimes } from './methods/utimes.js';\nimport { symlinkSync as _symlinkSync, readlinkSync as _readlinkSync, symlink as _symlink, readlink as _readlink } from './methods/symlink.js';\nimport { linkSync as _linkSync, link as _link } from './methods/link.js';\nimport { mkdtempSync as _mkdtempSync, mkdtemp as _mkdtemp } from './methods/mkdtemp.js';\nimport {\n  openSync as _openSync, closeSync as _closeSync,\n  readSync as _readSync, writeSyncFd as _writeSyncFd,\n  fstatSync as _fstatSync, ftruncateSync as _ftruncateSync, fdatasyncSync as _fdatasyncSync,\n  open as _open,\n} from './methods/open.js';\nimport { opendir as _opendir } from './methods/opendir.js';\nimport { watch as _watch, watchFile as _watchFile, unwatchFile as _unwatchFile, watchAsync as _watchAsync } from './methods/watch.js';\n\nconst encoder = new TextEncoder();\n\n// Default SAB size: 2MB\nconst DEFAULT_SAB_SIZE = 2 * 1024 * 1024;\nconst HEADER_SIZE = SAB_OFFSETS.HEADER_SIZE;\n\n// Atomics.wait() is disallowed on the browser main thread.\n// Use spin-wait (Atomics.load loop) as fallback.\nconst _canAtomicsWait = typeof globalThis.WorkerGlobalScope !== 'undefined';\n\nfunction spinWait(arr: Int32Array, index: number, value: number): void {\n  if (_canAtomicsWait) {\n    Atomics.wait(arr, index, value);\n  } else {\n    while (Atomics.load(arr, index) === value) {\n      // spin\n    }\n  }\n}\n\nexport class VFSFileSystem {\n  // SAB for sync communication with sync relay worker (null when SAB unavailable)\n  private sab!: SharedArrayBuffer;\n  private ctrl!: Int32Array;\n  private readySab!: SharedArrayBuffer;\n  private readySignal!: Int32Array;\n  // SAB for async-relay  sync-relay communication\n  private asyncSab!: SharedArrayBuffer;\n  // Whether SharedArrayBuffer is available (crossOriginIsolated)\n  private hasSAB = typeof SharedArrayBuffer !== 'undefined';\n\n  // Workers\n  private syncWorker!: Worker;\n  private asyncWorker!: Worker;\n\n  // Async request tracking\n  private asyncCallId = 0;\n  private asyncPending = new Map<number, {\n    resolve: (result: { status: number; data: Uint8Array | null }) => void;\n    reject: (err: Error) => void;\n  }>();\n\n  // Ready promise for async callers\n  private readyPromise: Promise<void>;\n  private resolveReady!: () => void;\n  private isReady = false;\n\n  // Config\n  private config: Omit<Required<VFSConfig>, 'opfsSyncRoot'> & { opfsSyncRoot?: string };\n  private tabId: string;\n\n  // Service worker registration for multi-tab port transfer\n  private swReg: ServiceWorkerRegistration | null = null;\n  private isFollower = false;\n  private holdingLeaderLock = false;\n  private brokerInitialized = false;\n  private leaderChangeBc: BroadcastChannel | null = null;\n\n  // Bound request functions for method delegation\n  private _sync: SyncRequestFn = (buf) => this.syncRequest(buf);\n  private _async: AsyncRequestFn = (op, p, flags, data, path2, fdArgs) =>\n    this.asyncRequest(op, p, flags, data, path2, fdArgs);\n\n  // Promises API namespace\n  readonly promises: VFSPromises;\n\n  constructor(config: VFSConfig = {}) {\n    this.config = {\n      root: config.root ?? '/',\n      opfsSync: config.opfsSync ?? true,\n      opfsSyncRoot: config.opfsSyncRoot,\n      uid: config.uid ?? 0,\n      gid: config.gid ?? 0,\n      umask: config.umask ?? 0o022,\n      strictPermissions: config.strictPermissions ?? false,\n      sabSize: config.sabSize ?? DEFAULT_SAB_SIZE,\n      debug: config.debug ?? false,\n    };\n\n    this.tabId = crypto.randomUUID();\n    this.readyPromise = new Promise(resolve => { this.resolveReady = resolve; });\n    this.promises = new VFSPromises(this._async);\n\n    this.bootstrap();\n  }\n\n  /** Spawn workers and establish communication */\n  private bootstrap(): void {\n    const sabSize = this.config.sabSize;\n\n    if (this.hasSAB) {\n      // Full mode: allocate SABs for sync + async communication\n      this.sab = new SharedArrayBuffer(sabSize);\n      this.readySab = new SharedArrayBuffer(4);\n      this.asyncSab = new SharedArrayBuffer(sabSize);\n      this.ctrl = new Int32Array(this.sab, 0, 8);\n      this.readySignal = new Int32Array(this.readySab, 0, 1);\n    }\n\n    // Spawn workers\n    this.syncWorker = this.spawnWorker('sync-relay');\n    this.asyncWorker = this.spawnWorker('async-relay');\n\n    // Handle messages from sync-relay\n    this.syncWorker.onmessage = (e: MessageEvent) => {\n      const msg = e.data;\n      if (msg.type === 'ready') {\n        this.isReady = true;\n        this.resolveReady();\n        if (!this.isFollower) {\n          this.initLeaderBroker();\n        }\n      } else if (msg.type === 'init-failed') {\n        if (this.holdingLeaderLock) {\n          // We hold the lock but OPFS handle not released yet  retry\n          setTimeout(() => this.sendLeaderInit(), 500);\n        } else if (!('locks' in navigator)) {\n          // No Web Locks fallback  become follower via OPFS handle detection\n          this.startAsFollower();\n        }\n      }\n    };\n\n    // Handle async responses from async-relay\n    this.asyncWorker.onmessage = (e: MessageEvent) => {\n      const msg = e.data;\n      if (msg.type === 'response') {\n        const pending = this.asyncPending.get(msg.callId);\n        if (pending) {\n          this.asyncPending.delete(msg.callId);\n          pending.resolve({ status: msg.status, data: msg.data });\n        }\n      }\n    };\n\n    if (this.hasSAB) {\n      // Initialize async relay with SAB (leader mode fast path)\n      this.asyncWorker.postMessage({\n        type: 'init-leader',\n        asyncSab: this.asyncSab,\n        wakeSab: this.sab,\n      });\n    } else {\n      // No SAB: connect async-relay  sync-relay via MessagePort\n      const mc = new MessageChannel();\n      this.asyncWorker.postMessage(\n        { type: 'init-port', port: mc.port1 },\n        [mc.port1],\n      );\n      this.syncWorker.postMessage(\n        { type: 'async-port', port: mc.port2 },\n        [mc.port2],\n      );\n    }\n\n    // Leader election via Web Locks\n    this.acquireLeaderLock();\n  }\n\n  /** Use Web Locks API for leader election. The tab that acquires the lock is\n   *  the leader; all others become followers. When the leader dies, the browser\n   *  releases the lock and the next waiting tab is promoted. */\n  private acquireLeaderLock(): void {\n    if (!('locks' in navigator)) {\n      this.startAsLeader();\n      return;\n    }\n\n    // Chrome can invoke the ifAvailable callback twice (once with lock, once\n    // with null). The `decided` flag ensures only the first invocation acts.\n    let decided = false;\n    navigator.locks.request('vfs-leader', { ifAvailable: true }, async (lock) => {\n      if (decided) return;\n      decided = true;\n      if (lock) {\n        this.holdingLeaderLock = true;\n        this.startAsLeader();\n        await new Promise(() => {}); // Hold lock forever (released when tab closes)\n      } else {\n        this.startAsFollower();\n        this.waitForLeaderLock();\n      }\n    });\n  }\n\n  /** Queue for leader takeover when the current leader's lock is released */\n  private waitForLeaderLock(): void {\n    if (!('locks' in navigator)) return;\n    navigator.locks.request('vfs-leader', async () => {\n      console.log('[VFS] Leader lock acquired  promoting to leader');\n      this.holdingLeaderLock = true;\n      this.promoteToLeader();\n      await new Promise(() => {}); // Hold lock as new leader\n    });\n  }\n\n  /** Send init-leader message to sync-relay worker */\n  private sendLeaderInit(): void {\n    this.syncWorker.postMessage({\n      type: 'init-leader',\n      sab: this.hasSAB ? this.sab : null,\n      readySab: this.hasSAB ? this.readySab : null,\n      asyncSab: this.hasSAB ? this.asyncSab : null,\n      tabId: this.tabId,\n      config: {\n        root: this.config.root,\n        opfsSync: this.config.opfsSync,\n        opfsSyncRoot: this.config.opfsSyncRoot,\n        uid: this.config.uid,\n        gid: this.config.gid,\n        umask: this.config.umask,\n        strictPermissions: this.config.strictPermissions,\n        debug: this.config.debug,\n      },\n    });\n  }\n\n  /** Start as leader  tell sync-relay to init VFS engine + OPFS handle */\n  private startAsLeader(): void {\n    this.isFollower = false;\n    this.sendLeaderInit();\n  }\n\n  /** Start as follower  connect to leader via service worker port brokering */\n  private startAsFollower(): void {\n    this.isFollower = true;\n\n    // Tell sync-relay to prepare for follower mode (sets SABs, awaits leader-port)\n    this.syncWorker.postMessage({\n      type: 'init-follower',\n      sab: this.hasSAB ? this.sab : null,\n      readySab: this.hasSAB ? this.readySab : null,\n      asyncSab: this.hasSAB ? this.asyncSab : null,\n      tabId: this.tabId,\n    });\n\n    // Connect to leader via service worker\n    this.connectToLeader();\n\n    // Listen for leader changes (BroadcastChannel is scope-independent, unlike SW clients API)\n    this.leaderChangeBc = new BroadcastChannel('vfs-leader-change');\n    this.leaderChangeBc.onmessage = () => {\n      if (this.isFollower) {\n        console.log('[VFS] Leader changed  reconnecting');\n        this.connectToLeader();\n      }\n    };\n  }\n\n  /** Send a new port to sync-relay for connecting to the current leader */\n  private connectToLeader(): void {\n    const mc = new MessageChannel();\n\n    // Send leader-port to sync-relay immediately so it can signal 'ready'.\n    // Messages posted to port1 queue until port2 is connected to the leader.\n    this.syncWorker.postMessage(\n      { type: 'leader-port', port: mc.port1 },\n      [mc.port1],\n    );\n\n    // Asynchronously connect port2 to the leader via service worker broker\n    this.getServiceWorker().then(sw => {\n      sw.postMessage({ type: 'transfer-port', tabId: this.tabId }, [mc.port2]);\n    }).catch(err => {\n      console.error('[VFS] Failed to connect to leader:', (err as Error).message);\n      mc.port2.close();\n    });\n  }\n\n  /** Register the VFS service worker and return the active SW */\n  private async getServiceWorker(): Promise<ServiceWorker> {\n    if (!this.swReg) {\n      const swUrl = new URL('./workers/service.worker.js', import.meta.url);\n      this.swReg = await navigator.serviceWorker.register(swUrl.href, { type: 'module' });\n    }\n    const reg = this.swReg;\n\n    if (reg.active) return reg.active;\n    const sw = reg.installing || reg.waiting;\n    if (!sw) throw new Error('No service worker found');\n\n    return new Promise<ServiceWorker>((resolve, reject) => {\n      const timer = setTimeout(() => {\n        sw.removeEventListener('statechange', onState);\n        reject(new Error('Service worker activation timeout'));\n      }, 5000);\n      const onState = () => {\n        if (sw.state === 'activated') {\n          clearTimeout(timer);\n          sw.removeEventListener('statechange', onState);\n          resolve(sw);\n        } else if (sw.state === 'redundant') {\n          clearTimeout(timer);\n          sw.removeEventListener('statechange', onState);\n          reject(new Error('SW redundant'));\n        }\n      };\n      sw.addEventListener('statechange', onState);\n      onState(); // Check immediately  state may have changed before listener was added\n    });\n  }\n\n  /** Register as leader with SW broker (receives follower ports via control channel) */\n  private initLeaderBroker(): void {\n    if (this.brokerInitialized) return;\n    this.brokerInitialized = true;\n\n    this.getServiceWorker().then(sw => {\n      const mc = new MessageChannel();\n      sw.postMessage({ type: 'register-server' }, [mc.port2]);\n\n      mc.port1.onmessage = (event: MessageEvent) => {\n        if (event.data.type === 'client-port') {\n          const clientPort = event.ports[0];\n          if (clientPort) {\n            this.syncWorker.postMessage(\n              { type: 'client-port', tabId: event.data.tabId, port: clientPort },\n              [clientPort],\n            );\n          }\n        }\n      };\n      mc.port1.start();\n\n      // Notify followers that a (new) leader is available  they should reconnect\n      const bc = new BroadcastChannel('vfs-leader-change');\n      bc.postMessage({ type: 'leader-changed' });\n      bc.close();\n    }).catch(err => {\n      console.warn('[VFS] SW broker unavailable, single-tab only:', (err as Error).message);\n    });\n  }\n\n  /** Promote from follower to leader (after leader tab dies and lock is acquired) */\n  private promoteToLeader(): void {\n    this.isFollower = false;\n    this.isReady = false;\n    this.brokerInitialized = false; // Allow re-registration with SW as new leader\n\n    // Stop listening for leader changes (we ARE the leader now)\n    if (this.leaderChangeBc) {\n      this.leaderChangeBc.close();\n      this.leaderChangeBc = null;\n    }\n\n    // Reset readyPromise for async callers during transition\n    this.readyPromise = new Promise(resolve => { this.resolveReady = resolve; });\n\n    // Terminate old workers\n    this.syncWorker.terminate();\n    this.asyncWorker.terminate();\n\n    // Allocate fresh SABs (only if available)\n    const sabSize = this.config.sabSize;\n    if (this.hasSAB) {\n      this.sab = new SharedArrayBuffer(sabSize);\n      this.readySab = new SharedArrayBuffer(4);\n      this.asyncSab = new SharedArrayBuffer(sabSize);\n      this.ctrl = new Int32Array(this.sab, 0, 8);\n      this.readySignal = new Int32Array(this.readySab, 0, 1);\n    }\n\n    // Spawn new workers\n    this.syncWorker = this.spawnWorker('sync-relay');\n    this.asyncWorker = this.spawnWorker('async-relay');\n\n    // Handle sync-relay messages\n    this.syncWorker.onmessage = (e: MessageEvent) => {\n      const msg = e.data;\n      if (msg.type === 'ready') {\n        this.isReady = true;\n        this.resolveReady();\n        this.initLeaderBroker();\n      } else if (msg.type === 'init-failed') {\n        // OPFS handle not yet released by dead leader  retry\n        console.warn('[VFS] Promotion: OPFS handle still busy, retrying...');\n        setTimeout(() => this.sendLeaderInit(), 500);\n      }\n    };\n\n    // Handle async responses\n    this.asyncWorker.onmessage = (e: MessageEvent) => {\n      const msg = e.data;\n      if (msg.type === 'response') {\n        const pending = this.asyncPending.get(msg.callId);\n        if (pending) {\n          this.asyncPending.delete(msg.callId);\n          pending.resolve({ status: msg.status, data: msg.data });\n        }\n      }\n    };\n\n    if (this.hasSAB) {\n      // Initialize async-relay with SAB\n      this.asyncWorker.postMessage({\n        type: 'init-leader',\n        asyncSab: this.asyncSab,\n        wakeSab: this.sab,\n      });\n    } else {\n      // No SAB: connect async-relay  sync-relay via MessagePort\n      const mc = new MessageChannel();\n      this.asyncWorker.postMessage(\n        { type: 'init-port', port: mc.port1 },\n        [mc.port1],\n      );\n      this.syncWorker.postMessage(\n        { type: 'async-port', port: mc.port2 },\n        [mc.port2],\n      );\n    }\n    this.sendLeaderInit();\n  }\n\n  /** Spawn an inline worker from bundled code */\n  private spawnWorker(name: string): Worker {\n    // In production, worker code is inlined as blob URLs at build time.\n    // For development, we use module workers.\n    const workerUrl = new URL(`./workers/${name}.worker.js`, import.meta.url);\n    return new Worker(workerUrl, { type: 'module' });\n  }\n\n  // ========== Sync operation primitives ==========\n\n  /** Block until workers are ready */\n  private ensureReady(): void {\n    if (this.isReady) return;\n    if (!this.hasSAB) {\n      throw new Error('Sync API requires crossOriginIsolated (COOP/COEP headers). Use the promises API instead.');\n    }\n    // Check if ready signal is set\n    if (Atomics.load(this.readySignal, 0) === 1) {\n      this.isReady = true;\n      return;\n    }\n    // Block until ready\n    spinWait(this.readySignal, 0, 0);\n    this.isReady = true;\n  }\n\n  /** Send a sync request via SAB and wait for response */\n  private syncRequest(requestBuf: ArrayBuffer): { status: number; data: Uint8Array | null } {\n    this.ensureReady();\n\n    const t0 = this.config.debug ? performance.now() : 0;\n    const maxChunk = this.sab.byteLength - HEADER_SIZE;\n    const requestBytes = new Uint8Array(requestBuf);\n    const totalLenView = new BigUint64Array(this.sab, SAB_OFFSETS.TOTAL_LEN, 1);\n\n    if (requestBytes.byteLength <= maxChunk) {\n      // Fast path: single chunk\n      new Uint8Array(this.sab, HEADER_SIZE, requestBytes.byteLength).set(requestBytes);\n      Atomics.store(this.ctrl, 3, requestBytes.byteLength); // chunk length\n      Atomics.store(totalLenView, 0, BigInt(requestBytes.byteLength));\n      Atomics.store(this.ctrl, 0, SIGNAL.REQUEST);\n      Atomics.notify(this.ctrl, 0);\n    } else {\n      // Multi-chunk: send in chunks\n      let sent = 0;\n      while (sent < requestBytes.byteLength) {\n        const chunkSize = Math.min(maxChunk, requestBytes.byteLength - sent);\n        new Uint8Array(this.sab, HEADER_SIZE, chunkSize).set(\n          requestBytes.subarray(sent, sent + chunkSize)\n        );\n        Atomics.store(this.ctrl, 3, chunkSize);\n        Atomics.store(totalLenView, 0, BigInt(requestBytes.byteLength));\n        Atomics.store(this.ctrl, 6, Math.floor(sent / maxChunk)); // chunk index\n\n        if (sent === 0) {\n          Atomics.store(this.ctrl, 0, SIGNAL.REQUEST);\n        } else {\n          Atomics.store(this.ctrl, 0, SIGNAL.CHUNK);\n        }\n        Atomics.notify(this.ctrl, 0);\n\n        sent += chunkSize;\n        if (sent < requestBytes.byteLength) {\n          // Wait for worker to ack\n          spinWait(this.ctrl, 0, sent === chunkSize ? SIGNAL.REQUEST : SIGNAL.CHUNK);\n        }\n      }\n    }\n\n    // Wait for response\n    spinWait(this.ctrl, 0, SIGNAL.REQUEST);\n\n    // Read response  may be chunked\n    const signal = Atomics.load(this.ctrl, 0);\n    const respChunkLen = Atomics.load(this.ctrl, 3);\n    const respTotalLen = Number(Atomics.load(totalLenView, 0));\n\n    let responseBytes: Uint8Array;\n\n    if (signal === SIGNAL.RESPONSE && respTotalLen <= maxChunk) {\n      // Single chunk response\n      responseBytes = new Uint8Array(this.sab, HEADER_SIZE, respChunkLen).slice();\n    } else {\n      // Multi-chunk response\n      responseBytes = new Uint8Array(respTotalLen);\n      let received = 0;\n\n      // Read first chunk\n      const firstLen = respChunkLen;\n      responseBytes.set(new Uint8Array(this.sab, HEADER_SIZE, firstLen), 0);\n      received += firstLen;\n\n      while (received < respTotalLen) {\n        // Ack and wait for next chunk\n        Atomics.store(this.ctrl, 0, SIGNAL.CHUNK_ACK);\n        Atomics.notify(this.ctrl, 0);\n        spinWait(this.ctrl, 0, SIGNAL.CHUNK_ACK);\n\n        const nextLen = Atomics.load(this.ctrl, 3);\n        responseBytes.set(new Uint8Array(this.sab, HEADER_SIZE, nextLen), received);\n        received += nextLen;\n      }\n    }\n\n    // Reset to idle  NO notify: the worker stays asleep until the next request's\n    // notify wakes it, giving us ONE cross-thread wake per operation instead of two.\n    Atomics.store(this.ctrl, 0, SIGNAL.IDLE);\n\n    const result = decodeResponse(responseBytes.buffer as ArrayBuffer);\n    if (this.config.debug) {\n      const t1 = performance.now();\n      console.log(`[syncRequest] size=${requestBuf.byteLength} roundTrip=${(t1 - t0).toFixed(3)}ms`);\n    }\n    return result;\n  }\n\n  // ========== Async operation primitive ==========\n\n  private asyncRequest(\n    op: number,\n    filePath: string,\n    flags?: number,\n    data?: Uint8Array | string | null,\n    path2?: string,\n    fdArgs?: Record<string, unknown>\n  ): Promise<{ status: number; data: Uint8Array | null }> {\n    return this.readyPromise.then(() => {\n      return new Promise((resolve, reject) => {\n        const callId = this.asyncCallId++;\n        this.asyncPending.set(callId, { resolve, reject });\n\n        this.asyncWorker.postMessage({\n          type: 'request',\n          callId,\n          op,\n          path: filePath,\n          flags: flags ?? 0,\n          data: data instanceof Uint8Array ? data : (typeof data === 'string' ? data : null),\n          path2,\n          fdArgs,\n        });\n      });\n    });\n  }\n\n  // ========== Sync API ==========\n\n  readFileSync(filePath: string, options?: ReadOptions | Encoding | null): string | Uint8Array {\n    return _readFileSync(this._sync, filePath, options);\n  }\n\n  writeFileSync(filePath: string, data: string | Uint8Array, options?: WriteOptions | Encoding): void {\n    _writeFileSync(this._sync, filePath, data, options);\n  }\n\n  appendFileSync(filePath: string, data: string | Uint8Array, options?: WriteOptions | Encoding): void {\n    _appendFileSync(this._sync, filePath, data, options);\n  }\n\n  existsSync(filePath: string): boolean {\n    return _existsSync(this._sync, filePath);\n  }\n\n  mkdirSync(filePath: string, options?: MkdirOptions | number): string | undefined {\n    return _mkdirSync(this._sync, filePath, options);\n  }\n\n  rmdirSync(filePath: string, options?: RmdirOptions): void {\n    _rmdirSync(this._sync, filePath, options);\n  }\n\n  rmSync(filePath: string, options?: RmOptions): void {\n    _rmSync(this._sync, filePath, options);\n  }\n\n  unlinkSync(filePath: string): void {\n    _unlinkSync(this._sync, filePath);\n  }\n\n  readdirSync(filePath: string, options?: ReaddirOptions | Encoding | null): string[] | Dirent[] {\n    return _readdirSync(this._sync, filePath, options);\n  }\n\n  statSync(filePath: string): Stats {\n    return _statSync(this._sync, filePath);\n  }\n\n  lstatSync(filePath: string): Stats {\n    return _lstatSync(this._sync, filePath);\n  }\n\n  renameSync(oldPath: string, newPath: string): void {\n    _renameSync(this._sync, oldPath, newPath);\n  }\n\n  copyFileSync(src: string, dest: string, mode?: number): void {\n    _copyFileSync(this._sync, src, dest, mode);\n  }\n\n  truncateSync(filePath: string, len?: number): void {\n    _truncateSync(this._sync, filePath, len);\n  }\n\n  accessSync(filePath: string, mode?: number): void {\n    _accessSync(this._sync, filePath, mode);\n  }\n\n  realpathSync(filePath: string): string {\n    return _realpathSync(this._sync, filePath);\n  }\n\n  chmodSync(filePath: string, mode: number): void {\n    _chmodSync(this._sync, filePath, mode);\n  }\n\n  chownSync(filePath: string, uid: number, gid: number): void {\n    _chownSync(this._sync, filePath, uid, gid);\n  }\n\n  utimesSync(filePath: string, atime: Date | number, mtime: Date | number): void {\n    _utimesSync(this._sync, filePath, atime, mtime);\n  }\n\n  symlinkSync(target: string, linkPath: string): void {\n    _symlinkSync(this._sync, target, linkPath);\n  }\n\n  readlinkSync(filePath: string): string {\n    return _readlinkSync(this._sync, filePath);\n  }\n\n  linkSync(existingPath: string, newPath: string): void {\n    _linkSync(this._sync, existingPath, newPath);\n  }\n\n  mkdtempSync(prefix: string): string {\n    return _mkdtempSync(this._sync, prefix);\n  }\n\n  // ---- File descriptor sync methods ----\n\n  openSync(filePath: string, flags: string | number = 'r', mode?: number): number {\n    return _openSync(this._sync, filePath, flags, mode);\n  }\n\n  closeSync(fd: number): void {\n    _closeSync(this._sync, fd);\n  }\n\n  readSync(fd: number, buffer: Uint8Array, offset = 0, length = buffer.byteLength, position: number | null = null): number {\n    return _readSync(this._sync, fd, buffer, offset, length, position);\n  }\n\n  writeSync(fd: number, buffer: Uint8Array, offset = 0, length = buffer.byteLength, position: number | null = null): number {\n    return _writeSyncFd(this._sync, fd, buffer, offset, length, position);\n  }\n\n  fstatSync(fd: number): Stats {\n    return _fstatSync(this._sync, fd);\n  }\n\n  ftruncateSync(fd: number, len?: number): void {\n    _ftruncateSync(this._sync, fd, len);\n  }\n\n  fdatasyncSync(fd: number): void {\n    _fdatasyncSync(this._sync, fd);\n  }\n\n  // ---- Watch methods ----\n\n  watch(filePath: string, options?: WatchOptions | Encoding, listener?: WatchListener): FSWatcher {\n    return _watch(filePath, options, listener);\n  }\n\n  watchFile(filePath: string, optionsOrListener?: WatchFileOptions | WatchFileListener, listener?: WatchFileListener): void {\n    _watchFile(this._sync, filePath, optionsOrListener, listener);\n  }\n\n  unwatchFile(filePath: string, listener?: WatchFileListener): void {\n    _unwatchFile(filePath, listener);\n  }\n\n  // ---- Stream methods ----\n\n  createReadStream(filePath: string, options?: ReadStreamOptions | string): ReadableStream<Uint8Array> {\n    const opts = typeof options === 'string' ? { encoding: options as Encoding } : options;\n    const start = opts?.start ?? 0;\n    const end = opts?.end;\n    const highWaterMark = opts?.highWaterMark ?? 64 * 1024;\n\n    let position = start;\n\n    return new ReadableStream<Uint8Array>({\n      pull: async (controller) => {\n        try {\n          const readLen = end !== undefined\n            ? Math.min(highWaterMark, end - position + 1)\n            : highWaterMark;\n\n          if (readLen <= 0) {\n            controller.close();\n            return;\n          }\n\n          const result = await this.promises.readFile(filePath);\n          const data = result instanceof Uint8Array ? result : encoder.encode(result);\n          const chunk = data.subarray(position, position + readLen);\n\n          if (chunk.byteLength === 0) {\n            controller.close();\n            return;\n          }\n\n          controller.enqueue(chunk);\n          position += chunk.byteLength;\n\n          if (end !== undefined && position > end) {\n            controller.close();\n          }\n        } catch (err) {\n          controller.error(err);\n        }\n      },\n    });\n  }\n\n  createWriteStream(filePath: string, options?: WriteStreamOptions | string): WritableStream<Uint8Array> {\n    const opts = typeof options === 'string' ? { encoding: options as Encoding } : options;\n    let position = opts?.start ?? 0;\n    let initialized = false;\n\n    return new WritableStream<Uint8Array>({\n      write: async (chunk) => {\n        if (!initialized) {\n          // Truncate file on first write (unless appending)\n          if (opts?.flags !== 'a' && opts?.flags !== 'a+') {\n            await this.promises.writeFile(filePath, new Uint8Array(0));\n          }\n          initialized = true;\n        }\n        await this.promises.appendFile(filePath, chunk);\n        position += chunk.byteLength;\n      },\n      close: async () => {\n        if (opts?.flush) {\n          await this.promises.flush();\n        }\n      },\n    });\n  }\n\n  // ---- Utility methods ----\n\n  flushSync(): void {\n    const buf = encodeRequest(OP.FSYNC, '');\n    this.syncRequest(buf);\n  }\n\n  purgeSync(): void {\n    // No-op  VFS doesn't have external caches to purge\n  }\n\n  /** Async init helper  avoid blocking main thread */\n  init(): Promise<void> {\n    return this.readyPromise;\n  }\n}\n\n// ========== Promises API ==========\n\nclass VFSPromises {\n  private _async: AsyncRequestFn;\n\n  constructor(asyncRequest: AsyncRequestFn) {\n    this._async = asyncRequest;\n  }\n\n  readFile(filePath: string, options?: ReadOptions | Encoding | null) {\n    return _readFile(this._async, filePath, options);\n  }\n\n  writeFile(filePath: string, data: string | Uint8Array, options?: WriteOptions | Encoding) {\n    return _writeFile(this._async, filePath, data, options);\n  }\n\n  appendFile(filePath: string, data: string | Uint8Array, options?: WriteOptions | Encoding) {\n    return _appendFile(this._async, filePath, data, options);\n  }\n\n  mkdir(filePath: string, options?: MkdirOptions | number) {\n    return _mkdir(this._async, filePath, options);\n  }\n\n  rmdir(filePath: string, options?: RmdirOptions) {\n    return _rmdir(this._async, filePath, options);\n  }\n\n  rm(filePath: string, options?: RmOptions) {\n    return _rm(this._async, filePath, options);\n  }\n\n  unlink(filePath: string) {\n    return _unlink(this._async, filePath);\n  }\n\n  readdir(filePath: string, options?: ReaddirOptions | Encoding | null) {\n    return _readdir(this._async, filePath, options);\n  }\n\n  stat(filePath: string) {\n    return _stat(this._async, filePath);\n  }\n\n  lstat(filePath: string) {\n    return _lstat(this._async, filePath);\n  }\n\n  access(filePath: string, mode?: number) {\n    return _access(this._async, filePath, mode);\n  }\n\n  rename(oldPath: string, newPath: string) {\n    return _rename(this._async, oldPath, newPath);\n  }\n\n  copyFile(src: string, dest: string, mode?: number) {\n    return _copyFile(this._async, src, dest, mode);\n  }\n\n  truncate(filePath: string, len?: number) {\n    return _truncate(this._async, filePath, len);\n  }\n\n  realpath(filePath: string) {\n    return _realpath(this._async, filePath);\n  }\n\n  exists(filePath: string) {\n    return _exists(this._async, filePath);\n  }\n\n  chmod(filePath: string, mode: number) {\n    return _chmod(this._async, filePath, mode);\n  }\n\n  chown(filePath: string, uid: number, gid: number) {\n    return _chown(this._async, filePath, uid, gid);\n  }\n\n  utimes(filePath: string, atime: Date | number, mtime: Date | number) {\n    return _utimes(this._async, filePath, atime, mtime);\n  }\n\n  symlink(target: string, linkPath: string) {\n    return _symlink(this._async, target, linkPath);\n  }\n\n  readlink(filePath: string) {\n    return _readlink(this._async, filePath);\n  }\n\n  link(existingPath: string, newPath: string) {\n    return _link(this._async, existingPath, newPath);\n  }\n\n  open(filePath: string, flags?: string | number, mode?: number) {\n    return _open(this._async, filePath, flags, mode);\n  }\n\n  opendir(filePath: string) {\n    return _opendir(this._async, filePath);\n  }\n\n  mkdtemp(prefix: string) {\n    return _mkdtemp(this._async, prefix);\n  }\n\n  async *watch(filePath: string, options?: WatchOptions): AsyncIterable<WatchEventType> {\n    yield* _watchAsync(this._async, filePath, options);\n  }\n\n  async flush(): Promise<void> {\n    await this._async(OP.FSYNC, '');\n  }\n\n  async purge(): Promise<void> {\n    // No-op\n  }\n}\n","/**\n * VFS Engine  operates on a FileSystemSyncAccessHandle\n *\n * Manages the binary VFS layout: superblock, inode table, path table,\n * free block bitmap, and data region. All operations are synchronous\n * and run inside the server worker.\n */\n\nimport {\n  VFS_MAGIC, VFS_VERSION, SUPERBLOCK, INODE, INODE_SIZE, INODE_TYPE,\n  DEFAULT_BLOCK_SIZE, DEFAULT_INODE_COUNT, DEFAULT_FILE_MODE, DEFAULT_DIR_MODE,\n  DEFAULT_SYMLINK_MODE, DEFAULT_UMASK, S_IFMT, S_IFREG, S_IFDIR, S_IFLNK,\n  MAX_SYMLINK_DEPTH, INITIAL_DATA_BLOCKS, INITIAL_PATH_TABLE_SIZE,\n  calculateLayout,\n} from './layout.js';\nimport { CODE_TO_STATUS } from '../errors.js';\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\ninterface Inode {\n  type: number;\n  pathOffset: number;\n  pathLength: number;\n  mode: number;\n  size: number;\n  firstBlock: number;\n  blockCount: number;\n  mtime: number;\n  ctime: number;\n  atime: number;\n  uid: number;\n  gid: number;\n}\n\ninterface FdEntry {\n  tabId: string;\n  inodeIdx: number;\n  position: number;\n  flags: number;\n}\n\nexport class VFSEngine {\n  private handle!: FileSystemSyncAccessHandle;\n  private pathIndex = new Map<string, number>(); // path  inode index\n  private inodeCount = 0;\n  private blockSize = DEFAULT_BLOCK_SIZE;\n  private totalBlocks = 0;\n  private freeBlocks = 0;\n  private inodeTableOffset = 0;\n  private pathTableOffset = 0;\n  private pathTableUsed = 0;\n  private pathTableSize = 0;\n  private bitmapOffset = 0;\n  private dataOffset = 0;\n  private umask = DEFAULT_UMASK;\n  private processUid = 0;\n  private processGid = 0;\n  private strictPermissions = false;\n  private debug = false;\n\n  // File descriptor table\n  private fdTable = new Map<number, FdEntry>();\n  private nextFd = 3; // 0=stdin, 1=stdout, 2=stderr reserved\n\n  // Reusable buffers to avoid allocations\n  private inodeBuf = new Uint8Array(INODE_SIZE);\n  private inodeView = new DataView(this.inodeBuf.buffer);\n\n  // In-memory inode cache  eliminates disk reads for hot inodes\n  private inodeCache = new Map<number, Inode>();\n  private superblockBuf = new Uint8Array(SUPERBLOCK.SIZE);\n  private superblockView = new DataView(this.superblockBuf.buffer);\n\n  // In-memory bitmap cache  eliminates bitmap reads from OPFS\n  private bitmap: Uint8Array | null = null;\n  private bitmapDirtyLo = Infinity;   // lowest dirty byte index\n  private bitmapDirtyHi = -1;         // highest dirty byte index (inclusive)\n  private superblockDirty = false;\n\n  // Free inode hint  skip O(n) scan\n  private freeInodeHint = 0;\n\n  init(\n    handle: FileSystemSyncAccessHandle,\n    opts?: { uid?: number; gid?: number; umask?: number; strictPermissions?: boolean; debug?: boolean }\n  ): void {\n    this.handle = handle;\n    this.processUid = opts?.uid ?? 0;\n    this.processGid = opts?.gid ?? 0;\n    this.umask = opts?.umask ?? DEFAULT_UMASK;\n    this.strictPermissions = opts?.strictPermissions ?? false;\n    this.debug = opts?.debug ?? false;\n\n    const size = handle.getSize();\n\n    if (size === 0) {\n      this.format();\n    } else {\n      this.mount();\n    }\n  }\n\n  /** Release the sync access handle (call on fatal error or shutdown) */\n  closeHandle(): void {\n    try {\n      this.handle?.close();\n    } catch (_) {\n      // Ignore  handle may already be closed\n    }\n  }\n\n  /** Format a fresh VFS */\n  private format(): void {\n    const layout = calculateLayout(DEFAULT_INODE_COUNT, DEFAULT_BLOCK_SIZE, INITIAL_DATA_BLOCKS);\n\n    this.inodeCount = DEFAULT_INODE_COUNT;\n    this.blockSize = DEFAULT_BLOCK_SIZE;\n    this.totalBlocks = layout.totalBlocks;\n    this.freeBlocks = layout.totalBlocks;\n    this.inodeTableOffset = layout.inodeTableOffset;\n    this.pathTableOffset = layout.pathTableOffset;\n    this.pathTableSize = layout.pathTableSize;\n    this.pathTableUsed = 0;\n    this.bitmapOffset = layout.bitmapOffset;\n    this.dataOffset = layout.dataOffset;\n\n    // Grow file to total size\n    this.handle.truncate(layout.totalSize);\n\n    // Write superblock\n    this.writeSuperblock();\n\n    // Zero out inode table (type=0 means free)\n    const zeroBuf = new Uint8Array(layout.inodeTableSize);\n    this.handle.write(zeroBuf, { at: this.inodeTableOffset });\n\n    // Zero out bitmap and cache in memory\n    this.bitmap = new Uint8Array(layout.bitmapSize);\n    this.handle.write(this.bitmap, { at: this.bitmapOffset });\n\n    // Create root directory inode\n    this.createInode('/', INODE_TYPE.DIRECTORY, DEFAULT_DIR_MODE, 0);\n\n    this.handle.flush();\n  }\n\n  /** Mount an existing VFS from disk  validates superblock integrity */\n  private mount(): void {\n    const fileSize = this.handle.getSize();\n    if (fileSize < SUPERBLOCK.SIZE) {\n      throw new Error(`Corrupt VFS: file too small (${fileSize} bytes, need at least ${SUPERBLOCK.SIZE})`);\n    }\n\n    this.handle.read(this.superblockBuf, { at: 0 });\n    const v = this.superblockView;\n\n    // Validate magic\n    const magic = v.getUint32(SUPERBLOCK.MAGIC, true);\n    if (magic !== VFS_MAGIC) {\n      throw new Error(`Corrupt VFS: bad magic 0x${magic.toString(16)} (expected 0x${VFS_MAGIC.toString(16)})`);\n    }\n\n    // Validate version\n    const version = v.getUint32(SUPERBLOCK.VERSION, true);\n    if (version !== VFS_VERSION) {\n      throw new Error(`Corrupt VFS: unsupported version ${version} (expected ${VFS_VERSION})`);\n    }\n\n    // Read superblock fields\n    const inodeCount = v.getUint32(SUPERBLOCK.INODE_COUNT, true);\n    const blockSize = v.getUint32(SUPERBLOCK.BLOCK_SIZE, true);\n    const totalBlocks = v.getUint32(SUPERBLOCK.TOTAL_BLOCKS, true);\n    const freeBlocks = v.getUint32(SUPERBLOCK.FREE_BLOCKS, true);\n    const inodeTableOffset = v.getFloat64(SUPERBLOCK.INODE_OFFSET, true);\n    const pathTableOffset = v.getFloat64(SUPERBLOCK.PATH_OFFSET, true);\n    const dataOffset = v.getFloat64(SUPERBLOCK.DATA_OFFSET, true);\n    const bitmapOffset = v.getFloat64(SUPERBLOCK.BITMAP_OFFSET, true);\n    const pathUsed = v.getUint32(SUPERBLOCK.PATH_USED, true);\n\n    // Validate field sanity\n    if (blockSize === 0 || (blockSize & (blockSize - 1)) !== 0) {\n      throw new Error(`Corrupt VFS: invalid block size ${blockSize} (must be power of 2)`);\n    }\n    if (inodeCount === 0) {\n      throw new Error('Corrupt VFS: inode count is 0');\n    }\n    if (freeBlocks > totalBlocks) {\n      throw new Error(`Corrupt VFS: free blocks (${freeBlocks}) exceeds total blocks (${totalBlocks})`);\n    }\n\n    // Validate section ordering: superblock < inodes < paths < bitmap < data\n    if (inodeTableOffset !== SUPERBLOCK.SIZE) {\n      throw new Error(`Corrupt VFS: inode table offset ${inodeTableOffset} (expected ${SUPERBLOCK.SIZE})`);\n    }\n    const expectedPathOffset = inodeTableOffset + inodeCount * INODE_SIZE;\n    if (pathTableOffset !== expectedPathOffset) {\n      throw new Error(`Corrupt VFS: path table offset ${pathTableOffset} (expected ${expectedPathOffset})`);\n    }\n    if (bitmapOffset <= pathTableOffset) {\n      throw new Error(`Corrupt VFS: bitmap offset ${bitmapOffset} must be after path table ${pathTableOffset}`);\n    }\n    if (dataOffset <= bitmapOffset) {\n      throw new Error(`Corrupt VFS: data offset ${dataOffset} must be after bitmap ${bitmapOffset}`);\n    }\n    const pathTableSize = bitmapOffset - pathTableOffset;\n    if (pathUsed > pathTableSize) {\n      throw new Error(`Corrupt VFS: path used (${pathUsed}) exceeds path table size (${pathTableSize})`);\n    }\n\n    // Validate file is large enough for the declared layout\n    const expectedMinSize = dataOffset + totalBlocks * blockSize;\n    if (fileSize < expectedMinSize) {\n      throw new Error(`Corrupt VFS: file size ${fileSize} too small for layout (need ${expectedMinSize})`);\n    }\n\n    // All checks passed  commit to engine state\n    this.inodeCount = inodeCount;\n    this.blockSize = blockSize;\n    this.totalBlocks = totalBlocks;\n    this.freeBlocks = freeBlocks;\n    this.inodeTableOffset = inodeTableOffset;\n    this.pathTableOffset = pathTableOffset;\n    this.dataOffset = dataOffset;\n    this.bitmapOffset = bitmapOffset;\n    this.pathTableUsed = pathUsed;\n    this.pathTableSize = pathTableSize;\n\n    // Load bitmap into memory\n    const bitmapSize = Math.ceil(this.totalBlocks / 8);\n    this.bitmap = new Uint8Array(bitmapSize);\n    this.handle.read(this.bitmap, { at: this.bitmapOffset });\n\n    this.rebuildIndex();\n\n    // Verify root directory exists\n    if (!this.pathIndex.has('/')) {\n      throw new Error('Corrupt VFS: root directory \"/\" not found in inode table');\n    }\n  }\n\n  private writeSuperblock(): void {\n    const v = this.superblockView;\n    v.setUint32(SUPERBLOCK.MAGIC, VFS_MAGIC, true);\n    v.setUint32(SUPERBLOCK.VERSION, VFS_VERSION, true);\n    v.setUint32(SUPERBLOCK.INODE_COUNT, this.inodeCount, true);\n    v.setUint32(SUPERBLOCK.BLOCK_SIZE, this.blockSize, true);\n    v.setUint32(SUPERBLOCK.TOTAL_BLOCKS, this.totalBlocks, true);\n    v.setUint32(SUPERBLOCK.FREE_BLOCKS, this.freeBlocks, true);\n    v.setFloat64(SUPERBLOCK.INODE_OFFSET, this.inodeTableOffset, true);\n    v.setFloat64(SUPERBLOCK.PATH_OFFSET, this.pathTableOffset, true);\n    v.setFloat64(SUPERBLOCK.DATA_OFFSET, this.dataOffset, true);\n    v.setFloat64(SUPERBLOCK.BITMAP_OFFSET, this.bitmapOffset, true);\n    v.setUint32(SUPERBLOCK.PATH_USED, this.pathTableUsed, true);\n    this.handle.write(this.superblockBuf, { at: 0 });\n  }\n\n  /** Flush pending bitmap and superblock writes to disk (one write each) */\n  private markBitmapDirty(lo: number, hi: number): void {\n    if (lo < this.bitmapDirtyLo) this.bitmapDirtyLo = lo;\n    if (hi > this.bitmapDirtyHi) this.bitmapDirtyHi = hi;\n  }\n\n  private commitPending(): void {\n    if (this.bitmapDirtyHi >= 0) {\n      const lo = this.bitmapDirtyLo;\n      const hi = this.bitmapDirtyHi;\n      this.handle.write(this.bitmap!.subarray(lo, hi + 1), { at: this.bitmapOffset + lo });\n      this.bitmapDirtyLo = Infinity;\n      this.bitmapDirtyHi = -1;\n    }\n    if (this.superblockDirty) {\n      this.writeSuperblock();\n      this.superblockDirty = false;\n    }\n  }\n\n  /** Rebuild in-memory pathinode index from disk */\n  private rebuildIndex(): void {\n    this.pathIndex.clear();\n    for (let i = 0; i < this.inodeCount; i++) {\n      const inode = this.readInode(i);\n      if (inode.type === INODE_TYPE.FREE) continue;\n      const path = this.readPath(inode.pathOffset, inode.pathLength);\n      this.pathIndex.set(path, i);\n    }\n  }\n\n  // ========== Low-level inode I/O ==========\n\n  private readInode(idx: number): Inode {\n    const cached = this.inodeCache.get(idx);\n    if (cached) return cached;\n\n    const offset = this.inodeTableOffset + idx * INODE_SIZE;\n    this.handle.read(this.inodeBuf, { at: offset });\n    const v = this.inodeView;\n    const inode: Inode = {\n      type: v.getUint8(INODE.TYPE),\n      pathOffset: v.getUint32(INODE.PATH_OFFSET, true),\n      pathLength: v.getUint16(INODE.PATH_LENGTH, true),\n      mode: v.getUint32(INODE.MODE, true),\n      size: v.getFloat64(INODE.SIZE, true),\n      firstBlock: v.getUint32(INODE.FIRST_BLOCK, true),\n      blockCount: v.getUint32(INODE.BLOCK_COUNT, true),\n      mtime: v.getFloat64(INODE.MTIME, true),\n      ctime: v.getFloat64(INODE.CTIME, true),\n      atime: v.getFloat64(INODE.ATIME, true),\n      uid: v.getUint32(INODE.UID, true),\n      gid: v.getUint32(INODE.GID, true),\n    };\n    this.inodeCache.set(idx, inode);\n    return inode;\n  }\n\n  private writeInode(idx: number, inode: Inode): void {\n    // Maintain inode cache\n    if (inode.type === INODE_TYPE.FREE) {\n      this.inodeCache.delete(idx);\n    } else {\n      this.inodeCache.set(idx, inode);\n    }\n\n    const v = this.inodeView;\n    v.setUint8(INODE.TYPE, inode.type);\n    v.setUint8(INODE.FLAGS, 0);\n    v.setUint8(INODE.FLAGS + 1, 0);\n    v.setUint8(INODE.FLAGS + 2, 0);\n    v.setUint32(INODE.PATH_OFFSET, inode.pathOffset, true);\n    v.setUint16(INODE.PATH_LENGTH, inode.pathLength, true);\n    v.setUint16(INODE.RESERVED_10, 0, true);\n    v.setUint32(INODE.MODE, inode.mode, true);\n    v.setFloat64(INODE.SIZE, inode.size, true);\n    v.setUint32(INODE.FIRST_BLOCK, inode.firstBlock, true);\n    v.setUint32(INODE.BLOCK_COUNT, inode.blockCount, true);\n    v.setFloat64(INODE.MTIME, inode.mtime, true);\n    v.setFloat64(INODE.CTIME, inode.ctime, true);\n    v.setFloat64(INODE.ATIME, inode.atime, true);\n    v.setUint32(INODE.UID, inode.uid, true);\n    v.setUint32(INODE.GID, inode.gid, true);\n\n    const offset = this.inodeTableOffset + idx * INODE_SIZE;\n    this.handle.write(this.inodeBuf, { at: offset });\n  }\n\n  // ========== Path table I/O ==========\n\n  private readPath(offset: number, length: number): string {\n    const buf = new Uint8Array(length);\n    this.handle.read(buf, { at: this.pathTableOffset + offset });\n    return decoder.decode(buf);\n  }\n\n  private appendPath(path: string): { offset: number; length: number } {\n    const bytes = encoder.encode(path);\n    const offset = this.pathTableUsed;\n\n    // Check if path table needs to grow\n    if (offset + bytes.byteLength > this.pathTableSize) {\n      this.growPathTable(offset + bytes.byteLength);\n    }\n\n    this.handle.write(bytes, { at: this.pathTableOffset + offset });\n    this.pathTableUsed += bytes.byteLength;\n\n    // Defer superblock write  committed in commitPending()\n    this.superblockDirty = true;\n\n    return { offset, length: bytes.byteLength };\n  }\n\n  private growPathTable(needed: number): void {\n    // Double the path table or grow to fit needed, whichever is larger\n    const newSize = Math.max(this.pathTableSize * 2, needed + INITIAL_PATH_TABLE_SIZE);\n    const growth = newSize - this.pathTableSize;\n\n    // Need to shift bitmap and data region forward\n    // Use in-memory bitmap (no read needed)\n\n    // Read existing data region\n    const dataSize = this.totalBlocks * this.blockSize;\n    const dataBuf = new Uint8Array(dataSize);\n    this.handle.read(dataBuf, { at: this.dataOffset });\n\n    // Grow file\n    const newTotalSize = this.handle.getSize() + growth;\n    this.handle.truncate(newTotalSize);\n\n    // Write data back at new offset\n    const newBitmapOffset = this.bitmapOffset + growth;\n    const newDataOffset = this.dataOffset + growth;\n    this.handle.write(dataBuf, { at: newDataOffset });\n    this.handle.write(this.bitmap!, { at: newBitmapOffset });\n\n    // Update offsets\n    this.pathTableSize = newSize;\n    this.bitmapOffset = newBitmapOffset;\n    this.dataOffset = newDataOffset;\n\n    // Mark superblock dirty (will be written in commitPending)\n    this.superblockDirty = true;\n  }\n\n  // ========== Bitmap I/O ==========\n\n  private allocateBlocks(count: number): number {\n    if (count === 0) return 0;\n\n    const bitmap = this.bitmap!;\n    let run = 0;\n    let start = 0;\n\n    for (let i = 0; i < this.totalBlocks; i++) {\n      const byteIdx = i >>> 3;\n      const bitIdx = i & 7;\n      const used = (bitmap[byteIdx] >>> bitIdx) & 1;\n\n      if (used) {\n        run = 0;\n        start = i + 1;\n      } else {\n        run++;\n        if (run === count) {\n          // Mark blocks as used in memory\n          for (let j = start; j <= i; j++) {\n            const bj = j >>> 3;\n            const bi = j & 7;\n            bitmap[bj] |= (1 << bi);\n          }\n          this.markBitmapDirty(start >>> 3, i >>> 3);\n          this.freeBlocks -= count;\n          this.superblockDirty = true;\n          return start;\n        }\n      }\n    }\n\n    // No contiguous space  grow data region\n    return this.growAndAllocate(count);\n  }\n\n  private growAndAllocate(count: number): number {\n    const oldTotal = this.totalBlocks;\n    // Grow by at least doubling or enough for the request\n    const newTotal = Math.max(oldTotal * 2, oldTotal + count);\n    const addedBlocks = newTotal - oldTotal;\n\n    // Grow the file\n    const newFileSize = this.dataOffset + newTotal * this.blockSize;\n    this.handle.truncate(newFileSize);\n\n    // Grow in-memory bitmap\n    const newBitmapSize = Math.ceil(newTotal / 8);\n    const newBitmap = new Uint8Array(newBitmapSize);\n    newBitmap.set(this.bitmap!);\n    this.bitmap = newBitmap;\n\n    this.totalBlocks = newTotal;\n    this.freeBlocks += addedBlocks;\n\n    // Allocate from the newly freed area\n    const start = oldTotal;\n    for (let j = start; j < start + count; j++) {\n      const bj = j >>> 3;\n      const bi = j & 7;\n      this.bitmap[bj] |= (1 << bi);\n    }\n\n    this.markBitmapDirty(start >>> 3, (start + count - 1) >>> 3);\n    this.freeBlocks -= count;\n    this.superblockDirty = true;\n\n    return start;\n  }\n\n  private freeBlockRange(start: number, count: number): void {\n    if (count === 0) return;\n    const bitmap = this.bitmap!;\n\n    for (let i = start; i < start + count; i++) {\n      const byteIdx = i >>> 3;\n      const bitIdx = i & 7;\n      bitmap[byteIdx] &= ~(1 << bitIdx);\n    }\n\n    this.markBitmapDirty(start >>> 3, (start + count - 1) >>> 3);\n    this.freeBlocks += count;\n    this.superblockDirty = true;\n  }\n\n  // updateSuperblockFreeBlocks is no longer needed  superblock writes are coalesced via commitPending()\n\n  // ========== Inode allocation ==========\n\n  private findFreeInode(): number {\n    // Start from hint to skip already-used entries\n    for (let i = this.freeInodeHint; i < this.inodeCount; i++) {\n      // Check cache first  cached entries are never FREE\n      if (this.inodeCache.has(i)) continue;\n\n      const offset = this.inodeTableOffset + i * INODE_SIZE;\n      const typeBuf = new Uint8Array(1);\n      this.handle.read(typeBuf, { at: offset });\n      if (typeBuf[0] === INODE_TYPE.FREE) {\n        this.freeInodeHint = i + 1;\n        return i;\n      }\n    }\n    // All inodes used  grow inode table\n    const idx = this.growInodeTable();\n    this.freeInodeHint = idx + 1;\n    return idx;\n  }\n\n  private growInodeTable(): number {\n    const oldCount = this.inodeCount;\n    const newCount = oldCount * 2;\n    const growth = (newCount - oldCount) * INODE_SIZE;\n\n    // Read everything after inode table\n    const afterInodeOffset = this.inodeTableOffset + oldCount * INODE_SIZE;\n    const afterSize = this.handle.getSize() - afterInodeOffset;\n    const afterBuf = new Uint8Array(afterSize);\n    this.handle.read(afterBuf, { at: afterInodeOffset });\n\n    // Grow file\n    this.handle.truncate(this.handle.getSize() + growth);\n\n    // Write back shifted content\n    this.handle.write(afterBuf, { at: afterInodeOffset + growth });\n\n    // Zero out new inode entries\n    const zeroes = new Uint8Array(growth);\n    this.handle.write(zeroes, { at: afterInodeOffset });\n\n    // Update offsets\n    this.pathTableOffset += growth;\n    this.bitmapOffset += growth;\n    this.dataOffset += growth;\n    this.inodeCount = newCount;\n\n    this.superblockDirty = true;\n\n    return oldCount; // First new free inode\n  }\n\n  // ========== Data I/O ==========\n\n  private readData(firstBlock: number, blockCount: number, size: number): Uint8Array {\n    const buf = new Uint8Array(size);\n    const offset = this.dataOffset + firstBlock * this.blockSize;\n    this.handle.read(buf, { at: offset });\n    return buf;\n  }\n\n  private writeData(firstBlock: number, data: Uint8Array): void {\n    const offset = this.dataOffset + firstBlock * this.blockSize;\n    this.handle.write(data, { at: offset });\n  }\n\n  // ========== Path resolution ==========\n\n  private resolvePath(path: string, depth: number = 0): number | undefined {\n    if (depth > MAX_SYMLINK_DEPTH) return undefined; // ELOOP\n\n    const idx = this.pathIndex.get(path);\n    if (idx === undefined) {\n      // Path not found directly  try component resolution (handles intermediate symlinks)\n      return this.resolvePathComponents(path, true, depth);\n    }\n\n    const inode = this.readInode(idx);\n    if (inode.type === INODE_TYPE.SYMLINK) {\n      // Follow symlink\n      const target = decoder.decode(this.readData(inode.firstBlock, inode.blockCount, inode.size));\n      const resolved = target.startsWith('/') ? target : this.resolveRelative(path, target);\n      return this.resolvePath(resolved, depth + 1);\n    }\n\n    return idx;\n  }\n\n  /** Resolve symlinks in intermediate path components */\n  private resolvePathComponents(path: string, followLast: boolean = true, depth: number = 0): number | undefined {\n    if (depth > MAX_SYMLINK_DEPTH) return undefined; // ELOOP\n\n    const parts = path.split('/').filter(Boolean);\n    let current = '/';\n\n    for (let i = 0; i < parts.length; i++) {\n      const isLast = i === parts.length - 1;\n      current = current === '/' ? '/' + parts[i] : current + '/' + parts[i];\n\n      const idx = this.pathIndex.get(current);\n      if (idx === undefined) return undefined;\n\n      const inode = this.readInode(idx);\n      if (inode.type === INODE_TYPE.SYMLINK && (!isLast || followLast)) {\n        const target = decoder.decode(this.readData(inode.firstBlock, inode.blockCount, inode.size));\n        const resolved = target.startsWith('/') ? target : this.resolveRelative(current, target);\n\n        if (isLast) {\n          // Use resolvePathComponents (not resolvePath) so intermediate symlinks\n          // in the resolved target path are also followed\n          return this.resolvePathComponents(resolved, true, depth + 1);\n        }\n\n        // Reconstruct remaining path with resolved symlink\n        const remaining = parts.slice(i + 1).join('/');\n        const newPath = resolved + (remaining ? '/' + remaining : '');\n        return this.resolvePathComponents(newPath, followLast, depth + 1);\n      }\n    }\n\n    return this.pathIndex.get(current);\n  }\n\n  private resolveRelative(from: string, target: string): string {\n    const dir = from.substring(0, from.lastIndexOf('/')) || '/';\n    const parts = (dir + '/' + target).split('/').filter(Boolean);\n    const resolved: string[] = [];\n    for (const p of parts) {\n      if (p === '.') continue;\n      if (p === '..') { resolved.pop(); continue; }\n      resolved.push(p);\n    }\n    return '/' + resolved.join('/');\n  }\n\n  // ========== Core inode creation helper ==========\n\n  private createInode(path: string, type: number, mode: number, size: number, data?: Uint8Array): number {\n    const idx = this.findFreeInode();\n    const { offset: pathOff, length: pathLen } = this.appendPath(path);\n    const now = Date.now();\n\n    let firstBlock = 0;\n    let blockCount = 0;\n\n    if (data && data.byteLength > 0) {\n      blockCount = Math.ceil(data.byteLength / this.blockSize);\n      firstBlock = this.allocateBlocks(blockCount);\n      this.writeData(firstBlock, data);\n    }\n\n    const inode: Inode = {\n      type,\n      pathOffset: pathOff,\n      pathLength: pathLen,\n      mode,\n      size,\n      firstBlock,\n      blockCount,\n      mtime: now,\n      ctime: now,\n      atime: now,\n      uid: this.processUid,\n      gid: this.processGid,\n    };\n\n    this.writeInode(idx, inode);\n    this.pathIndex.set(path, idx);\n\n    return idx;\n  }\n\n  // ========== Public API  called by server worker dispatch ==========\n\n  /** Normalize a path: ensure leading /, resolve . and .. */\n  normalizePath(p: string): string {\n    if (p.charCodeAt(0) !== 47) p = '/' + p; // 47 = '/'\n    // Fast path: already normalized (no '.', '..', '//', trailing '/')\n    if (p.length === 1) return p; // \"/\"\n    if (p.indexOf('/.') === -1 && p.indexOf('//') === -1 && p.charCodeAt(p.length - 1) !== 47) {\n      return p;\n    }\n    // Slow path: full normalize\n    const parts = p.split('/').filter(Boolean);\n    const resolved: string[] = [];\n    for (const part of parts) {\n      if (part === '.') continue;\n      if (part === '..') { resolved.pop(); continue; }\n      resolved.push(part);\n    }\n    return '/' + resolved.join('/');\n  }\n\n  // ---- READ ----\n  read(path: string): { status: number; data: Uint8Array | null } {\n    const t0 = this.debug ? performance.now() : 0;\n    path = this.normalizePath(path);\n\n    // Fast path: direct index lookup (skips component-by-component walk)\n    let idx = this.pathIndex.get(path);\n    if (idx !== undefined) {\n      const inode = this.inodeCache.get(idx);\n      if (inode) {\n        // Symlink? Fall through to full resolve\n        if (inode.type === INODE_TYPE.SYMLINK) {\n          idx = this.resolvePathComponents(path, true);\n        } else if (inode.type === INODE_TYPE.DIRECTORY) {\n          return { status: CODE_TO_STATUS.EISDIR, data: null };\n        } else {\n          // Hot path: cached inode, no symlinks\n          const data = inode.size > 0\n            ? this.readData(inode.firstBlock, inode.blockCount, inode.size)\n            : new Uint8Array(0);\n          if (this.debug) {\n            const t1 = performance.now();\n            console.log(`[VFS read] path=${path} size=${inode.size} TOTAL=${(t1-t0).toFixed(3)}ms (fast)`);\n          }\n          return { status: 0, data };\n        }\n      }\n    }\n\n    // Slow path: full component resolution (handles symlinks, uncached inodes)\n    if (idx === undefined) idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT, data: null };\n\n    const inode = this.readInode(idx);\n    if (inode.type === INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.EISDIR, data: null };\n\n    const data = inode.size > 0\n      ? this.readData(inode.firstBlock, inode.blockCount, inode.size)\n      : new Uint8Array(0);\n\n    if (this.debug) {\n      const t1 = performance.now();\n      console.log(`[VFS read] path=${path} size=${inode.size} TOTAL=${(t1-t0).toFixed(3)}ms (slow path)`);\n    }\n\n    return { status: 0, data };\n  }\n\n  // ---- WRITE ----\n  write(path: string, data: Uint8Array, flags: number = 0): { status: number } {\n    const t0 = this.debug ? performance.now() : 0;\n    path = this.normalizePath(path);\n    const t1 = this.debug ? performance.now() : 0;\n\n    // Ensure parent directory exists\n    const parentStatus = this.ensureParent(path);\n    if (parentStatus !== 0) return { status: parentStatus };\n    const t2 = this.debug ? performance.now() : 0;\n\n    const existingIdx = this.resolvePathComponents(path, true);\n    const t3 = this.debug ? performance.now() : 0;\n\n    let tAlloc = t3, tData = t3, tInode = t3;\n\n    if (existingIdx !== undefined) {\n      // Update existing file\n      const inode = this.readInode(existingIdx);\n      if (inode.type === INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.EISDIR };\n\n      const neededBlocks = Math.ceil(data.byteLength / this.blockSize);\n\n      if (neededBlocks <= inode.blockCount) {\n        // Fits in current blocks\n        tAlloc = this.debug ? performance.now() : 0;\n        this.writeData(inode.firstBlock, data);\n        tData = this.debug ? performance.now() : 0;\n        if (neededBlocks < inode.blockCount) {\n          this.freeBlockRange(inode.firstBlock + neededBlocks, inode.blockCount - neededBlocks);\n        }\n      } else {\n        // Need more blocks  free old, allocate new\n        this.freeBlockRange(inode.firstBlock, inode.blockCount);\n        const newFirst = this.allocateBlocks(neededBlocks);\n        tAlloc = this.debug ? performance.now() : 0;\n        this.writeData(newFirst, data);\n        tData = this.debug ? performance.now() : 0;\n        inode.firstBlock = newFirst;\n      }\n\n      inode.size = data.byteLength;\n      inode.blockCount = neededBlocks;\n      inode.mtime = Date.now();\n      this.writeInode(existingIdx, inode);\n      tInode = this.debug ? performance.now() : 0;\n    } else {\n      // Create new file\n      const mode = DEFAULT_FILE_MODE & ~(this.umask & 0o777);\n      this.createInode(path, INODE_TYPE.FILE, mode, data.byteLength, data);\n      tAlloc = this.debug ? performance.now() : 0;\n      tData = tAlloc;\n      tInode = tAlloc;\n    }\n\n    if (flags & 1) {\n      this.commitPending();\n      this.handle.flush();\n    }\n    const tFlush = this.debug ? performance.now() : 0;\n\n    if (this.debug) {\n      const existing = existingIdx !== undefined;\n      console.log(`[VFS write] path=${path} size=${data.byteLength} ${existing ? 'UPDATE' : 'CREATE'} normalize=${(t1-t0).toFixed(3)}ms parent=${(t2-t1).toFixed(3)}ms resolve=${(t3-t2).toFixed(3)}ms alloc=${(tAlloc-t3).toFixed(3)}ms data=${(tData-tAlloc).toFixed(3)}ms inode=${(tInode-tData).toFixed(3)}ms flush=${(tFlush-tInode).toFixed(3)}ms TOTAL=${(tFlush-t0).toFixed(3)}ms`);\n    }\n\n    return { status: 0 };\n  }\n\n  // ---- APPEND ----\n  append(path: string, data: Uint8Array): { status: number } {\n    path = this.normalizePath(path);\n    const existingIdx = this.resolvePathComponents(path, true);\n\n    if (existingIdx === undefined) {\n      // Create new file with the data\n      return this.write(path, data);\n    }\n\n    const inode = this.readInode(existingIdx);\n    if (inode.type === INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.EISDIR };\n\n    // Read existing data\n    const existing = inode.size > 0\n      ? this.readData(inode.firstBlock, inode.blockCount, inode.size)\n      : new Uint8Array(0);\n\n    // Concat\n    const combined = new Uint8Array(existing.byteLength + data.byteLength);\n    combined.set(existing);\n    combined.set(data, existing.byteLength);\n\n    // Rewrite\n    const neededBlocks = Math.ceil(combined.byteLength / this.blockSize);\n    this.freeBlockRange(inode.firstBlock, inode.blockCount);\n    const newFirst = this.allocateBlocks(neededBlocks);\n    this.writeData(newFirst, combined);\n\n    inode.firstBlock = newFirst;\n    inode.blockCount = neededBlocks;\n    inode.size = combined.byteLength;\n    inode.mtime = Date.now();\n    this.writeInode(existingIdx, inode);\n\n    this.commitPending();\n    return { status: 0 };\n  }\n\n  // ---- UNLINK ----\n  unlink(path: string): { status: number } {\n    path = this.normalizePath(path);\n    const idx = this.pathIndex.get(path);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    const inode = this.readInode(idx);\n    if (inode.type === INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.EISDIR };\n\n    // Free data blocks\n    this.freeBlockRange(inode.firstBlock, inode.blockCount);\n\n    // Mark inode as free\n    inode.type = INODE_TYPE.FREE;\n    this.writeInode(idx, inode);\n\n    // Remove from index\n    this.pathIndex.delete(path);\n    // Reset free inode hint\n    if (idx < this.freeInodeHint) this.freeInodeHint = idx;\n\n    this.commitPending();\n    return { status: 0 };\n  }\n\n  // ---- STAT ----\n  stat(path: string): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT, data: null };\n\n    return this.encodeStatResponse(idx);\n  }\n\n  // ---- LSTAT (no symlink follow) ----\n  lstat(path: string): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n    const idx = this.pathIndex.get(path);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT, data: null };\n\n    return this.encodeStatResponse(idx);\n  }\n\n  private encodeStatResponse(idx: number): { status: number; data: Uint8Array } {\n    const inode = this.readInode(idx);\n    // Encode stat into binary: type(1) + mode(4) + size(8) + mtime(8) + ctime(8) + atime(8) + uid(4) + gid(4) + ino(4) = 49 bytes\n    const buf = new Uint8Array(49);\n    const view = new DataView(buf.buffer);\n    view.setUint8(0, inode.type);\n    view.setUint32(1, inode.mode, true);\n    view.setFloat64(5, inode.size, true);\n    view.setFloat64(13, inode.mtime, true);\n    view.setFloat64(21, inode.ctime, true);\n    view.setFloat64(29, inode.atime, true);\n    view.setUint32(37, inode.uid, true);\n    view.setUint32(41, inode.gid, true);\n    view.setUint32(45, idx, true); // ino = inode index\n\n    return { status: 0, data: buf };\n  }\n\n  // ---- MKDIR ----\n  mkdir(path: string, flags: number = 0): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n    const recursive = (flags & 1) !== 0;\n\n    if (recursive) {\n      return this.mkdirRecursive(path);\n    }\n\n    // Check if already exists\n    if (this.pathIndex.has(path)) return { status: CODE_TO_STATUS.EEXIST, data: null };\n\n    // Ensure parent exists\n    const parentStatus = this.ensureParent(path);\n    if (parentStatus !== 0) return { status: parentStatus, data: null };\n\n    const mode = DEFAULT_DIR_MODE & ~(this.umask & 0o777);\n    this.createInode(path, INODE_TYPE.DIRECTORY, mode, 0);\n\n    this.commitPending();\n    // Return created path as data\n    const pathBytes = encoder.encode(path);\n    return { status: 0, data: pathBytes };\n  }\n\n  private mkdirRecursive(path: string): { status: number; data: Uint8Array | null } {\n    const parts = path.split('/').filter(Boolean);\n    let current = '';\n    let firstCreated: string | null = null;\n\n    for (const part of parts) {\n      current += '/' + part;\n\n      if (this.pathIndex.has(current)) {\n        const idx = this.pathIndex.get(current)!;\n        const inode = this.readInode(idx);\n        if (inode.type !== INODE_TYPE.DIRECTORY) {\n          return { status: CODE_TO_STATUS.ENOTDIR, data: null };\n        }\n        continue;\n      }\n\n      const mode = DEFAULT_DIR_MODE & ~(this.umask & 0o777);\n      this.createInode(current, INODE_TYPE.DIRECTORY, mode, 0);\n      if (!firstCreated) firstCreated = current;\n    }\n\n    this.commitPending();\n    const result = firstCreated ? encoder.encode(firstCreated) : undefined;\n    return { status: 0, data: result ?? null };\n  }\n\n  // ---- RMDIR ----\n  rmdir(path: string, flags: number = 0): { status: number } {\n    path = this.normalizePath(path);\n    const recursive = (flags & 1) !== 0;\n    const idx = this.pathIndex.get(path);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    const inode = this.readInode(idx);\n    if (inode.type !== INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.ENOTDIR };\n\n    // Check for children\n    const children = this.getDirectChildren(path);\n\n    if (children.length > 0) {\n      if (!recursive) return { status: CODE_TO_STATUS.ENOTEMPTY };\n\n      // Recursive delete\n      for (const child of this.getAllDescendants(path)) {\n        const childIdx = this.pathIndex.get(child)!;\n        const childInode = this.readInode(childIdx);\n        this.freeBlockRange(childInode.firstBlock, childInode.blockCount);\n        childInode.type = INODE_TYPE.FREE;\n        this.writeInode(childIdx, childInode);\n        this.pathIndex.delete(child);\n      }\n    }\n\n    // Remove the directory itself\n    inode.type = INODE_TYPE.FREE;\n    this.writeInode(idx, inode);\n    this.pathIndex.delete(path);\n    if (idx < this.freeInodeHint) this.freeInodeHint = idx;\n\n    this.commitPending();\n    return { status: 0 };\n  }\n\n  // ---- READDIR ----\n  readdir(path: string, flags: number = 0): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT, data: null };\n\n    const inode = this.readInode(idx);\n    if (inode.type !== INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.ENOTDIR, data: null };\n\n    const withFileTypes = (flags & 1) !== 0;\n    const children = this.getDirectChildren(path);\n\n    if (withFileTypes) {\n      // Encode as: count(u32) + entries[name_len(u16) + name(bytes) + type(u8)]\n      let totalSize = 4;\n      const entries: { name: Uint8Array; type: number }[] = [];\n\n      for (const childPath of children) {\n        const name = childPath.substring(childPath.lastIndexOf('/') + 1);\n        const nameBytes = encoder.encode(name);\n        const childIdx = this.pathIndex.get(childPath)!;\n        const childInode = this.readInode(childIdx);\n        entries.push({ name: nameBytes, type: childInode.type });\n        totalSize += 2 + nameBytes.byteLength + 1; // nameLen + name + type\n      }\n\n      const buf = new Uint8Array(totalSize);\n      const view = new DataView(buf.buffer);\n      view.setUint32(0, entries.length, true);\n      let offset = 4;\n\n      for (const entry of entries) {\n        view.setUint16(offset, entry.name.byteLength, true);\n        offset += 2;\n        buf.set(entry.name, offset);\n        offset += entry.name.byteLength;\n        buf[offset++] = entry.type;\n      }\n\n      return { status: 0, data: buf };\n    }\n\n    // Simple name list: count(u32) + entries[name_len(u16) + name(bytes)]\n    let totalSize = 4;\n    const nameEntries: Uint8Array[] = [];\n\n    for (const childPath of children) {\n      const name = childPath.substring(childPath.lastIndexOf('/') + 1);\n      const nameBytes = encoder.encode(name);\n      nameEntries.push(nameBytes);\n      totalSize += 2 + nameBytes.byteLength;\n    }\n\n    const buf = new Uint8Array(totalSize);\n    const view = new DataView(buf.buffer);\n    view.setUint32(0, nameEntries.length, true);\n    let offset = 4;\n\n    for (const nameBytes of nameEntries) {\n      view.setUint16(offset, nameBytes.byteLength, true);\n      offset += 2;\n      buf.set(nameBytes, offset);\n      offset += nameBytes.byteLength;\n    }\n\n    return { status: 0, data: buf };\n  }\n\n  // ---- RENAME ----\n  rename(oldPath: string, newPath: string): { status: number } {\n    oldPath = this.normalizePath(oldPath);\n    newPath = this.normalizePath(newPath);\n\n    const idx = this.pathIndex.get(oldPath);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    // Ensure parent of new path exists\n    const parentStatus = this.ensureParent(newPath);\n    if (parentStatus !== 0) return { status: parentStatus };\n\n    // If target exists, remove it\n    const existingIdx = this.pathIndex.get(newPath);\n    if (existingIdx !== undefined) {\n      const existingInode = this.readInode(existingIdx);\n      this.freeBlockRange(existingInode.firstBlock, existingInode.blockCount);\n      existingInode.type = INODE_TYPE.FREE;\n      this.writeInode(existingIdx, existingInode);\n      this.pathIndex.delete(newPath);\n    }\n\n    // Update inode with new path\n    const inode = this.readInode(idx);\n    const { offset: pathOff, length: pathLen } = this.appendPath(newPath);\n    inode.pathOffset = pathOff;\n    inode.pathLength = pathLen;\n    inode.mtime = Date.now();\n    this.writeInode(idx, inode);\n\n    // Update index\n    this.pathIndex.delete(oldPath);\n    this.pathIndex.set(newPath, idx);\n\n    // If it's a directory, rename all descendants\n    if (inode.type === INODE_TYPE.DIRECTORY) {\n      const prefix = oldPath === '/' ? '/' : oldPath + '/';\n      const toRename: [string, number][] = [];\n\n      for (const [p, i] of this.pathIndex) {\n        if (p.startsWith(prefix)) {\n          toRename.push([p, i]);\n        }\n      }\n\n      for (const [p, i] of toRename) {\n        const suffix = p.substring(oldPath.length);\n        const childNewPath = newPath + suffix;\n        const childInode = this.readInode(i);\n        const { offset: cpo, length: cpl } = this.appendPath(childNewPath);\n        childInode.pathOffset = cpo;\n        childInode.pathLength = cpl;\n        this.writeInode(i, childInode);\n        this.pathIndex.delete(p);\n        this.pathIndex.set(childNewPath, i);\n      }\n    }\n\n    this.commitPending();\n    return { status: 0 };\n  }\n\n  // ---- EXISTS ----\n  exists(path: string): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    const buf = new Uint8Array(1);\n    buf[0] = idx !== undefined ? 1 : 0;\n    return { status: 0, data: buf };\n  }\n\n  // ---- TRUNCATE ----\n  truncate(path: string, len: number = 0): { status: number } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    const inode = this.readInode(idx);\n    if (inode.type === INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.EISDIR };\n\n    if (len === 0) {\n      // Free all blocks\n      this.freeBlockRange(inode.firstBlock, inode.blockCount);\n      inode.firstBlock = 0;\n      inode.blockCount = 0;\n      inode.size = 0;\n    } else if (len < inode.size) {\n      // Shrink\n      const neededBlocks = Math.ceil(len / this.blockSize);\n      if (neededBlocks < inode.blockCount) {\n        this.freeBlockRange(inode.firstBlock + neededBlocks, inode.blockCount - neededBlocks);\n      }\n      inode.blockCount = neededBlocks;\n      inode.size = len;\n    } else if (len > inode.size) {\n      // Grow (zero-fill)\n      const neededBlocks = Math.ceil(len / this.blockSize);\n      if (neededBlocks > inode.blockCount) {\n        // Need more blocks\n        const oldData = this.readData(inode.firstBlock, inode.blockCount, inode.size);\n        this.freeBlockRange(inode.firstBlock, inode.blockCount);\n        const newFirst = this.allocateBlocks(neededBlocks);\n        const newData = new Uint8Array(len);\n        newData.set(oldData);\n        // Rest is already zero-filled\n        this.writeData(newFirst, newData);\n        inode.firstBlock = newFirst;\n      }\n      inode.blockCount = neededBlocks;\n      inode.size = len;\n    }\n\n    inode.mtime = Date.now();\n    this.writeInode(idx, inode);\n\n    this.commitPending();\n    return { status: 0 };\n  }\n\n  // ---- COPY ----\n  copy(srcPath: string, destPath: string, flags: number = 0): { status: number } {\n    srcPath = this.normalizePath(srcPath);\n    destPath = this.normalizePath(destPath);\n\n    const srcIdx = this.resolvePathComponents(srcPath, true);\n    if (srcIdx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    const srcInode = this.readInode(srcIdx);\n    if (srcInode.type === INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.EISDIR };\n\n    // COPYFILE_EXCL check\n    if ((flags & 1) && this.pathIndex.has(destPath)) {\n      return { status: CODE_TO_STATUS.EEXIST };\n    }\n\n    // Read source data\n    const data = srcInode.size > 0\n      ? this.readData(srcInode.firstBlock, srcInode.blockCount, srcInode.size)\n      : new Uint8Array(0);\n\n    return this.write(destPath, data);\n  }\n\n  // ---- ACCESS ----\n  access(path: string, mode: number = 0): { status: number } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    if (mode === 0) return { status: 0 }; // F_OK  just check existence\n\n    if (!this.strictPermissions) return { status: 0 }; // Relaxed mode\n\n    const inode = this.readInode(idx);\n    // Check permission bits against process identity\n    const filePerm = this.getEffectivePermission(inode);\n\n    if ((mode & 4) && !(filePerm & 4)) return { status: CODE_TO_STATUS.EACCES }; // R_OK\n    if ((mode & 2) && !(filePerm & 2)) return { status: CODE_TO_STATUS.EACCES }; // W_OK\n    if ((mode & 1) && !(filePerm & 1)) return { status: CODE_TO_STATUS.EACCES }; // X_OK\n\n    return { status: 0 };\n  }\n\n  private getEffectivePermission(inode: Inode): number {\n    const modeBits = inode.mode & 0o777;\n    if (this.processUid === inode.uid) return (modeBits >>> 6) & 7;\n    if (this.processGid === inode.gid) return (modeBits >>> 3) & 7;\n    return modeBits & 7;\n  }\n\n  // ---- REALPATH ----\n  realpath(path: string): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT, data: null };\n\n    // Find the resolved path for this inode\n    const inode = this.readInode(idx);\n    const resolvedPath = this.readPath(inode.pathOffset, inode.pathLength);\n    return { status: 0, data: encoder.encode(resolvedPath) };\n  }\n\n  // ---- CHMOD ----\n  chmod(path: string, mode: number): { status: number } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    const inode = this.readInode(idx);\n    // Preserve file type bits, update permission bits\n    inode.mode = (inode.mode & S_IFMT) | (mode & 0o7777);\n    inode.ctime = Date.now();\n    this.writeInode(idx, inode);\n\n    return { status: 0 };\n  }\n\n  // ---- CHOWN ----\n  chown(path: string, uid: number, gid: number): { status: number } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    const inode = this.readInode(idx);\n    inode.uid = uid;\n    inode.gid = gid;\n    inode.ctime = Date.now();\n    this.writeInode(idx, inode);\n\n    return { status: 0 };\n  }\n\n  // ---- UTIMES ----\n  utimes(path: string, atime: number, mtime: number): { status: number } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT };\n\n    const inode = this.readInode(idx);\n    inode.atime = atime;\n    inode.mtime = mtime;\n    inode.ctime = Date.now();\n    this.writeInode(idx, inode);\n\n    return { status: 0 };\n  }\n\n  // ---- SYMLINK ----\n  symlink(target: string, linkPath: string): { status: number } {\n    linkPath = this.normalizePath(linkPath);\n    if (this.pathIndex.has(linkPath)) return { status: CODE_TO_STATUS.EEXIST };\n\n    const parentStatus = this.ensureParent(linkPath);\n    if (parentStatus !== 0) return { status: parentStatus };\n\n    const targetBytes = encoder.encode(target);\n    this.createInode(linkPath, INODE_TYPE.SYMLINK, DEFAULT_SYMLINK_MODE, targetBytes.byteLength, targetBytes);\n\n    this.commitPending();\n    return { status: 0 };\n  }\n\n  // ---- READLINK ----\n  readlink(path: string): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n    const idx = this.pathIndex.get(path);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT, data: null };\n\n    const inode = this.readInode(idx);\n    if (inode.type !== INODE_TYPE.SYMLINK) return { status: CODE_TO_STATUS.EINVAL, data: null };\n\n    const target = this.readData(inode.firstBlock, inode.blockCount, inode.size);\n    return { status: 0, data: target };\n  }\n\n  // ---- LINK (hard link  copies the file) ----\n  link(existingPath: string, newPath: string): { status: number } {\n    return this.copy(existingPath, newPath);\n  }\n\n  // ---- OPEN (file descriptor) ----\n  open(path: string, flags: number, tabId: string): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n\n    const hasCreate = (flags & 64) !== 0;  // O_CREAT\n    const hasTrunc = (flags & 512) !== 0;   // O_TRUNC\n    const hasExcl = (flags & 128) !== 0;    // O_EXCL\n\n    let idx = this.resolvePathComponents(path, true);\n\n    if (idx === undefined) {\n      if (!hasCreate) return { status: CODE_TO_STATUS.ENOENT, data: null };\n      // Create file\n      const mode = DEFAULT_FILE_MODE & ~(this.umask & 0o777);\n      idx = this.createInode(path, INODE_TYPE.FILE, mode, 0);\n    } else if (hasExcl && hasCreate) {\n      return { status: CODE_TO_STATUS.EEXIST, data: null };\n    }\n\n    if (hasTrunc) {\n      this.truncate(path, 0);\n    }\n\n    const fd = this.nextFd++;\n    this.fdTable.set(fd, { tabId, inodeIdx: idx, position: 0, flags });\n\n    const buf = new Uint8Array(4);\n    new DataView(buf.buffer).setUint32(0, fd, true);\n    return { status: 0, data: buf };\n  }\n\n  // ---- CLOSE ----\n  close(fd: number): { status: number } {\n    if (!this.fdTable.has(fd)) return { status: CODE_TO_STATUS.EBADF };\n    this.fdTable.delete(fd);\n    return { status: 0 };\n  }\n\n  // ---- FREAD ----\n  fread(fd: number, length: number, position: number | null): { status: number; data: Uint8Array | null } {\n    const entry = this.fdTable.get(fd);\n    if (!entry) return { status: CODE_TO_STATUS.EBADF, data: null };\n\n    const inode = this.readInode(entry.inodeIdx);\n    const pos = position ?? entry.position;\n    const readLen = Math.min(length, inode.size - pos);\n\n    if (readLen <= 0) return { status: 0, data: new Uint8Array(0) };\n\n    // Read from specific offset within the file's data blocks\n    const dataOffset = this.dataOffset + inode.firstBlock * this.blockSize + pos;\n    const buf = new Uint8Array(readLen);\n    this.handle.read(buf, { at: dataOffset });\n\n    // Update position\n    if (position === null) {\n      entry.position += readLen;\n    }\n\n    return { status: 0, data: buf };\n  }\n\n  // ---- FWRITE ----\n  fwrite(fd: number, data: Uint8Array, position: number | null): { status: number; data: Uint8Array | null } {\n    const entry = this.fdTable.get(fd);\n    if (!entry) return { status: CODE_TO_STATUS.EBADF, data: null };\n\n    const inode = this.readInode(entry.inodeIdx);\n    const isAppend = (entry.flags & 1024) !== 0; // O_APPEND\n    const pos = isAppend ? inode.size : (position ?? entry.position);\n    const endPos = pos + data.byteLength;\n\n    // Check if we need to grow\n    if (endPos > inode.size) {\n      const neededBlocks = Math.ceil(endPos / this.blockSize);\n      if (neededBlocks > inode.blockCount) {\n        // Grow  read old data, reallocate, write back\n        const oldData = inode.size > 0\n          ? this.readData(inode.firstBlock, inode.blockCount, inode.size)\n          : new Uint8Array(0);\n        this.freeBlockRange(inode.firstBlock, inode.blockCount);\n        const newFirst = this.allocateBlocks(neededBlocks);\n        const newBuf = new Uint8Array(endPos);\n        newBuf.set(oldData);\n        newBuf.set(data, pos);\n        this.writeData(newFirst, newBuf);\n        inode.firstBlock = newFirst;\n        inode.blockCount = neededBlocks;\n      } else {\n        // Fits, write at position\n        const dataOffset = this.dataOffset + inode.firstBlock * this.blockSize + pos;\n        this.handle.write(data, { at: dataOffset });\n      }\n      inode.size = endPos;\n    } else {\n      // Write within existing bounds\n      const dataOffset = this.dataOffset + inode.firstBlock * this.blockSize + pos;\n      this.handle.write(data, { at: dataOffset });\n    }\n\n    inode.mtime = Date.now();\n    this.writeInode(entry.inodeIdx, inode);\n\n    // Update position\n    if (position === null) {\n      entry.position = endPos;\n    }\n\n    this.commitPending();\n    const buf = new Uint8Array(4);\n    new DataView(buf.buffer).setUint32(0, data.byteLength, true);\n    return { status: 0, data: buf };\n  }\n\n  // ---- FSTAT ----\n  fstat(fd: number): { status: number; data: Uint8Array | null } {\n    const entry = this.fdTable.get(fd);\n    if (!entry) return { status: CODE_TO_STATUS.EBADF, data: null };\n    return this.encodeStatResponse(entry.inodeIdx);\n  }\n\n  // ---- FTRUNCATE ----\n  ftruncate(fd: number, len: number = 0): { status: number } {\n    const entry = this.fdTable.get(fd);\n    if (!entry) return { status: CODE_TO_STATUS.EBADF };\n\n    const inode = this.readInode(entry.inodeIdx);\n    const path = this.readPath(inode.pathOffset, inode.pathLength);\n    return this.truncate(path, len);\n  }\n\n  // ---- FSYNC ----\n  fsync(): { status: number } {\n    this.commitPending();\n    this.handle.flush();\n    return { status: 0 };\n  }\n\n  // ---- OPENDIR ----\n  opendir(path: string, tabId: string): { status: number; data: Uint8Array | null } {\n    path = this.normalizePath(path);\n    const idx = this.resolvePathComponents(path, true);\n    if (idx === undefined) return { status: CODE_TO_STATUS.ENOENT, data: null };\n\n    const inode = this.readInode(idx);\n    if (inode.type !== INODE_TYPE.DIRECTORY) return { status: CODE_TO_STATUS.ENOTDIR, data: null };\n\n    // Use fd table for dir handles too\n    const fd = this.nextFd++;\n    this.fdTable.set(fd, { tabId, inodeIdx: idx, position: 0, flags: 0 });\n\n    const buf = new Uint8Array(4);\n    new DataView(buf.buffer).setUint32(0, fd, true);\n    return { status: 0, data: buf };\n  }\n\n  // ---- MKDTEMP ----\n  mkdtemp(prefix: string): { status: number; data: Uint8Array | null } {\n    const suffix = Math.random().toString(36).substring(2, 8);\n    const path = this.normalizePath(prefix + suffix);\n\n    // Ensure parent directories exist\n    const parentStatus = this.ensureParent(path);\n    if (parentStatus !== 0) {\n      // Auto-create parent directories for mkdtemp\n      const parentPath = path.substring(0, path.lastIndexOf('/'));\n      if (parentPath) {\n        this.mkdirRecursive(parentPath);\n      }\n    }\n\n    const mode = DEFAULT_DIR_MODE & ~(this.umask & 0o777);\n    this.createInode(path, INODE_TYPE.DIRECTORY, mode, 0);\n\n    this.commitPending();\n    return { status: 0, data: encoder.encode(path) };\n  }\n\n  // ========== Helpers ==========\n\n  private getDirectChildren(dirPath: string): string[] {\n    const prefix = dirPath === '/' ? '/' : dirPath + '/';\n    const children: string[] = [];\n\n    for (const path of this.pathIndex.keys()) {\n      if (path === dirPath) continue;\n      if (!path.startsWith(prefix)) continue;\n      // Direct child: no more slashes after prefix\n      const rest = path.substring(prefix.length);\n      if (!rest.includes('/')) {\n        children.push(path);\n      }\n    }\n\n    return children.sort();\n  }\n\n  private getAllDescendants(dirPath: string): string[] {\n    const prefix = dirPath === '/' ? '/' : dirPath + '/';\n    const descendants: string[] = [];\n\n    for (const path of this.pathIndex.keys()) {\n      if (path.startsWith(prefix)) descendants.push(path);\n    }\n\n    // Sort by depth (deepest first) for safe deletion\n    return descendants.sort((a, b) => {\n      const da = a.split('/').length;\n      const db = b.split('/').length;\n      return db - da;\n    });\n  }\n\n  private ensureParent(path: string): number {\n    const lastSlash = path.lastIndexOf('/');\n    if (lastSlash <= 0) return 0; // Parent is root, always exists\n\n    const parentPath = path.substring(0, lastSlash);\n    const parentIdx = this.pathIndex.get(parentPath);\n    if (parentIdx === undefined) return CODE_TO_STATUS.ENOENT;\n\n    const parentInode = this.readInode(parentIdx);\n    if (parentInode.type !== INODE_TYPE.DIRECTORY) return CODE_TO_STATUS.ENOTDIR;\n\n    return 0;\n  }\n\n  /** Clean up all fds owned by a tab */\n  cleanupTab(tabId: string): void {\n    for (const [fd, entry] of this.fdTable) {\n      if (entry.tabId === tabId) {\n        this.fdTable.delete(fd);\n      }\n    }\n  }\n\n  /** Get all file paths and their data for OPFS sync */\n  getAllFiles(): { path: string; idx: number }[] {\n    const files: { path: string; idx: number }[] = [];\n    for (const [path, idx] of this.pathIndex) {\n      files.push({ path, idx });\n    }\n    return files;\n  }\n\n  /** Get file path for a file descriptor (used by OPFS sync for FD-based ops) */\n  getPathForFd(fd: number): string | null {\n    const entry = this.fdTable.get(fd);\n    if (!entry) return null;\n    const inode = this.readInode(entry.inodeIdx);\n    return this.readPath(inode.pathOffset, inode.pathLength);\n  }\n\n  /** Get file data by inode index */\n  getInodeData(idx: number): { type: number; data: Uint8Array; mtime: number } {\n    const inode = this.readInode(idx);\n    const data = inode.size > 0\n      ? this.readData(inode.firstBlock, inode.blockCount, inode.size)\n      : new Uint8Array(0);\n    return { type: inode.type, data, mtime: inode.mtime };\n  }\n\n  /** Export all files/dirs/symlinks from the VFS */\n  exportAll(): Array<{ path: string; type: number; data: Uint8Array | null; mode: number; mtime: number }> {\n    const result: Array<{ path: string; type: number; data: Uint8Array | null; mode: number; mtime: number }> = [];\n    for (const [path, idx] of this.pathIndex) {\n      const inode = this.readInode(idx);\n      let data: Uint8Array | null = null;\n      if (inode.type === INODE_TYPE.FILE || inode.type === INODE_TYPE.SYMLINK) {\n        data = inode.size > 0\n          ? this.readData(inode.firstBlock, inode.blockCount, inode.size)\n          : new Uint8Array(0);\n      }\n      result.push({ path, type: inode.type, data, mode: inode.mode, mtime: inode.mtime });\n    }\n    // Sort directories first so parents are created before children\n    result.sort((a, b) => {\n      if (a.type === INODE_TYPE.DIRECTORY && b.type !== INODE_TYPE.DIRECTORY) return -1;\n      if (a.type !== INODE_TYPE.DIRECTORY && b.type === INODE_TYPE.DIRECTORY) return 1;\n      return a.path.localeCompare(b.path);\n    });\n    return result;\n  }\n\n  flush(): void {\n    this.handle.flush();\n  }\n}\n","/**\n * VFS Helper Functions\n *\n * Standalone utilities for VFS maintenance:\n * - unpackToOPFS: Export VFS contents to real OPFS files\n * - loadFromOPFS: Rebuild VFS from real OPFS files\n * - repairVFS: Attempt to recover files from a corrupt VFS binary\n *\n * These functions acquire an exclusive sync access handle on .vfs.bin,\n * so any running VFSFileSystem instance must be closed first.\n * Must be called from a Worker context (createSyncAccessHandle requirement).\n */\n\nimport { VFSEngine } from './vfs/engine.js';\nimport {\n  VFS_MAGIC, VFS_VERSION, SUPERBLOCK, INODE, INODE_SIZE, INODE_TYPE,\n  DEFAULT_INODE_COUNT, DEFAULT_BLOCK_SIZE, INITIAL_DATA_BLOCKS,\n  INITIAL_PATH_TABLE_SIZE, calculateLayout,\n} from './vfs/layout.js';\n\n// ========== OPFS Navigation Helpers ==========\n\nasync function navigateToRoot(root: string): Promise<FileSystemDirectoryHandle> {\n  let dir = await navigator.storage.getDirectory();\n  if (root && root !== '/') {\n    for (const seg of root.split('/').filter(Boolean)) {\n      dir = await dir.getDirectoryHandle(seg, { create: true });\n    }\n  }\n  return dir;\n}\n\nasync function ensureParentDirs(rootDir: FileSystemDirectoryHandle, path: string): Promise<FileSystemDirectoryHandle> {\n  const parts = path.split('/').filter(Boolean);\n  parts.pop(); // Remove filename\n  let dir = rootDir;\n  for (const part of parts) {\n    dir = await dir.getDirectoryHandle(part, { create: true });\n  }\n  return dir;\n}\n\nfunction basename(path: string): string {\n  const parts = path.split('/').filter(Boolean);\n  return parts[parts.length - 1] || '';\n}\n\nasync function writeOPFSFile(rootDir: FileSystemDirectoryHandle, path: string, data: Uint8Array): Promise<void> {\n  const parentDir = await ensureParentDirs(rootDir, path);\n  const name = basename(path);\n  const fileHandle = await parentDir.getFileHandle(name, { create: true });\n  const syncHandle = await fileHandle.createSyncAccessHandle();\n  try {\n    syncHandle.truncate(0);\n    if (data.byteLength > 0) {\n      syncHandle.write(data, { at: 0 });\n    }\n    syncHandle.flush();\n  } finally {\n    syncHandle.close();\n  }\n}\n\nasync function clearDirectory(dir: FileSystemDirectoryHandle, skip: Set<string>): Promise<void> {\n  const entries: string[] = [];\n  for await (const name of (dir as any).keys()) {\n    if (!skip.has(name)) entries.push(name);\n  }\n  for (const name of entries) {\n    await dir.removeEntry(name, { recursive: true });\n  }\n}\n\ninterface RecursiveEntry {\n  path: string;\n  type: 'file' | 'directory';\n  data?: ArrayBuffer;\n}\n\nasync function readOPFSRecursive(\n  dir: FileSystemDirectoryHandle,\n  prefix: string,\n  skip: Set<string>,\n): Promise<RecursiveEntry[]> {\n  const result: RecursiveEntry[] = [];\n  for await (const [name, handle] of (dir as any).entries()) {\n    if (prefix === '' && skip.has(name)) continue;\n    const fullPath = prefix ? `${prefix}/${name}` : `/${name}`;\n    if (handle.kind === 'directory') {\n      result.push({ path: fullPath, type: 'directory' });\n      const children = await readOPFSRecursive(handle as FileSystemDirectoryHandle, fullPath, skip);\n      result.push(...children);\n    } else {\n      const file = await (handle as FileSystemFileHandle).getFile();\n      const data = await file.arrayBuffer();\n      result.push({ path: fullPath, type: 'file', data });\n    }\n  }\n  return result;\n}\n\n// ========== Public Helper Functions ==========\n\nexport interface UnpackResult {\n  files: number;\n  directories: number;\n}\n\n/**\n * Unpack VFS contents to real OPFS files.\n *\n * Reads all files/directories from the VFS binary and writes them as real\n * OPFS files. Clears existing OPFS files (except .vfs.bin) first.\n *\n * Must be called from a Worker. Close any running VFSFileSystem first.\n */\nexport async function unpackToOPFS(root: string = '/'): Promise<UnpackResult> {\n  const rootDir = await navigateToRoot(root);\n\n  // Open VFS binary\n  const vfsFileHandle = await rootDir.getFileHandle('.vfs.bin');\n  const handle = await vfsFileHandle.createSyncAccessHandle();\n\n  let entries: Array<{ path: string; type: number; data: Uint8Array | null; mode: number; mtime: number }>;\n  try {\n    const engine = new VFSEngine();\n    engine.init(handle);\n    entries = engine.exportAll();\n  } finally {\n    handle.close();\n  }\n\n  // Clear OPFS (except .vfs.bin)\n  await clearDirectory(rootDir, new Set(['.vfs.bin']));\n\n  // Write all entries\n  let files = 0;\n  let directories = 0;\n  for (const entry of entries) {\n    if (entry.path === '/') continue; // Skip root\n    if (entry.type === INODE_TYPE.DIRECTORY) {\n      await ensureParentDirs(rootDir, entry.path + '/dummy');\n      const name = basename(entry.path);\n      const parent = await ensureParentDirs(rootDir, entry.path);\n      await parent.getDirectoryHandle(name, { create: true });\n      directories++;\n    } else if (entry.type === INODE_TYPE.FILE) {\n      await writeOPFSFile(rootDir, entry.path, entry.data ?? new Uint8Array(0));\n      files++;\n    } else if (entry.type === INODE_TYPE.SYMLINK) {\n      // OPFS has no symlink concept  write target content as regular file\n      await writeOPFSFile(rootDir, entry.path, entry.data ?? new Uint8Array(0));\n      files++;\n    }\n  }\n\n  return { files, directories };\n}\n\nexport interface LoadResult {\n  files: number;\n  directories: number;\n}\n\n/**\n * Load all real OPFS files into a fresh VFS.\n *\n * Reads all OPFS files/directories recursively, deletes the existing .vfs.bin,\n * creates a fresh VFS, and writes all OPFS content into it.\n *\n * Must be called from a Worker. Close any running VFSFileSystem first.\n */\nexport async function loadFromOPFS(root: string = '/'): Promise<LoadResult> {\n  const rootDir = await navigateToRoot(root);\n\n  // Read all OPFS entries (skip .vfs.bin)\n  const opfsEntries = await readOPFSRecursive(rootDir, '', new Set(['.vfs.bin']));\n\n  // Delete old VFS binary\n  try {\n    await rootDir.removeEntry('.vfs.bin');\n  } catch (_) {\n    // May not exist\n  }\n\n  // Create fresh VFS\n  const vfsFileHandle = await rootDir.getFileHandle('.vfs.bin', { create: true });\n  const handle = await vfsFileHandle.createSyncAccessHandle();\n\n  try {\n    const engine = new VFSEngine();\n    engine.init(handle); // size=0  formats fresh VFS\n\n    // Write directories first (sorted by depth)\n    const dirs = opfsEntries\n      .filter(e => e.type === 'directory')\n      .sort((a, b) => a.path.localeCompare(b.path));\n\n    let files = 0;\n    let directories = 0;\n\n    for (const dir of dirs) {\n      engine.mkdir(dir.path, 0o040755);\n      directories++;\n    }\n\n    // Write files\n    const fileEntries = opfsEntries.filter(e => e.type === 'file');\n    for (const file of fileEntries) {\n      engine.write(file.path, new Uint8Array(file.data!));\n      files++;\n    }\n\n    engine.flush();\n    return { files, directories };\n  } finally {\n    handle.close();\n  }\n}\n\nexport interface RepairResult {\n  recovered: number;\n  lost: number;\n  entries: Array<{ path: string; type: 'file' | 'directory' | 'symlink'; size: number }>;\n}\n\n/**\n * Attempt to recover files from a corrupt VFS binary.\n *\n * Reads the raw .vfs.bin binary, scans the inode table for valid-looking\n * entries, extracts recoverable files, then creates a fresh VFS with the\n * recovered data.\n *\n * Must be called from a Worker. Close any running VFSFileSystem first.\n */\nexport async function repairVFS(root: string = '/'): Promise<RepairResult> {\n  const rootDir = await navigateToRoot(root);\n\n  // Read corrupt VFS into memory\n  const vfsFileHandle = await rootDir.getFileHandle('.vfs.bin');\n  const file = await vfsFileHandle.getFile();\n  const raw = new Uint8Array(await file.arrayBuffer());\n  const fileSize = raw.byteLength;\n\n  if (fileSize < SUPERBLOCK.SIZE) {\n    throw new Error(`VFS file too small to repair (${fileSize} bytes)`);\n  }\n\n  const view = new DataView(raw.buffer);\n\n  // Try to determine layout from superblock, fall back to defaults\n  let inodeCount: number;\n  let blockSize: number;\n  let totalBlocks: number;\n  let inodeTableOffset: number;\n  let pathTableOffset: number;\n  let bitmapOffset: number;\n  let dataOffset: number;\n  let pathTableUsed: number;\n\n  const magic = view.getUint32(SUPERBLOCK.MAGIC, true);\n  const version = view.getUint32(SUPERBLOCK.VERSION, true);\n  const superblockValid = magic === VFS_MAGIC && version === VFS_VERSION;\n\n  if (superblockValid) {\n    // Superblock looks valid  use its values with sanity checks\n    inodeCount = view.getUint32(SUPERBLOCK.INODE_COUNT, true);\n    blockSize = view.getUint32(SUPERBLOCK.BLOCK_SIZE, true);\n    totalBlocks = view.getUint32(SUPERBLOCK.TOTAL_BLOCKS, true);\n    inodeTableOffset = view.getFloat64(SUPERBLOCK.INODE_OFFSET, true);\n    pathTableOffset = view.getFloat64(SUPERBLOCK.PATH_OFFSET, true);\n    bitmapOffset = view.getFloat64(SUPERBLOCK.BITMAP_OFFSET, true);\n    dataOffset = view.getFloat64(SUPERBLOCK.DATA_OFFSET, true);\n    pathTableUsed = view.getUint32(SUPERBLOCK.PATH_USED, true);\n\n    // Sanity check  if values are unreasonable, fall back to defaults\n    if (blockSize === 0 || (blockSize & (blockSize - 1)) !== 0 || inodeCount === 0 ||\n        inodeTableOffset >= fileSize || pathTableOffset >= fileSize || dataOffset >= fileSize) {\n      const layout = calculateLayout(DEFAULT_INODE_COUNT, DEFAULT_BLOCK_SIZE, INITIAL_DATA_BLOCKS);\n      inodeCount = DEFAULT_INODE_COUNT;\n      blockSize = DEFAULT_BLOCK_SIZE;\n      totalBlocks = INITIAL_DATA_BLOCKS;\n      inodeTableOffset = layout.inodeTableOffset;\n      pathTableOffset = layout.pathTableOffset;\n      bitmapOffset = layout.bitmapOffset;\n      dataOffset = layout.dataOffset;\n      pathTableUsed = INITIAL_PATH_TABLE_SIZE;\n    }\n  } else {\n    // Superblock corrupt  use default layout\n    const layout = calculateLayout(DEFAULT_INODE_COUNT, DEFAULT_BLOCK_SIZE, INITIAL_DATA_BLOCKS);\n    inodeCount = DEFAULT_INODE_COUNT;\n    blockSize = DEFAULT_BLOCK_SIZE;\n    totalBlocks = INITIAL_DATA_BLOCKS;\n    inodeTableOffset = layout.inodeTableOffset;\n    pathTableOffset = layout.pathTableOffset;\n    bitmapOffset = layout.bitmapOffset;\n    dataOffset = layout.dataOffset;\n    pathTableUsed = INITIAL_PATH_TABLE_SIZE;\n  }\n\n  // Scan inode table for valid entries\n  const decoder = new TextDecoder();\n  const recovered: Array<{ path: string; type: number; data: Uint8Array }> = [];\n  let lost = 0;\n\n  const maxInodes = Math.min(inodeCount, Math.floor((fileSize - inodeTableOffset) / INODE_SIZE));\n\n  for (let i = 0; i < maxInodes; i++) {\n    const off = inodeTableOffset + i * INODE_SIZE;\n    if (off + INODE_SIZE > fileSize) break;\n\n    const type = raw[off + INODE.TYPE];\n    if (type < INODE_TYPE.FILE || type > INODE_TYPE.SYMLINK) continue; // Skip free/invalid\n\n    const inodeView = new DataView(raw.buffer, off, INODE_SIZE);\n    const pathOffset = inodeView.getUint32(INODE.PATH_OFFSET, true);\n    const pathLength = inodeView.getUint16(INODE.PATH_LENGTH, true);\n    const size = inodeView.getFloat64(INODE.SIZE, true);\n    const firstBlock = inodeView.getUint32(INODE.FIRST_BLOCK, true);\n    const blockCount = inodeView.getUint32(INODE.BLOCK_COUNT, true);\n\n    // Try to read path\n    const absPathOffset = pathTableOffset + pathOffset;\n    if (pathLength === 0 || pathLength > 4096 || absPathOffset + pathLength > fileSize) {\n      lost++;\n      continue;\n    }\n\n    let path: string;\n    try {\n      path = decoder.decode(raw.subarray(absPathOffset, absPathOffset + pathLength));\n    } catch {\n      lost++;\n      continue;\n    }\n\n    // Validate path looks reasonable\n    if (!path.startsWith('/') || path.includes('\\0')) {\n      lost++;\n      continue;\n    }\n\n    // For directories, no data needed\n    if (type === INODE_TYPE.DIRECTORY) {\n      recovered.push({ path, type, data: new Uint8Array(0) });\n      continue;\n    }\n\n    // Try to read file data\n    if (size < 0 || size > fileSize || !isFinite(size)) {\n      lost++;\n      continue;\n    }\n\n    const dataStart = dataOffset + firstBlock * blockSize;\n    if (dataStart + size > fileSize || firstBlock >= totalBlocks) {\n      // Data blocks out of bounds  try to recover with empty data\n      recovered.push({ path, type, data: new Uint8Array(0) });\n      lost++;\n      continue;\n    }\n\n    const data = raw.slice(dataStart, dataStart + size);\n    recovered.push({ path, type, data });\n  }\n\n  // Delete corrupt VFS\n  await rootDir.removeEntry('.vfs.bin');\n\n  // Create fresh VFS with recovered data\n  const newFileHandle = await rootDir.getFileHandle('.vfs.bin', { create: true });\n  const handle = await newFileHandle.createSyncAccessHandle();\n\n  try {\n    const engine = new VFSEngine();\n    engine.init(handle); // Fresh format\n\n    // Sort: directories first (by depth), then files\n    const dirs = recovered\n      .filter(e => e.type === INODE_TYPE.DIRECTORY && e.path !== '/')\n      .sort((a, b) => a.path.localeCompare(b.path));\n    const files = recovered.filter(e => e.type === INODE_TYPE.FILE);\n    const symlinks = recovered.filter(e => e.type === INODE_TYPE.SYMLINK);\n\n    // Create directories\n    for (const dir of dirs) {\n      const result = engine.mkdir(dir.path, 0o040755);\n      if (result.status !== 0) lost++;\n    }\n\n    // Write files\n    for (const file of files) {\n      const result = engine.write(file.path, file.data);\n      if (result.status !== 0) lost++;\n    }\n\n    // Recreate symlinks\n    for (const sym of symlinks) {\n      const target = decoder.decode(sym.data);\n      const result = engine.symlink(target, sym.path);\n      if (result.status !== 0) lost++;\n    }\n\n    engine.flush();\n  } finally {\n    handle.close();\n  }\n\n  const entries = recovered\n    .filter(e => e.path !== '/')\n    .map(e => ({\n      path: e.path,\n      type: (e.type === INODE_TYPE.FILE ? 'file' : e.type === INODE_TYPE.DIRECTORY ? 'directory' : 'symlink') as 'file' | 'directory' | 'symlink',\n      size: e.data.byteLength,\n    }));\n\n  return { recovered: entries.length, lost, entries };\n}\n","/**\n * VFS-FS: High-performance OPFS-based Node.js fs polyfill\n *\n * Uses SharedArrayBuffer + Atomics for sync operations with a VFS binary format.\n *\n * @example\n * ```typescript\n * import fs from '@componentor/fs';\n *\n * // Sync API (blocks until ready)\n * fs.writeFileSync('/hello.txt', 'Hello World!');\n * const data = fs.readFileSync('/hello.txt', 'utf8');\n *\n * // Async API\n * await fs.promises.writeFile('/async.txt', 'Async data');\n * const content = await fs.promises.readFile('/async.txt', 'utf8');\n * ```\n */\n\nexport { VFSFileSystem } from './filesystem.js';\nexport { constants } from './constants.js';\nexport { FSError, createError, statusToError } from './errors.js';\nexport { unpackToOPFS, loadFromOPFS, repairVFS } from './helpers.js';\nexport type { UnpackResult, LoadResult, RepairResult } from './helpers.js';\nexport * as path from './path.js';\nexport type {\n  Stats,\n  Dirent,\n  ReadOptions,\n  WriteOptions,\n  MkdirOptions,\n  RmdirOptions,\n  RmOptions,\n  ReaddirOptions,\n  Encoding,\n  PathLike,\n  FileHandle,\n  Dir,\n  VFSConfig,\n  WatchOptions,\n  WatchEventType,\n  FSWatcher,\n  WatchListener,\n  WatchFileListener,\n  ReadStreamOptions,\n  WriteStreamOptions,\n} from './types.js';\n\nimport { VFSFileSystem } from './filesystem.js';\n\n/** Create a configured VFS instance */\nexport function createFS(config?: import('./types.js').VFSConfig): VFSFileSystem {\n  return new VFSFileSystem(config);\n}\n\n// Lazy default singleton  only created on first access\nlet _defaultFS: VFSFileSystem | undefined;\n\n/** Get (or create) the default VFS singleton */\nexport function getDefaultFS(): VFSFileSystem {\n  if (!_defaultFS) _defaultFS = new VFSFileSystem();\n  return _defaultFS;\n}\n\n/** Async init helper  avoids blocking main thread */\nexport function init(): Promise<void> {\n  return getDefaultFS().init();\n}\n"]}