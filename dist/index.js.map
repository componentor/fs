{"version":3,"sources":["../src/path.ts","../src/constants.ts","../src/errors.ts","../src/filesystem.ts","../src/index.ts"],"names":["isAbsolute","resolve","result","self"],"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA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","file":"index.js","sourcesContent":["/**\n * POSIX-style path utilities for OPFS\n * Mirrors Node.js path module behavior\n */\n\nexport const sep = '/';\nexport const delimiter = ':';\n\nexport function normalize(p: string): string {\n  if (p.length === 0) return '.';\n\n  const isAbsolute = p.charCodeAt(0) === 47; // '/'\n  const trailingSlash = p.charCodeAt(p.length - 1) === 47;\n\n  const segments = p.split('/');\n  const result: string[] = [];\n\n  for (const segment of segments) {\n    if (segment === '' || segment === '.') {\n      continue;\n    }\n    if (segment === '..') {\n      if (result.length > 0 && result[result.length - 1] !== '..') {\n        result.pop();\n      } else if (!isAbsolute) {\n        result.push('..');\n      }\n    } else {\n      result.push(segment);\n    }\n  }\n\n  let normalized = result.join('/');\n\n  if (isAbsolute) {\n    normalized = '/' + normalized;\n  }\n\n  if (trailingSlash && normalized.length > 1) {\n    normalized += '/';\n  }\n\n  return normalized || (isAbsolute ? '/' : '.');\n}\n\nexport function join(...paths: string[]): string {\n  if (paths.length === 0) return '.';\n\n  let joined: string | undefined;\n\n  for (const path of paths) {\n    if (path.length > 0) {\n      if (joined === undefined) {\n        joined = path;\n      } else {\n        joined += '/' + path;\n      }\n    }\n  }\n\n  if (joined === undefined) return '.';\n\n  return normalize(joined);\n}\n\nexport function resolve(...paths: string[]): string {\n  let resolvedPath = '';\n  let resolvedAbsolute = false;\n\n  for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    const path = i >= 0 ? paths[i] : '/';\n\n    // Handle undefined, null, or empty paths\n    if (path == null || path.length === 0) continue;\n\n    resolvedPath = resolvedPath ? path + '/' + resolvedPath : path;\n    resolvedAbsolute = path.charCodeAt(0) === 47; // '/'\n  }\n\n  resolvedPath = normalize(resolvedPath);\n\n  // Remove trailing slash unless it's the root\n  if (resolvedPath.length > 1 && resolvedPath.endsWith('/')) {\n    resolvedPath = resolvedPath.slice(0, -1);\n  }\n\n  if (resolvedAbsolute) {\n    return resolvedPath.length > 0 ? resolvedPath : '/';\n  }\n\n  return resolvedPath.length > 0 ? resolvedPath : '.';\n}\n\nexport function isAbsolute(p: string): boolean {\n  return p.length > 0 && p.charCodeAt(0) === 47; // '/'\n}\n\nexport function dirname(p: string): string {\n  if (p.length === 0) return '.';\n\n  const hasRoot = p.charCodeAt(0) === 47;\n  let end = -1;\n  let matchedSlash = true;\n\n  for (let i = p.length - 1; i >= 1; --i) {\n    if (p.charCodeAt(i) === 47) {\n      if (!matchedSlash) {\n        end = i;\n        break;\n      }\n    } else {\n      matchedSlash = false;\n    }\n  }\n\n  if (end === -1) return hasRoot ? '/' : '.';\n  if (hasRoot && end === 1) return '//';\n\n  return p.slice(0, end);\n}\n\nexport function basename(p: string, ext?: string): string {\n  let start = 0;\n  let end = -1;\n  let matchedSlash = true;\n\n  for (let i = p.length - 1; i >= 0; --i) {\n    if (p.charCodeAt(i) === 47) {\n      if (!matchedSlash) {\n        start = i + 1;\n        break;\n      }\n    } else if (end === -1) {\n      matchedSlash = false;\n      end = i + 1;\n    }\n  }\n\n  if (end === -1) return '';\n\n  const base = p.slice(start, end);\n\n  if (ext && base.endsWith(ext)) {\n    return base.slice(0, base.length - ext.length);\n  }\n\n  return base;\n}\n\nexport function extname(p: string): string {\n  let startDot = -1;\n  let startPart = 0;\n  let end = -1;\n  let matchedSlash = true;\n  let preDotState = 0;\n\n  for (let i = p.length - 1; i >= 0; --i) {\n    const code = p.charCodeAt(i);\n\n    if (code === 47) {\n      if (!matchedSlash) {\n        startPart = i + 1;\n        break;\n      }\n      continue;\n    }\n\n    if (end === -1) {\n      matchedSlash = false;\n      end = i + 1;\n    }\n\n    if (code === 46) {\n      if (startDot === -1) {\n        startDot = i;\n      } else if (preDotState !== 1) {\n        preDotState = 1;\n      }\n    } else if (startDot !== -1) {\n      preDotState = -1;\n    }\n  }\n\n  if (\n    startDot === -1 ||\n    end === -1 ||\n    preDotState === 0 ||\n    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)\n  ) {\n    return '';\n  }\n\n  return p.slice(startDot, end);\n}\n\nexport function relative(from: string, to: string): string {\n  if (from === to) return '';\n\n  from = resolve(from);\n  to = resolve(to);\n\n  if (from === to) return '';\n\n  // Split into segments\n  const fromParts = from.split('/').filter(Boolean);\n  const toParts = to.split('/').filter(Boolean);\n\n  // Find common base\n  let commonLength = 0;\n  const minLength = Math.min(fromParts.length, toParts.length);\n  for (let i = 0; i < minLength; i++) {\n    if (fromParts[i] === toParts[i]) {\n      commonLength++;\n    } else {\n      break;\n    }\n  }\n\n  // Build relative path\n  const upCount = fromParts.length - commonLength;\n  const relativeParts: string[] = [];\n\n  for (let i = 0; i < upCount; i++) {\n    relativeParts.push('..');\n  }\n\n  for (let i = commonLength; i < toParts.length; i++) {\n    relativeParts.push(toParts[i]);\n  }\n\n  return relativeParts.join('/') || '.';\n}\n\nexport function parse(p: string): {\n  root: string;\n  dir: string;\n  base: string;\n  ext: string;\n  name: string;\n} {\n  const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n\n  if (p.length === 0) return ret;\n\n  const isAbsolutePath = p.charCodeAt(0) === 47;\n\n  if (isAbsolutePath) {\n    ret.root = '/';\n  }\n\n  let start = 0;\n  let end = -1;\n  let startDot = -1;\n  let matchedSlash = true;\n  let preDotState = 0;\n\n  for (let i = p.length - 1; i >= 0; --i) {\n    const code = p.charCodeAt(i);\n\n    if (code === 47) {\n      if (!matchedSlash) {\n        start = i + 1;\n        break;\n      }\n      continue;\n    }\n\n    if (end === -1) {\n      matchedSlash = false;\n      end = i + 1;\n    }\n\n    if (code === 46) {\n      if (startDot === -1) {\n        startDot = i;\n      } else if (preDotState !== 1) {\n        preDotState = 1;\n      }\n    } else if (startDot !== -1) {\n      preDotState = -1;\n    }\n  }\n\n  if (end !== -1) {\n    if (\n      startDot === -1 ||\n      preDotState === 0 ||\n      (preDotState === 1 && startDot === end - 1 && startDot === start + 1)\n    ) {\n      ret.base = p.slice(start, end);\n      ret.name = ret.base;\n    } else {\n      ret.name = p.slice(start, startDot);\n      ret.base = p.slice(start, end);\n      ret.ext = p.slice(startDot, end);\n    }\n  }\n\n  if (start > 0) {\n    ret.dir = p.slice(0, start - 1);\n  } else if (isAbsolutePath) {\n    ret.dir = '/';\n  }\n\n  return ret;\n}\n\nexport function format(pathObject: {\n  root?: string;\n  dir?: string;\n  base?: string;\n  ext?: string;\n  name?: string;\n}): string {\n  const dir = pathObject.dir || pathObject.root || '';\n  const base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n\n  if (!dir) return base;\n  if (dir === pathObject.root) return dir + base;\n\n  return dir + '/' + base;\n}\n\nexport const posix = {\n  sep,\n  delimiter,\n  normalize,\n  join,\n  resolve,\n  isAbsolute,\n  dirname,\n  basename,\n  extname,\n  relative,\n  parse,\n  format,\n};\n\nexport default posix;\n","/**\n * File system constants matching Node.js fs.constants\n */\n\nexport const constants = {\n  // File access constants\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n\n  // File copy constants\n  COPYFILE_EXCL: 1,\n  COPYFILE_FICLONE: 2,\n  COPYFILE_FICLONE_FORCE: 4,\n\n  // File open constants\n  O_RDONLY: 0,\n  O_WRONLY: 1,\n  O_RDWR: 2,\n  O_CREAT: 64,\n  O_EXCL: 128,\n  O_TRUNC: 512,\n  O_APPEND: 1024,\n  O_SYNC: 4096,\n\n  // File type constants\n  S_IFMT: 61440,\n  S_IFREG: 32768,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960,\n  S_IFSOCK: 49152,\n\n  // File mode constants\n  S_IRWXU: 448,\n  S_IRUSR: 256,\n  S_IWUSR: 128,\n  S_IXUSR: 64,\n  S_IRWXG: 56,\n  S_IRGRP: 32,\n  S_IWGRP: 16,\n  S_IXGRP: 8,\n  S_IRWXO: 7,\n  S_IROTH: 4,\n  S_IWOTH: 2,\n  S_IXOTH: 1,\n} as const;\n\nexport type Constants = typeof constants;\n","/**\n * Node.js compatible filesystem error classes\n */\n\nexport class FSError extends Error {\n  code: string;\n  errno: number;\n  syscall?: string;\n  path?: string;\n\n  constructor(code: string, errno: number, message: string, syscall?: string, path?: string) {\n    super(message);\n    this.name = 'FSError';\n    this.code = code;\n    this.errno = errno;\n    this.syscall = syscall;\n    this.path = path;\n\n    // Maintain proper stack trace (V8 specific)\n    const ErrorWithCapture = Error as unknown as { captureStackTrace?: (target: object, constructor: Function) => void };\n    if (ErrorWithCapture.captureStackTrace) {\n      ErrorWithCapture.captureStackTrace(this, FSError);\n    }\n  }\n}\n\nexport const ErrorCodes = {\n  ENOENT: -2,\n  EEXIST: -17,\n  EISDIR: -21,\n  ENOTDIR: -20,\n  ENOTEMPTY: -39,\n  EACCES: -13,\n  EBADF: -9,\n  EINVAL: -22,\n  EMFILE: -24,\n  ENOSPC: -28,\n  EPERM: -1,\n  ENOSYS: -38,\n  ELOOP: -40,\n} as const;\n\nexport function createENOENT(syscall: string, path: string): FSError {\n  return new FSError(\n    'ENOENT',\n    ErrorCodes.ENOENT,\n    `ENOENT: no such file or directory, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createEEXIST(syscall: string, path: string): FSError {\n  return new FSError(\n    'EEXIST',\n    ErrorCodes.EEXIST,\n    `EEXIST: file already exists, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createEISDIR(syscall: string, path: string): FSError {\n  return new FSError(\n    'EISDIR',\n    ErrorCodes.EISDIR,\n    `EISDIR: illegal operation on a directory, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createENOTDIR(syscall: string, path: string): FSError {\n  return new FSError(\n    'ENOTDIR',\n    ErrorCodes.ENOTDIR,\n    `ENOTDIR: not a directory, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createENOTEMPTY(syscall: string, path: string): FSError {\n  return new FSError(\n    'ENOTEMPTY',\n    ErrorCodes.ENOTEMPTY,\n    `ENOTEMPTY: directory not empty, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createEACCES(syscall: string, path: string): FSError {\n  return new FSError(\n    'EACCES',\n    ErrorCodes.EACCES,\n    `EACCES: permission denied, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createEINVAL(syscall: string, path: string): FSError {\n  return new FSError(\n    'EINVAL',\n    ErrorCodes.EINVAL,\n    `EINVAL: invalid argument, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createENOSYS(syscall: string, path: string): FSError {\n  return new FSError(\n    'ENOSYS',\n    ErrorCodes.ENOSYS,\n    `ENOSYS: function not implemented, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function createELOOP(syscall: string, path: string): FSError {\n  return new FSError(\n    'ELOOP',\n    ErrorCodes.ELOOP,\n    `ELOOP: too many symbolic links encountered, ${syscall} '${path}'`,\n    syscall,\n    path\n  );\n}\n\nexport function mapErrorCode(errorName: string, syscall: string, path: string): FSError {\n  switch (errorName) {\n    case 'NotFoundError':\n      return createENOENT(syscall, path);\n    case 'NotAllowedError':\n      return createEACCES(syscall, path);\n    case 'TypeMismatchError':\n      return createENOTDIR(syscall, path);\n    case 'InvalidModificationError':\n      return createENOTEMPTY(syscall, path);\n    case 'QuotaExceededError':\n      return new FSError('ENOSPC', ErrorCodes.ENOSPC, `ENOSPC: no space left on device, ${syscall} '${path}'`, syscall, path);\n    default:\n      return new FSError('EINVAL', ErrorCodes.EINVAL, `${errorName}: ${syscall} '${path}'`, syscall, path);\n  }\n}\n","/**\n * OPFS FileSystem - Node.js fs-compatible API\n * Supports two performance tiers:\n * - Tier 1 (Sync): SharedArrayBuffer + Atomics - requires crossOriginIsolated (COOP/COEP headers)\n * - Tier 2 (Async): Promises API using Worker kernel - always available\n */\n\nimport * as path from './path.js';\nimport { constants } from './constants.js';\nimport {\n  FSError,\n  createENOENT,\n  mapErrorCode,\n} from './errors.js';\nimport type {\n  Stats,\n  Dirent,\n  ReadOptions,\n  WriteOptions,\n  MkdirOptions,\n  RmdirOptions,\n  RmOptions,\n  ReaddirOptions,\n  Encoding,\n  FileSystemPromises,\n  KernelResponse,\n  KernelResult,\n  ReadStreamOptions,\n  WriteStreamOptions,\n  WatchOptions,\n  WatchFileOptions,\n  WatchEventType,\n  FileHandle,\n  Dir,\n  FSWatcher,\n  StatWatcher,\n  WatchListener,\n  WatchFileListener,\n  FileSystemChangeRecord,\n  FileSystemObserverCallback,\n  FileSystemObserverInterface,\n} from './types.js';\n\n// Detect if we're running in a Worker context (where Atomics.wait and createSyncAccessHandle work)\nconst isWorkerContext = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n\n// Worker kernel source - inlined for zero-config deployment\n// Uses direct Worker postMessage for simple communication\n// Includes sync handle caching for performance (same as sync kernel)\nconst KERNEL_SOURCE = `\nconst LOCK_NAME = 'opfs_fs_lock';\nlet messageQueue = [];\nlet isReady = false;\nlet cachedRoot = null;\nconst dirCache = new Map();\n\n// Sync handle cache - MAJOR performance optimization (2-5x speedup)\n// Uses readwrite-unsafe mode when available (no exclusive lock, allows external access)\n// Falls back to readwrite with debounced release for older browsers\nconst syncHandleCache = new Map();\nconst MAX_HANDLES = 100;\n\n// Track if readwrite-unsafe mode is supported (detected on first use)\nlet unsafeModeSupported = null;\n\n// Debug tracing - set via 'setDebug' message\nlet debugTrace = false;\nfunction trace(...args) {\n  if (debugTrace) console.log('[OPFS-T2]', ...args);\n}\n\n// Minimal timer for legacy mode only\nlet releaseTimer = null;\nconst LEGACY_RELEASE_DELAY = 100;\n\nfunction scheduleHandleRelease() {\n  if (unsafeModeSupported) return; // No release needed for readwrite-unsafe\n  if (releaseTimer) return; // Already scheduled\n  releaseTimer = setTimeout(() => {\n    releaseTimer = null;\n    const count = syncHandleCache.size;\n    for (const h of syncHandleCache.values()) {\n      try { h.flush(); h.close(); } catch {}\n    }\n    syncHandleCache.clear();\n    trace('Released ' + count + ' handles (legacy mode debounce)');\n  }, LEGACY_RELEASE_DELAY);\n}\n\nasync function getSyncHandle(filePath, create) {\n  const cached = syncHandleCache.get(filePath);\n  if (cached) {\n    trace('Handle cache HIT: ' + filePath);\n    return cached;\n  }\n\n  // Evict oldest handles if cache is full\n  if (syncHandleCache.size >= MAX_HANDLES) {\n    const keys = Array.from(syncHandleCache.keys()).slice(0, 10);\n    trace('LRU evicting ' + keys.length + ' handles');\n    for (const key of keys) {\n      const h = syncHandleCache.get(key);\n      if (h) { try { h.close(); } catch {} syncHandleCache.delete(key); }\n    }\n  }\n\n  const fh = await getFileHandle(filePath, create);\n\n  // Try readwrite-unsafe mode first (no exclusive lock, Chrome 121+)\n  let access;\n  if (unsafeModeSupported === null) {\n    // First time - detect support\n    try {\n      access = await fh.createSyncAccessHandle({ mode: 'readwrite-unsafe' });\n      unsafeModeSupported = true;\n      trace('readwrite-unsafe mode SUPPORTED - handles won\\\\'t block');\n    } catch {\n      // Not supported, use default mode\n      access = await fh.createSyncAccessHandle();\n      unsafeModeSupported = false;\n      trace('readwrite-unsafe mode NOT supported - using legacy mode');\n    }\n  } else if (unsafeModeSupported) {\n    access = await fh.createSyncAccessHandle({ mode: 'readwrite-unsafe' });\n  } else {\n    access = await fh.createSyncAccessHandle();\n  }\n\n  syncHandleCache.set(filePath, access);\n  trace('Handle ACQUIRED: ' + filePath + ' (cache size: ' + syncHandleCache.size + ')');\n  return access;\n}\n\nfunction closeSyncHandle(filePath) {\n  const h = syncHandleCache.get(filePath);\n  if (h) {\n    try { h.close(); } catch {}\n    syncHandleCache.delete(filePath);\n    trace('Handle RELEASED: ' + filePath);\n  }\n}\n\nfunction closeHandlesUnder(prefix) {\n  for (const [p, h] of syncHandleCache) {\n    if (p === prefix || p.startsWith(prefix + '/')) {\n      try { h.close(); } catch {}\n      syncHandleCache.delete(p);\n    }\n  }\n}\n\n// Clear directory cache entries for a path and all descendants\nfunction clearDirCacheUnder(filePath) {\n  // Convert to cache key format (no leading slash)\n  const prefix = parsePath(filePath).join('/');\n  if (!prefix) {\n    // Root directory - clear everything\n    dirCache.clear();\n    return;\n  }\n  for (const key of dirCache.keys()) {\n    if (key === prefix || key.startsWith(prefix + '/')) {\n      dirCache.delete(key);\n    }\n  }\n}\n\nasync function getRoot() {\n  if (!cachedRoot) {\n    cachedRoot = await navigator.storage.getDirectory();\n  }\n  return cachedRoot;\n}\n\nfunction parsePath(filePath) {\n  return filePath.split('/').filter(Boolean);\n}\n\nasync function getDirectoryHandle(parts, create = false) {\n  if (parts.length === 0) return getRoot();\n\n  const cacheKey = parts.join('/');\n  if (dirCache.has(cacheKey)) {\n    return dirCache.get(cacheKey);\n  }\n\n  let curr = await getRoot();\n  let pathSoFar = '';\n\n  for (const part of parts) {\n    pathSoFar += (pathSoFar ? '/' : '') + part;\n\n    if (dirCache.has(pathSoFar)) {\n      curr = dirCache.get(pathSoFar);\n    } else {\n      curr = await curr.getDirectoryHandle(part, { create });\n      dirCache.set(pathSoFar, curr);\n    }\n  }\n\n  return curr;\n}\n\nasync function getFileHandle(filePath, create = false) {\n  const parts = parsePath(filePath);\n  const fileName = parts.pop();\n  if (!fileName) throw new Error('Invalid file path');\n  const dir = parts.length > 0 ? await getDirectoryHandle(parts, create) : await getRoot();\n  return await dir.getFileHandle(fileName, { create });\n}\n\nasync function getParentAndName(filePath) {\n  const parts = parsePath(filePath);\n  const name = parts.pop();\n  if (!name) throw new Error('Invalid path');\n  const parent = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n  return { parent, name };\n}\n\nasync function handleRead(filePath, payload) {\n  const access = await getSyncHandle(filePath, false);\n  const size = access.getSize();\n  const offset = payload?.offset || 0;\n  const len = payload?.len || (size - offset);\n  const buf = new Uint8Array(len);\n  const bytesRead = access.read(buf, { at: offset });\n  return { data: buf.slice(0, bytesRead) };\n}\n\n// Non-blocking read using getFile() - does NOT lock the file\n// Use this for HMR scenarios where external tools need to modify files\nasync function handleReadAsync(filePath, payload) {\n  const parts = parsePath(filePath);\n  const fileName = parts.pop();\n  if (!fileName) throw new Error('Invalid file path');\n  const dir = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n  const fh = await dir.getFileHandle(fileName);\n  const file = await fh.getFile();\n\n  const offset = payload?.offset || 0;\n  const len = payload?.len || (file.size - offset);\n\n  if (offset === 0 && len === file.size) {\n    // Fast path: read entire file\n    const buf = new Uint8Array(await file.arrayBuffer());\n    return { data: buf };\n  }\n\n  // Partial read using slice\n  const slice = file.slice(offset, offset + len);\n  const buf = new Uint8Array(await slice.arrayBuffer());\n  return { data: buf };\n}\n\n// Force release a file handle - allows external tools to modify the file\nfunction handleReleaseHandle(filePath) {\n  closeSyncHandle(filePath);\n  return { success: true };\n}\n\n// Force release ALL file handles - use before HMR notifications\nfunction handleReleaseAllHandles() {\n  for (const h of syncHandleCache.values()) {\n    try { h.close(); } catch {}\n  }\n  syncHandleCache.clear();\n  return { success: true };\n}\n\nasync function handleWrite(filePath, payload) {\n  const access = await getSyncHandle(filePath, true);\n  if (payload?.data) {\n    const offset = payload.offset ?? 0;\n    if (offset === 0) access.truncate(0);\n    access.write(payload.data, { at: offset });\n    if (payload?.flush !== false) access.flush();\n  }\n  return { success: true };\n}\n\nasync function handleAppend(filePath, payload) {\n  const access = await getSyncHandle(filePath, true);\n  if (payload?.data) {\n    const size = access.getSize();\n    access.write(payload.data, { at: size });\n    if (payload?.flush !== false) access.flush();\n  }\n  return { success: true };\n}\n\nasync function handleTruncate(filePath, payload) {\n  const access = await getSyncHandle(filePath, false);\n  access.truncate(payload?.len ?? 0);\n  access.flush();\n  return { success: true };\n}\n\nasync function handleStat(filePath) {\n  const parts = parsePath(filePath);\n  // Node.js compatible stat shape: mode 33188 = file (0o100644), 16877 = dir (0o40755)\n  if (parts.length === 0) {\n    return { size: 0, mtimeMs: Date.now(), mode: 16877, type: 'directory' };\n  }\n  const name = parts.pop();\n  const parent = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n  try {\n    const fh = await parent.getFileHandle(name);\n    // Use getFile() for metadata - faster than createSyncAccessHandle\n    const file = await fh.getFile();\n    return { size: file.size, mtimeMs: file.lastModified, mode: 33188, type: 'file' };\n  } catch {\n    try {\n      await parent.getDirectoryHandle(name);\n      return { size: 0, mtimeMs: Date.now(), mode: 16877, type: 'directory' };\n    } catch {\n      throw new Error('NotFoundError');\n    }\n  }\n}\n\nasync function handleExists(filePath) {\n  try {\n    await handleStat(filePath);\n    return { exists: true };\n  } catch {\n    return { exists: false };\n  }\n}\n\nasync function handleMkdir(filePath, payload) {\n  const parts = parsePath(filePath);\n  if (payload?.recursive) {\n    let curr = await getRoot();\n    for (const part of parts) {\n      curr = await curr.getDirectoryHandle(part, { create: true });\n    }\n  } else {\n    const name = parts.pop();\n    if (!name) throw new Error('Invalid path');\n    const parent = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n    await parent.getDirectoryHandle(name, { create: true });\n  }\n  return { success: true };\n}\n\nasync function handleRmdir(filePath, payload) {\n  closeHandlesUnder(filePath); // Close all cached file handles under this directory\n  clearDirCacheUnder(filePath); // Clear stale directory cache entries\n  const { parent, name } = await getParentAndName(filePath);\n  if (payload?.recursive) {\n    await parent.removeEntry(name, { recursive: true });\n  } else {\n    const dir = await parent.getDirectoryHandle(name);\n    const entries = dir.entries();\n    const first = await entries.next();\n    if (!first.done) {\n      const e = new Error('InvalidModificationError');\n      e.name = 'InvalidModificationError';\n      throw e;\n    }\n    await parent.removeEntry(name);\n  }\n  return { success: true };\n}\n\nasync function handleUnlink(filePath) {\n  closeSyncHandle(filePath); // Close cached handle before deleting\n  const { parent, name } = await getParentAndName(filePath);\n  await parent.removeEntry(name);\n  return { success: true };\n}\n\nasync function handleReaddir(filePath) {\n  const parts = parsePath(filePath);\n  const dir = parts.length > 0 ? await getDirectoryHandle(parts, false) : await getRoot();\n  const entries = [];\n  for await (const [name] of dir.entries()) {\n    entries.push(name);\n  }\n  return { entries };\n}\n\nasync function handleRename(oldPath, payload) {\n  if (!payload?.newPath) throw new Error('newPath required');\n  const newPath = payload.newPath;\n\n  // Close cached handles for old path (file will be deleted)\n  closeSyncHandle(oldPath);\n  closeHandlesUnder(oldPath); // For directory renames\n  clearDirCacheUnder(oldPath); // Clear stale directory cache entries\n\n  const oldParts = parsePath(oldPath);\n  const newParts = parsePath(newPath);\n  const oldName = oldParts.pop();\n  const newName = newParts.pop();\n  const oldParent = oldParts.length > 0 ? await getDirectoryHandle(oldParts, false) : await getRoot();\n  const newParent = newParts.length > 0 ? await getDirectoryHandle(newParts, true) : await getRoot();\n\n  try {\n    const fh = await oldParent.getFileHandle(oldName);\n    const file = await fh.getFile();\n    const data = new Uint8Array(await file.arrayBuffer());\n\n    // Use cached handle for new file\n    const access = await getSyncHandle(newPath, true);\n    access.truncate(0);\n    access.write(data, { at: 0 });\n    access.flush();\n\n    await oldParent.removeEntry(oldName);\n    return { success: true };\n  } catch {\n    const oldDir = await oldParent.getDirectoryHandle(oldName);\n    async function copyDir(src, dst, dstPath) {\n      for await (const [name, handle] of src.entries()) {\n        if (handle.kind === 'file') {\n          const srcFile = await handle.getFile();\n          const data = new Uint8Array(await srcFile.arrayBuffer());\n          const filePath = dstPath + '/' + name;\n          const access = await getSyncHandle(filePath, true);\n          access.truncate(0);\n          access.write(data, { at: 0 });\n          access.flush();\n        } else {\n          const newSubDir = await dst.getDirectoryHandle(name, { create: true });\n          await copyDir(handle, newSubDir, dstPath + '/' + name);\n        }\n      }\n    }\n    const newDir = await newParent.getDirectoryHandle(newName, { create: true });\n    await copyDir(oldDir, newDir, newPath);\n    await oldParent.removeEntry(oldName, { recursive: true });\n    return { success: true };\n  }\n}\n\nasync function handleCopy(srcPath, payload) {\n  if (!payload?.newPath) throw new Error('newPath required');\n  const dstPath = payload.newPath;\n  const srcParts = parsePath(srcPath);\n  const srcName = srcParts.pop();\n  const srcParent = srcParts.length > 0 ? await getDirectoryHandle(srcParts, false) : await getRoot();\n  const srcFh = await srcParent.getFileHandle(srcName);\n  const srcFile = await srcFh.getFile();\n  const data = new Uint8Array(await srcFile.arrayBuffer());\n\n  // Use cached handle for destination\n  const access = await getSyncHandle(dstPath, true);\n  access.truncate(0);\n  access.write(data, { at: 0 });\n  access.flush();\n  return { success: true };\n}\n\nfunction handleFlush() {\n  // Flush all cached sync handles\n  for (const [, handle] of syncHandleCache) {\n    try { handle.flush(); } catch {}\n  }\n  return { success: true };\n}\n\nfunction handlePurge() {\n  if (releaseTimer) {\n    clearTimeout(releaseTimer);\n    releaseTimer = null;\n  }\n  for (const handle of syncHandleCache.values()) {\n    try { handle.flush(); handle.close(); } catch {}\n  }\n  syncHandleCache.clear();\n  dirCache.clear();\n  cachedRoot = null;\n  return { success: true };\n}\n\nasync function processMessage(msg) {\n  const { type, path, payload } = msg;\n  switch (type) {\n    case 'read': return handleRead(path, payload);\n    case 'readAsync': return handleReadAsync(path, payload);\n    case 'write': return handleWrite(path, payload);\n    case 'append': return handleAppend(path, payload);\n    case 'truncate': return handleTruncate(path, payload);\n    case 'stat': return handleStat(path);\n    case 'exists': return handleExists(path);\n    case 'mkdir': return handleMkdir(path, payload);\n    case 'rmdir': return handleRmdir(path, payload);\n    case 'unlink': return handleUnlink(path);\n    case 'readdir': return handleReaddir(path);\n    case 'rename': return handleRename(path, payload);\n    case 'copy': return handleCopy(path, payload);\n    case 'flush': return handleFlush();\n    case 'purge': return handlePurge();\n    case 'releaseHandle': return handleReleaseHandle(path);\n    case 'releaseAllHandles': return handleReleaseAllHandles();\n    case 'setDebug':\n      debugTrace = !!payload?.enabled;\n      trace('Debug tracing ' + (debugTrace ? 'ENABLED' : 'DISABLED') + ', unsafeMode: ' + unsafeModeSupported);\n      return { success: true, debugTrace, unsafeModeSupported, cacheSize: syncHandleCache.size };\n    default: throw new Error('Unknown operation: ' + type);\n  }\n}\n\nfunction sendAtomicsResponse(result, payload) {\n  const ctrl = payload.ctrl;\n  if (result.data && payload.dataBuffer) {\n    const view = new Uint8Array(payload.dataBuffer);\n    view.set(result.data);\n    Atomics.store(ctrl, 0, result.data.length);\n  } else if (result.entries && payload.resultBuffer) {\n    const json = JSON.stringify(result);\n    const encoded = new TextEncoder().encode(json);\n    const view = new Uint8Array(payload.resultBuffer);\n    view.set(encoded);\n    Atomics.store(ctrl, 0, encoded.length);\n  } else if (result.success) {\n    Atomics.store(ctrl, 0, 1);\n  } else if (result.exists !== undefined) {\n    Atomics.store(ctrl, 0, result.exists ? 1 : 0);\n  } else if (result.isFile !== undefined) {\n    if (payload.resultBuffer) {\n      const json = JSON.stringify(result);\n      const encoded = new TextEncoder().encode(json);\n      const view = new Uint8Array(payload.resultBuffer);\n      view.set(encoded);\n      Atomics.store(ctrl, 0, encoded.length);\n    } else {\n      Atomics.store(ctrl, 0, result.size || 0);\n    }\n  }\n  Atomics.notify(ctrl, 0);\n}\n\n// Handle incoming messages\nasync function handleMessage(msg) {\n  const { id, payload } = msg;\n  try {\n    const result = await processMessage(msg);\n    if (payload?.ctrl) {\n      sendAtomicsResponse(result, payload);\n    } else {\n      // Use Transferable for data to avoid copying\n      if (result.data) {\n        const buffer = result.data.buffer;\n        self.postMessage({ id, result }, [buffer]);\n      } else {\n        self.postMessage({ id, result });\n      }\n    }\n  } catch (e) {\n    const error = e instanceof Error ? e : new Error(String(e));\n    // Use error name if it's a specific DOM exception, otherwise use message\n    // (handleStat throws new Error('NotFoundError') where message contains the type)\n    const errorName = error.name || 'Error';\n    const errorCode = errorName !== 'Error' ? errorName : (error.message || 'Error');\n    if (payload?.ctrl) {\n      Atomics.store(payload.ctrl, 0, -1);\n      Atomics.notify(payload.ctrl, 0);\n    } else {\n      self.postMessage({ id, error: errorCode, code: errorCode });\n    }\n  } finally {\n    // Schedule handle release (debounced - waits 100ms after last operation)\n    scheduleHandleRelease();\n  }\n}\n\n// Process queued messages after ready\nfunction processQueue() {\n  while (messageQueue.length > 0) {\n    const msg = messageQueue.shift();\n    handleMessage(msg);\n  }\n}\n\n// Handle messages directly - no serialization needed because:\n// - Tier 2: Client awaits response before sending next message\n// - Each OPFSFileSystem instance has its own worker\nself.onmessage = (event) => {\n  if (isReady) {\n    handleMessage(event.data);\n  } else {\n    messageQueue.push(event.data);\n  }\n};\n\n// Signal ready after a timeout to ensure main thread handler is set\nsetTimeout(() => {\n  isReady = true;\n  processQueue();\n  self.postMessage({ type: 'ready' });\n}, 10);\n`;\n\n// --- Helper functions ---\n\nfunction createStats(result: KernelResult): Stats {\n  // Support both new format (type, mtimeMs) and legacy format (isFile, isDirectory, mtime)\n  const isFile = result.type ? result.type === 'file' : (result.isFile ?? false);\n  const isDir = result.type ? result.type === 'directory' : (result.isDirectory ?? false);\n  const mtimeMs = result.mtimeMs ?? result.mtime ?? Date.now();\n  const size = result.size ?? 0;\n  const mode = result.mode ?? (isDir ? 16877 : 33188);\n\n  return {\n    isFile: () => isFile,\n    isDirectory: () => isDir,\n    isBlockDevice: () => false,\n    isCharacterDevice: () => false,\n    isSymbolicLink: () => false,\n    isFIFO: () => false,\n    isSocket: () => false,\n    dev: 0,\n    ino: 0,\n    mode,\n    nlink: 1,\n    uid: 0,\n    gid: 0,\n    rdev: 0,\n    size,\n    blksize: 4096,\n    blocks: Math.ceil(size / 512),\n    atimeMs: mtimeMs,\n    mtimeMs,\n    ctimeMs: mtimeMs,\n    birthtimeMs: mtimeMs,\n    atime: new Date(mtimeMs),\n    mtime: new Date(mtimeMs),\n    ctime: new Date(mtimeMs),\n    birthtime: new Date(mtimeMs),\n  };\n}\n\nfunction createDirent(name: string, isDir: boolean): Dirent {\n  return {\n    name,\n    isFile: () => !isDir,\n    isDirectory: () => isDir,\n    isBlockDevice: () => false,\n    isCharacterDevice: () => false,\n    isSymbolicLink: () => false,\n    isFIFO: () => false,\n    isSocket: () => false,\n  };\n}\n\nfunction generateId(): string {\n  return Math.random().toString(36).substring(2, 15);\n}\n\nfunction encodeData(data: Uint8Array | string | ArrayBufferView | ArrayBuffer, _encoding?: Encoding): Uint8Array {\n  if (typeof data === 'string') {\n    return new TextEncoder().encode(data);\n  }\n  if (data instanceof Uint8Array) {\n    return data;\n  }\n  if (data instanceof ArrayBuffer) {\n    return new Uint8Array(data);\n  }\n  if (ArrayBuffer.isView(data)) {\n    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  }\n  // Fallback for unknown types - convert to string\n  return new TextEncoder().encode(String(data ?? ''));\n}\n\nfunction decodeData(data: Uint8Array, encoding?: Encoding | null): Uint8Array | string {\n  if (encoding === 'utf8' || encoding === 'utf-8') {\n    return new TextDecoder().decode(data);\n  }\n  return data;\n}\n\n// File descriptor entry for low-level read/write operations\ninterface FileDescriptor {\n  path: string;\n  flags: number;\n  position: number;\n}\n\nexport class OPFSFileSystem {\n  private worker: Worker | null = null;\n  private pending = new Map<string, { resolve: (v: KernelResult) => void; reject: (e: Error) => void; path: string; type: string }>();\n  private initialized = false;\n  private initPromise: Promise<void> | null = null;\n\n  // File descriptor table for openSync/readSync/writeSync/closeSync\n  private fdTable = new Map<number, FileDescriptor>();\n  private nextFd = 3; // Start at 3 (0=stdin, 1=stdout, 2=stderr)\n\n  // Stat cache - reduces FS traffic by 30-50% for git operations\n  private statCache = new Map<string, Stats>();\n\n  constructor() {\n    // Auto-initialize worker for fast async operations\n    this.initWorker();\n  }\n\n  // Invalidate stat cache for a path (and parent for directory operations)\n  private invalidateStat(filePath: string): void {\n    const absPath = path.normalize(path.resolve(filePath));\n    this.statCache.delete(absPath);\n    // Also invalidate parent directory (for readdir caching if added later)\n    const parent = path.dirname(absPath);\n    if (parent !== absPath) {\n      this.statCache.delete(parent);\n    }\n  }\n\n  // Invalidate all stats under a directory (for recursive operations)\n  private invalidateStatsUnder(dirPath: string): void {\n    const prefix = path.normalize(path.resolve(dirPath));\n    for (const key of this.statCache.keys()) {\n      if (key === prefix || key.startsWith(prefix + '/')) {\n        this.statCache.delete(key);\n      }\n    }\n  }\n\n  private async initWorker(): Promise<void> {\n    if (this.initialized) return;\n    if (this.initPromise) return this.initPromise;\n\n    this.initPromise = (async () => {\n      const blob = new Blob([KERNEL_SOURCE], { type: 'application/javascript' });\n      this.worker = new Worker(URL.createObjectURL(blob));\n\n      // Set up message handler FIRST, before worker can send 'ready'\n      const readyPromise = new Promise<void>((resolve) => {\n        this.worker!.onmessage = (event: MessageEvent<KernelResponse>) => {\n          const { id, result, error, code, type: msgType } = event.data;\n\n          // Handle ready signal\n          if (msgType === 'ready') {\n            resolve();\n            return;\n          }\n\n          const pending = this.pending.get(id);\n          if (pending) {\n            this.pending.delete(id);\n            if (error) {\n              // Map DOM exception names to Node.js-style error codes\n              // Use stored path from pending request (more reliable than extracting from error)\n              const errCode = code || 'Error';\n              if (errCode === 'NotFoundError' || errCode === 'NotAllowedError' ||\n                  errCode === 'TypeMismatchError' || errCode === 'InvalidModificationError' ||\n                  errCode === 'QuotaExceededError') {\n                pending.reject(mapErrorCode(errCode, pending.type, pending.path));\n              } else {\n                pending.reject(new FSError(errCode, -1, `${error}: ${pending.type} '${pending.path}'`));\n              }\n            } else if (result) {\n              pending.resolve(result);\n            }\n          }\n        };\n      });\n\n      await readyPromise;\n      this.initialized = true;\n    })();\n\n    return this.initPromise;\n  }\n\n  // Async call to worker - uses fast createSyncAccessHandle internally\n  private async asyncCall(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): Promise<KernelResult> {\n    await this.initWorker();\n\n    if (!this.worker) {\n      throw new Error('Worker not initialized');\n    }\n\n    const absPath = path.resolve(filePath);\n    const id = generateId();\n\n    return new Promise((resolve, reject) => {\n      this.pending.set(id, { resolve, reject, path: absPath, type });\n\n      const msg = {\n        id,\n        type,\n        path: absPath,\n        payload,\n      };\n\n      // Transfer ArrayBuffer if payload contains data (for writes)\n      if (payload?.data instanceof Uint8Array) {\n        // Clone the data since we're transferring - caller might still need original\n        const clone = new Uint8Array(payload.data);\n        const newPayload = { ...payload, data: clone };\n        this.worker!.postMessage({ ...msg, payload: newPayload }, [clone.buffer]);\n      } else {\n        this.worker!.postMessage(msg);\n      }\n    });\n  }\n\n  // Kernel worker for Tier 1 sync operations (loaded from URL, not blob)\n  private syncKernel: Worker | null = null;\n  private syncKernelReady = false;\n\n  /**\n   * Initialize sync operations with a kernel worker loaded from URL.\n   * Required for Tier 1 (SharedArrayBuffer + Atomics) to work in nested Workers.\n   * @param kernelUrl URL to the kernel.js file (defaults to '/kernel.js')\n   */\n  async initSync(kernelUrl = '/kernel.js'): Promise<void> {\n    if (this.syncKernelReady) return;\n\n    this.syncKernel = new Worker(kernelUrl, { type: 'module' });\n\n    await new Promise<void>((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('Kernel init timeout')), 10000);\n      this.syncKernel!.onmessage = (e) => {\n        if (e.data?.type === 'ready') {\n          clearTimeout(timeout);\n          this.syncKernelReady = true;\n          resolve();\n        }\n      };\n      this.syncKernel!.onerror = (e) => {\n        clearTimeout(timeout);\n        reject(new Error(`Kernel error: ${e.message}`));\n      };\n    });\n  }\n\n  // Tier 1: SharedArrayBuffer + Atomics via kernel worker\n  // Data is transferred via SharedArrayBuffer (zero-copy)\n  // Synchronization via Atomics.wait/notify\n\n  // Buffer sizes for Tier 1 communication\n  private static readonly META_SIZE = 1024 * 64; // 64KB for metadata/results\n  private static readonly DEFAULT_DATA_SIZE = 1024 * 1024 * 10; // 10MB default buffer\n  private static readonly MAX_CHUNK_SIZE = 1024 * 1024 * 10; // 10MB max per chunk\n\n  // Reusable SharedArrayBuffer pool to prevent memory leaks\n  // SharedArrayBuffers are expensive to allocate and don't get GC'd quickly\n  private syncBufferPool: {\n    ctrl: SharedArrayBuffer;\n    meta: SharedArrayBuffer;\n    data: SharedArrayBuffer;\n    dataSize: number;\n  } | null = null;\n\n  private getSyncBuffers(requiredDataSize: number): {\n    ctrlBuffer: SharedArrayBuffer;\n    ctrl: Int32Array;\n    metaBuffer: SharedArrayBuffer;\n    dataBuffer: SharedArrayBuffer;\n  } {\n    // Reuse existing buffers if they're large enough\n    if (this.syncBufferPool && this.syncBufferPool.dataSize >= requiredDataSize) {\n      return {\n        ctrlBuffer: this.syncBufferPool.ctrl,\n        ctrl: new Int32Array(this.syncBufferPool.ctrl),\n        metaBuffer: this.syncBufferPool.meta,\n        dataBuffer: this.syncBufferPool.data,\n      };\n    }\n\n    // Allocate new buffers (or larger ones if needed)\n    const dataSize = Math.max(\n      OPFSFileSystem.DEFAULT_DATA_SIZE,\n      Math.min(requiredDataSize + 1024, 1024 * 1024 * 64) // Up to 64MB\n    );\n\n    const ctrlBuffer = new SharedArrayBuffer(4);\n    const metaBuffer = new SharedArrayBuffer(OPFSFileSystem.META_SIZE);\n    const dataBuffer = new SharedArrayBuffer(dataSize);\n\n    // Store in pool for reuse\n    this.syncBufferPool = {\n      ctrl: ctrlBuffer,\n      meta: metaBuffer,\n      data: dataBuffer,\n      dataSize,\n    };\n\n    return {\n      ctrlBuffer,\n      ctrl: new Int32Array(ctrlBuffer),\n      metaBuffer,\n      dataBuffer,\n    };\n  }\n\n  private syncCallTier1(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): KernelResult {\n    if (!this.syncKernel || !this.syncKernelReady) {\n      throw new Error('Sync kernel not initialized. Call initSync() first.');\n    }\n\n    // Path normalization: resolve and normalize to ensure consistent paths\n    // e.g., /foo/bar, foo/bar/, and /foo//bar all become /foo/bar\n    const absPath = path.normalize(path.resolve(filePath));\n\n    const data = payload?.data instanceof Uint8Array ? payload.data : null;\n    const dataSize = data?.length ?? 0;\n\n    // For large writes, use chunked approach\n    if (type === 'write' && data && dataSize > OPFSFileSystem.MAX_CHUNK_SIZE) {\n      return this.syncCallTier1Chunked(absPath, data);\n    }\n\n    // Get reusable SharedArrayBuffers from pool (prevents memory leaks)\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(dataSize);\n\n    // Initialize control signal to \"waiting\"\n    Atomics.store(ctrl, 0, 0);\n\n    // For write operations, copy data to SharedArrayBuffer\n    let dataLength = 0;\n    if (data) {\n      const view = new Uint8Array(dataBuffer);\n      view.set(data);\n      dataLength = data.length;\n    }\n\n    // Send command to kernel with SharedArrayBuffers\n    this.syncKernel.postMessage({\n      type,\n      path: absPath,\n      ctrlBuffer,\n      metaBuffer,\n      dataBuffer,\n      dataLength,\n      payload: payload ? { ...payload, data: undefined } : undefined,\n    });\n\n    // Block until kernel signals completion\n    const waitResult = Atomics.wait(ctrl, 0, 0, 30000);\n    if (waitResult === 'timed-out') {\n      throw new Error('Operation timed out');\n    }\n\n    const status = Atomics.load(ctrl, 0);\n\n    // Status codes:\n    // > 0: success, value indicates data length or result\n    // -1: error (error message in metaBuffer)\n    // -2: not found\n\n    if (status === -1) {\n      const metaView = new Uint8Array(metaBuffer);\n      let end = metaView.indexOf(0);\n      if (end === -1) end = OPFSFileSystem.META_SIZE;\n      const errorMsg = new TextDecoder().decode(metaView.slice(0, end));\n      throw mapErrorCode(errorMsg || 'Error', type, absPath);\n    }\n\n    if (status === -2) {\n      throw createENOENT(type, absPath);\n    }\n\n    // Parse result based on operation type\n    if (type === 'read') {\n      const bytesRead = status;\n      const bufferSize = dataBuffer.byteLength;\n\n      // If we filled the buffer completely, there might be more data\n      // Use stat to check total size and switch to chunked read if needed\n      if (bytesRead === bufferSize) {\n        const stat = this.syncStatTier1(absPath);\n        if (stat && stat.size > bytesRead) {\n          // File is larger than buffer, use chunked read from the beginning\n          return this.syncCallTier1ChunkedRead(absPath, stat.size);\n        }\n      }\n\n      const dataView = new Uint8Array(dataBuffer);\n      return { data: dataView.slice(0, bytesRead) };\n    }\n\n    if (type === 'stat') {\n      // Binary stat: [type:u8] [pad:3] [mode:u32] [size:f64] [mtimeMs:f64]\n      const view = new DataView(metaBuffer);\n      const typeVal = view.getUint8(0);\n      return {\n        type: typeVal === 0 ? 'file' : 'directory',\n        mode: view.getUint32(4, true),\n        size: view.getFloat64(8, true),\n        mtimeMs: view.getFloat64(16, true),\n      };\n    }\n\n    if (type === 'readdir') {\n      // Binary readdir: [count:u32] [len:u16 + utf8]...\n      const view = new DataView(metaBuffer);\n      const bytes = new Uint8Array(metaBuffer);\n      const count = view.getUint32(0, true);\n      const entries: string[] = [];\n      let offset = 4;\n      for (let i = 0; i < count; i++) {\n        const len = view.getUint16(offset, true);\n        offset += 2;\n        // Use slice() instead of subarray() to copy from SharedArrayBuffer (TextDecoder requires regular ArrayBuffer)\n        const name = new TextDecoder().decode(bytes.slice(offset, offset + len));\n        entries.push(name);\n        offset += len;\n      }\n      return { entries };\n    }\n\n    if (type === 'exists') {\n      return { exists: status === 1 };\n    }\n\n    return { success: status === 1 };\n  }\n\n  // Mutex for async operations to prevent buffer reuse race conditions\n  // Multiple concurrent Atomics.waitAsync calls would share the same buffer pool,\n  // causing data corruption when operations complete out of order\n  private asyncOperationPromise: Promise<void> = Promise.resolve();\n\n  // Async version of syncCallTier1 using Atomics.waitAsync (works on main thread)\n  // This allows the main thread to use the fast SharedArrayBuffer path without blocking\n  // IMPORTANT: Operations are serialized to prevent buffer reuse race conditions\n  private async syncCallTier1Async(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): Promise<KernelResult> {\n    // Serialize async operations to prevent buffer reuse race conditions\n    const previousOp = this.asyncOperationPromise;\n    let resolveCurrentOp: () => void;\n    this.asyncOperationPromise = new Promise(resolve => { resolveCurrentOp = resolve; });\n\n    try {\n      // Wait for previous operation to complete\n      await previousOp;\n      return await this.syncCallTier1AsyncImpl(type, filePath, payload);\n    } finally {\n      // Signal that this operation is complete\n      resolveCurrentOp!();\n    }\n  }\n\n  // Implementation of async Tier 1 call (called after serialization)\n  private async syncCallTier1AsyncImpl(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): Promise<KernelResult> {\n    if (!this.syncKernel || !this.syncKernelReady) {\n      throw new Error('Sync kernel not initialized. Call initSync() first.');\n    }\n\n    const absPath = path.normalize(path.resolve(filePath));\n    const data = payload?.data instanceof Uint8Array ? payload.data : null;\n    const dataSize = data?.length ?? 0;\n\n    // For large writes, use chunked approach (async version)\n    if (type === 'write' && data && dataSize > OPFSFileSystem.MAX_CHUNK_SIZE) {\n      return this.syncCallTier1ChunkedAsync(absPath, data);\n    }\n\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(dataSize);\n\n    Atomics.store(ctrl, 0, 0);\n\n    let dataLength = 0;\n    if (data) {\n      const view = new Uint8Array(dataBuffer);\n      view.set(data);\n      dataLength = data.length;\n    }\n\n    this.syncKernel.postMessage({\n      type,\n      path: absPath,\n      ctrlBuffer,\n      metaBuffer,\n      dataBuffer,\n      dataLength,\n      payload: payload ? { ...payload, data: undefined } : undefined,\n    });\n\n    // Use Atomics.waitAsync for non-blocking wait (works on main thread)\n    const waitResult = await Atomics.waitAsync(ctrl, 0, 0, 30000).value;\n    if (waitResult === 'timed-out') {\n      throw new Error('Operation timed out');\n    }\n\n    const status = Atomics.load(ctrl, 0);\n\n    if (status === -1) {\n      const metaView = new Uint8Array(metaBuffer);\n      let end = metaView.indexOf(0);\n      if (end === -1) end = OPFSFileSystem.META_SIZE;\n      const errorMsg = new TextDecoder().decode(metaView.slice(0, end));\n      throw mapErrorCode(errorMsg || 'Error', type, absPath);\n    }\n\n    if (status === -2) {\n      throw createENOENT(type, absPath);\n    }\n\n    // Parse result based on operation type\n    if (type === 'read') {\n      const bytesRead = status;\n      const bufferSize = dataBuffer.byteLength;\n\n      if (bytesRead === bufferSize) {\n        const stat = await this.syncStatTier1Async(absPath);\n        if (stat && stat.size > bytesRead) {\n          return this.syncCallTier1ChunkedReadAsync(absPath, stat.size);\n        }\n      }\n\n      const dataView = new Uint8Array(dataBuffer);\n      return { data: dataView.slice(0, bytesRead) };\n    }\n\n    if (type === 'stat') {\n      const view = new DataView(metaBuffer);\n      const typeVal = view.getUint8(0);\n      return {\n        type: typeVal === 0 ? 'file' : 'directory',\n        mode: view.getUint32(4, true),\n        size: view.getFloat64(8, true),\n        mtimeMs: view.getFloat64(16, true),\n      };\n    }\n\n    if (type === 'readdir') {\n      const view = new DataView(metaBuffer);\n      const bytes = new Uint8Array(metaBuffer);\n      const count = view.getUint32(0, true);\n      const entries: string[] = [];\n      let offset = 4;\n      for (let i = 0; i < count; i++) {\n        const len = view.getUint16(offset, true);\n        offset += 2;\n        // Use slice() instead of subarray() to copy from SharedArrayBuffer (TextDecoder requires regular ArrayBuffer)\n        const name = new TextDecoder().decode(bytes.slice(offset, offset + len));\n        entries.push(name);\n        offset += len;\n      }\n      return { entries };\n    }\n\n    if (type === 'exists') {\n      return { exists: status === 1 };\n    }\n\n    return { success: status === 1 };\n  }\n\n  // Async stat helper for main thread\n  // NOTE: Called from within syncCallTier1AsyncImpl, so uses impl directly to avoid deadlock\n  private async syncStatTier1Async(absPath: string): Promise<{ size: number } | null> {\n    try {\n      const result = await this.syncCallTier1AsyncImpl('stat', absPath);\n      return { size: result.size as number };\n    } catch {\n      return null;\n    }\n  }\n\n  // Async chunked write for main thread\n  private async syncCallTier1ChunkedAsync(\n    absPath: string,\n    data: Uint8Array\n  ): Promise<KernelResult> {\n    const totalSize = data.length;\n    let offset = 0;\n\n    while (offset < totalSize) {\n      const remaining = totalSize - offset;\n      const currentChunkSize = Math.min(remaining, OPFSFileSystem.MAX_CHUNK_SIZE);\n      const chunk = data.subarray(offset, offset + currentChunkSize);\n\n      const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(currentChunkSize);\n      Atomics.store(ctrl, 0, 0);\n\n      const view = new Uint8Array(dataBuffer);\n      view.set(chunk);\n\n      const isFirstChunk = offset === 0;\n      this.syncKernel!.postMessage({\n        type: isFirstChunk ? 'write' : 'append',\n        path: absPath,\n        ctrlBuffer,\n        metaBuffer,\n        dataBuffer,\n        dataLength: currentChunkSize,\n        payload: { flush: false },\n      });\n\n      const waitResult = await Atomics.waitAsync(ctrl, 0, 0, 30000).value;\n      if (waitResult === 'timed-out') {\n        throw new Error('Chunked write timed out');\n      }\n\n      const status = Atomics.load(ctrl, 0);\n      if (status === -1 || status === -2) {\n        throw createENOENT('write', absPath);\n      }\n\n      offset += currentChunkSize;\n    }\n\n    return { success: true };\n  }\n\n  // Async chunked read for main thread\n  private async syncCallTier1ChunkedReadAsync(\n    absPath: string,\n    totalSize: number\n  ): Promise<KernelResult> {\n    const result = new Uint8Array(totalSize);\n    let offset = 0;\n\n    while (offset < totalSize) {\n      const remaining = totalSize - offset;\n      const currentChunkSize = Math.min(remaining, OPFSFileSystem.MAX_CHUNK_SIZE);\n\n      const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(currentChunkSize);\n      Atomics.store(ctrl, 0, 0);\n\n      this.syncKernel!.postMessage({\n        type: 'readChunk',\n        path: absPath,\n        ctrlBuffer,\n        metaBuffer,\n        dataBuffer,\n        dataLength: 0,\n        payload: { offset, length: currentChunkSize },\n      });\n\n      const waitResult = await Atomics.waitAsync(ctrl, 0, 0, 30000).value;\n      if (waitResult === 'timed-out') {\n        throw new Error('Chunked read timed out');\n      }\n\n      const status = Atomics.load(ctrl, 0);\n      if (status === -1 || status === -2) {\n        throw createENOENT('read', absPath);\n      }\n\n      const bytesRead = status;\n      const dataView = new Uint8Array(dataBuffer);\n      result.set(dataView.subarray(0, bytesRead), offset);\n      offset += bytesRead;\n    }\n\n    return { data: result };\n  }\n\n  // Chunked write for files larger than MAX_CHUNK_SIZE\n  private syncCallTier1Chunked(\n    absPath: string,\n    data: Uint8Array\n  ): KernelResult {\n    const totalSize = data.length;\n    const chunkSize = OPFSFileSystem.MAX_CHUNK_SIZE;\n\n    // Reuse buffers from pool (prevents memory leaks)\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(chunkSize);\n    const dataView = new Uint8Array(dataBuffer);\n\n    let offset = 0;\n    while (offset < totalSize) {\n      const remaining = totalSize - offset;\n      const currentChunkSize = Math.min(chunkSize, remaining);\n      const chunk = data.subarray(offset, offset + currentChunkSize);\n\n      // Reset control signal\n      Atomics.store(ctrl, 0, 0);\n\n      // Copy chunk to SharedArrayBuffer\n      dataView.set(chunk);\n\n      // First chunk: truncate file (offset 0), subsequent chunks: append at offset\n      this.syncKernel!.postMessage({\n        type: 'write',\n        path: absPath,\n        ctrlBuffer,\n        metaBuffer,\n        dataBuffer,\n        dataLength: currentChunkSize,\n        payload: { offset }, // Kernel writes at this offset\n      });\n\n      // Wait for completion\n      const waitResult = Atomics.wait(ctrl, 0, 0, 60000); // Longer timeout for large chunks\n      if (waitResult === 'timed-out') {\n        throw new Error(`Chunked write timed out at offset ${offset}`);\n      }\n\n      const status = Atomics.load(ctrl, 0);\n      if (status === -1) {\n        const metaView = new Uint8Array(metaBuffer);\n        let end = metaView.indexOf(0);\n        if (end === -1) end = OPFSFileSystem.META_SIZE;\n        const errorMsg = new TextDecoder().decode(metaView.slice(0, end));\n        throw mapErrorCode(errorMsg || 'Error', 'write', absPath);\n      }\n      if (status === -2) {\n        throw createENOENT('write', absPath);\n      }\n\n      offset += currentChunkSize;\n    }\n\n    return { success: true };\n  }\n\n  // Chunked read for files larger than buffer size\n  private syncCallTier1ChunkedRead(\n    absPath: string,\n    totalSize: number\n  ): KernelResult {\n    const chunkSize = OPFSFileSystem.MAX_CHUNK_SIZE;\n\n    // Allocate result buffer on main thread\n    const result = new Uint8Array(totalSize);\n\n    // Reuse buffers from pool (prevents memory leaks)\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(chunkSize);\n\n    let offset = 0;\n    while (offset < totalSize) {\n      const remaining = totalSize - offset;\n      const currentChunkSize = Math.min(chunkSize, remaining);\n\n      // Reset control signal\n      Atomics.store(ctrl, 0, 0);\n\n      // Request chunk from kernel\n      this.syncKernel!.postMessage({\n        type: 'read',\n        path: absPath,\n        ctrlBuffer,\n        metaBuffer,\n        dataBuffer,\n        dataLength: 0,\n        payload: { offset, len: currentChunkSize },\n      });\n\n      // Wait for completion\n      const waitResult = Atomics.wait(ctrl, 0, 0, 60000);\n      if (waitResult === 'timed-out') {\n        throw new Error(`Chunked read timed out at offset ${offset}`);\n      }\n\n      const status = Atomics.load(ctrl, 0);\n      if (status === -1) {\n        const metaView = new Uint8Array(metaBuffer);\n        let end = metaView.indexOf(0);\n        if (end === -1) end = OPFSFileSystem.META_SIZE;\n        const errorMsg = new TextDecoder().decode(metaView.slice(0, end));\n        throw mapErrorCode(errorMsg || 'Error', 'read', absPath);\n      }\n      if (status === -2) {\n        throw createENOENT('read', absPath);\n      }\n\n      // Copy chunk from SharedArrayBuffer to result\n      const bytesRead = status;\n      const dataView = new Uint8Array(dataBuffer, 0, bytesRead);\n      result.set(dataView, offset);\n\n      offset += bytesRead;\n\n      // If we read less than requested, we've reached EOF\n      if (bytesRead < currentChunkSize) {\n        break;\n      }\n    }\n\n    return { data: result.subarray(0, offset) };\n  }\n\n  // Get file size via stat (used for chunked reads)\n  private syncStatTier1(absPath: string): { size: number } | null {\n    // Reuse buffers from pool (prevents memory leaks)\n    const { ctrlBuffer, ctrl, metaBuffer, dataBuffer } = this.getSyncBuffers(1024);\n\n    Atomics.store(ctrl, 0, 0);\n\n    this.syncKernel!.postMessage({\n      type: 'stat',\n      path: absPath,\n      ctrlBuffer,\n      metaBuffer,\n      dataBuffer,\n      dataLength: 0,\n    });\n\n    const waitResult = Atomics.wait(ctrl, 0, 0, 10000);\n    if (waitResult === 'timed-out') {\n      return null;\n    }\n\n    const status = Atomics.load(ctrl, 0);\n    if (status <= 0) {\n      return null;\n    }\n\n    // Binary stat: [type:u8] [pad:3] [mode:u32] [size:f64] [mtimeMs:f64]\n    const view = new DataView(metaBuffer);\n    return { size: view.getFloat64(8, true) };\n  }\n\n  private syncCall(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): KernelResult {\n    // Sync operations require SharedArrayBuffer + Atomics\n    // This requires crossOriginIsolated (COOP/COEP headers) and initSync() to be called\n    if (\n      isWorkerContext &&\n      typeof SharedArrayBuffer !== 'undefined' &&\n      this.syncKernelReady\n    ) {\n      return this.syncCallTier1(type, filePath, payload);\n    }\n\n    // No sync tier available - throw helpful error\n    throw new Error(\n      `Sync operations require crossOriginIsolated environment (COOP/COEP headers) and initSync() to be called. ` +\n      `Current state: crossOriginIsolated=${typeof crossOriginIsolated !== 'undefined' ? crossOriginIsolated : 'N/A'}, ` +\n      `isWorkerContext=${isWorkerContext}, syncKernelReady=${this.syncKernelReady}. ` +\n      `Use fs.promises.* for async operations that work everywhere.`\n    );\n  }\n\n  // --- Synchronous API (Node.js fs compatible) ---\n\n  readFileSync(filePath: string, options?: ReadOptions | Encoding | null): Uint8Array | string {\n    const encoding = typeof options === 'string' ? options : options?.encoding;\n    const result = this.syncCall('read', filePath);\n    if (!result.data) throw createENOENT('read', filePath);\n    return decodeData(result.data, encoding);\n  }\n\n  writeFileSync(filePath: string, data: Uint8Array | string, options?: WriteOptions | Encoding): void {\n    const opts = typeof options === 'string' ? { encoding: options } : options;\n    const encoded = encodeData(data, opts?.encoding);\n    // Pass flush option (defaults to true in kernel for safety)\n    this.syncCall('write', filePath, { data: encoded, flush: opts?.flush });\n    this.invalidateStat(filePath);\n  }\n\n  appendFileSync(filePath: string, data: Uint8Array | string, options?: WriteOptions | Encoding): void {\n    const encoding = typeof options === 'string' ? options : options?.encoding;\n    const encoded = encodeData(data, encoding);\n    this.syncCall('append', filePath, { data: encoded });\n    this.invalidateStat(filePath);\n  }\n\n  existsSync(filePath: string): boolean {\n    try {\n      const result = this.syncCall('exists', filePath);\n      return result.exists ?? false;\n    } catch {\n      return false;\n    }\n  }\n\n  mkdirSync(filePath: string, options?: MkdirOptions | number): string | undefined {\n    const recursive = typeof options === 'object' ? options?.recursive : false;\n    this.syncCall('mkdir', filePath, { recursive });\n    this.invalidateStat(filePath);\n    return recursive ? filePath : undefined;\n  }\n\n  rmdirSync(filePath: string, options?: RmdirOptions): void {\n    this.syncCall('rmdir', filePath, { recursive: options?.recursive });\n    if (options?.recursive) {\n      this.invalidateStatsUnder(filePath);\n    } else {\n      this.invalidateStat(filePath);\n    }\n  }\n\n  rmSync(filePath: string, options?: RmOptions): void {\n    try {\n      const result = this.syncCall('stat', filePath);\n      try {\n        if (result.isDirectory || result.type === 'directory') {\n          this.syncCall('rmdir', filePath, { recursive: options?.recursive });\n          if (options?.recursive) {\n            this.invalidateStatsUnder(filePath);\n          } else {\n            this.invalidateStat(filePath);\n          }\n        } else {\n          this.syncCall('unlink', filePath);\n          this.invalidateStat(filePath);\n        }\n      } catch (e) {\n        // Handle errors from rmdir/unlink with force option\n        if (!options?.force) throw e;\n      }\n    } catch (e) {\n      // Handle errors from stat with force option\n      if (!options?.force) throw e;\n    }\n  }\n\n  unlinkSync(filePath: string): void {\n    this.syncCall('unlink', filePath);\n    this.invalidateStat(filePath);\n  }\n\n  readdirSync(filePath: string, options?: ReaddirOptions | Encoding | null): string[] | Dirent[] {\n    const result = this.syncCall('readdir', filePath);\n    const entries = result.entries || [];\n\n    const opts = typeof options === 'object' ? options : { encoding: options };\n\n    if (opts?.withFileTypes) {\n      return entries.map((name) => {\n        try {\n          const stat = this.syncCall('stat', path.join(filePath, name));\n          // Check type first (from kernel result), fall back to isDirectory boolean\n          const isDir = stat.type === 'directory' || stat.isDirectory === true;\n          return createDirent(name, isDir);\n        } catch {\n          return createDirent(name, false);\n        }\n      });\n    }\n\n    return entries;\n  }\n\n  statSync(filePath: string): Stats {\n    const absPath = path.normalize(path.resolve(filePath));\n\n    // Check cache first\n    const cached = this.statCache.get(absPath);\n    if (cached) return cached;\n\n    const result = this.syncCall('stat', filePath);\n    // Check for both new format (type) and legacy format (isFile/isDirectory)\n    if (result.type === undefined && result.isFile === undefined && result.isDirectory === undefined) {\n      throw createENOENT('stat', filePath);\n    }\n    const stats = createStats(result);\n\n    // Cache the result\n    this.statCache.set(absPath, stats);\n    return stats;\n  }\n\n  lstatSync(filePath: string): Stats {\n    const stats = this.statSync(filePath);\n    // Check if it's a symlink and update the stats accordingly\n    if (stats.isFile() && this.isSymlinkSync(filePath)) {\n      return this.createSymlinkStats(stats);\n    }\n    return stats;\n  }\n\n  /**\n   * Create stats object for a symlink file.\n   */\n  private createSymlinkStats(baseStats: Stats): Stats {\n    return {\n      ...baseStats,\n      isFile: () => false,\n      isSymbolicLink: () => true,\n      // Symlink mode: 0o120777 (41471 decimal)\n      mode: 41471,\n    };\n  }\n\n  renameSync(oldPath: string, newPath: string): void {\n    this.syncCall('rename', oldPath, { newPath });\n    this.invalidateStat(oldPath);\n    this.invalidateStat(newPath);\n  }\n\n  copyFileSync(src: string, dest: string): void {\n    this.syncCall('copy', src, { newPath: dest });\n    this.invalidateStat(dest);\n  }\n\n  truncateSync(filePath: string, len = 0): void {\n    this.syncCall('truncate', filePath, { len });\n    this.invalidateStat(filePath);\n  }\n\n  /**\n   * Flush all pending writes to storage.\n   * Use this after writes with { flush: false } to ensure data is persisted.\n   */\n  flushSync(): void {\n    this.syncCall('flush', '/');\n  }\n\n  /**\n   * Alias for flushSync() - matches Node.js fdatasync behavior\n   */\n  fdatasyncSync(): void {\n    this.flushSync();\n  }\n\n  /**\n   * Purge all kernel caches (sync handles, directory handles).\n   * Use between major operations to ensure clean state.\n   */\n  purgeSync(): void {\n    this.syncCall('purge', '/');\n    this.statCache.clear();\n  }\n\n  /**\n   * Enable or disable debug tracing for handle operations.\n   * When enabled, logs handle cache hits, acquisitions, releases, and mode information.\n   * @param enabled - Whether to enable debug tracing\n   * @returns Debug state information including unsafeModeSupported and cache size\n   */\n  setDebugSync(enabled: boolean): { debugTrace: boolean; unsafeModeSupported: boolean; cacheSize: number } {\n    return this.syncCall('setDebug', '/', { enabled }) as unknown as { debugTrace: boolean; unsafeModeSupported: boolean; cacheSize: number };\n  }\n\n  /**\n   * Enable or disable debug tracing for handle operations (async version).\n   * When enabled, logs handle cache hits, acquisitions, releases, and mode information.\n   * @param enabled - Whether to enable debug tracing\n   * @returns Debug state information including unsafeModeSupported and cache size\n   */\n  async setDebug(enabled: boolean): Promise<{ debugTrace: boolean; unsafeModeSupported: boolean; cacheSize: number }> {\n    return this.asyncCall('setDebug', '/', { enabled }) as unknown as Promise<{ debugTrace: boolean; unsafeModeSupported: boolean; cacheSize: number }>;\n  }\n\n  accessSync(filePath: string, _mode?: number): void {\n    const exists = this.existsSync(filePath);\n    if (!exists) {\n      throw createENOENT('access', filePath);\n    }\n  }\n\n  // --- Low-level File Descriptor API ---\n  // For efficient packfile access (read specific offsets without loading entire file)\n\n  openSync(filePath: string, flags: string | number = 'r'): number {\n    // Verify file exists for read modes\n    const flagNum = typeof flags === 'string' ? this.parseFlags(flags) : flags;\n    const isReadOnly = (flagNum & constants.O_WRONLY) === 0 && (flagNum & constants.O_RDWR) === 0;\n\n    if (isReadOnly && !this.existsSync(filePath)) {\n      throw createENOENT('open', filePath);\n    }\n\n    const fd = this.nextFd++;\n    this.fdTable.set(fd, {\n      path: path.normalize(path.resolve(filePath)),\n      flags: flagNum,\n      position: 0,\n    });\n    return fd;\n  }\n\n  closeSync(fd: number): void {\n    if (!this.fdTable.has(fd)) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n    this.fdTable.delete(fd);\n  }\n\n  readSync(\n    fd: number,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number | null\n  ): number {\n    const entry = this.fdTable.get(fd);\n    if (!entry) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n\n    const readPos = position !== null ? position : entry.position;\n    const result = this.syncCall('read', entry.path, { offset: readPos, len: length });\n\n    if (!result.data) {\n      return 0; // EOF or error\n    }\n\n    // Copy data into the provided buffer at the specified offset\n    const bytesRead = Math.min(result.data.length, length);\n    buffer.set(result.data.subarray(0, bytesRead), offset);\n\n    // Update position if not using explicit position\n    if (position === null) {\n      entry.position += bytesRead;\n    }\n\n    return bytesRead;\n  }\n\n  writeSync(\n    fd: number,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number | null\n  ): number {\n    const entry = this.fdTable.get(fd);\n    if (!entry) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n\n    const writePos = position !== null ? position : entry.position;\n    const data = buffer.subarray(offset, offset + length);\n\n    // Use truncate: false to avoid truncating on positional writes\n    this.syncCall('write', entry.path, {\n      data,\n      offset: writePos,\n      truncate: false,\n    });\n\n    // Invalidate stat cache after write\n    this.invalidateStat(entry.path);\n\n    // Update position if not using explicit position\n    if (position === null) {\n      entry.position += length;\n    }\n\n    return length;\n  }\n\n  fstatSync(fd: number): Stats {\n    const entry = this.fdTable.get(fd);\n    if (!entry) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n    return this.statSync(entry.path);\n  }\n\n  ftruncateSync(fd: number, len = 0): void {\n    const entry = this.fdTable.get(fd);\n    if (!entry) {\n      throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n    }\n    this.truncateSync(entry.path, len);\n  }\n\n  /**\n   * Resolve a path to an absolute path.\n   * OPFS doesn't support symlinks, so this just normalizes the path.\n   */\n  realpathSync(filePath: string): string {\n    // Verify the path exists\n    this.accessSync(filePath);\n    return path.normalize(path.resolve(filePath));\n  }\n\n  /**\n   * Change file mode (no-op in OPFS - permissions not supported).\n   */\n  chmodSync(_filePath: string, _mode: number): void {\n    // No-op: OPFS doesn't support file permissions\n  }\n\n  /**\n   * Change file owner (no-op in OPFS - ownership not supported).\n   */\n  chownSync(_filePath: string, _uid: number, _gid: number): void {\n    // No-op: OPFS doesn't support file ownership\n  }\n\n  /**\n   * Change file timestamps (no-op in OPFS - timestamps are read-only).\n   */\n  utimesSync(_filePath: string, _atime: Date | number, _mtime: Date | number): void {\n    // No-op: OPFS doesn't support modifying timestamps\n  }\n\n  // Magic prefix for symlink files - must be unique enough to not appear in regular files\n  private static readonly SYMLINK_MAGIC = 'OPFS_SYMLINK_V1:';\n\n  /**\n   * Create a symbolic link.\n   * Emulated by storing target path in a special file format.\n   */\n  symlinkSync(target: string, filePath: string, _type?: string): void {\n    const content = OPFSFileSystem.SYMLINK_MAGIC + target;\n    this.writeFileSync(filePath, content);\n  }\n\n  /**\n   * Read a symbolic link target.\n   */\n  readlinkSync(filePath: string): string {\n    const content = this.readFileSync(filePath, { encoding: 'utf8' }) as string;\n    if (!content.startsWith(OPFSFileSystem.SYMLINK_MAGIC)) {\n      throw new FSError('EINVAL', -22, `EINVAL: invalid argument, readlink '${filePath}'`, 'readlink', filePath);\n    }\n    return content.slice(OPFSFileSystem.SYMLINK_MAGIC.length);\n  }\n\n  /**\n   * Check if a file is a symlink (sync).\n   */\n  private isSymlinkSync(filePath: string): boolean {\n    try {\n      const content = this.readFileSync(filePath, { encoding: 'utf8' }) as string;\n      return content.startsWith(OPFSFileSystem.SYMLINK_MAGIC);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if a file is a symlink (async).\n   */\n  private async isSymlinkAsync(filePath: string): Promise<boolean> {\n    try {\n      const content = await this.promises.readFile(filePath, { encoding: 'utf8' }) as string;\n      return content.startsWith(OPFSFileSystem.SYMLINK_MAGIC);\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Create a hard link.\n   * Emulated by copying the file (true hard links not supported in OPFS).\n   */\n  linkSync(existingPath: string, newPath: string): void {\n    // For symlinks, copy the symlink file itself (not the target)\n    this.copyFileSync(existingPath, newPath);\n  }\n\n  private parseFlags(flags: string): number {\n    switch (flags) {\n      case 'r': return constants.O_RDONLY;\n      case 'r+': return constants.O_RDWR;\n      case 'w': return constants.O_WRONLY | constants.O_CREAT | constants.O_TRUNC;\n      case 'w+': return constants.O_RDWR | constants.O_CREAT | constants.O_TRUNC;\n      case 'a': return constants.O_WRONLY | constants.O_CREAT | constants.O_APPEND;\n      case 'a+': return constants.O_RDWR | constants.O_CREAT | constants.O_APPEND;\n      default: return constants.O_RDONLY;\n    }\n  }\n\n  // --- Async Promises API ---\n  // When Tier 1 sync kernel is available, use it for better performance (wrapped in Promise)\n  // Otherwise fall back to async worker\n\n  // Helper: Use sync kernel if available (in worker context), otherwise async worker\n  private async fastCall(\n    type: string,\n    filePath: string,\n    payload?: Record<string, unknown>\n  ): Promise<KernelResult> {\n    // Use sync kernel when available for best performance\n    // Benefits of sync kernel:\n    // 1. SharedArrayBuffer zero-copy data transfer\n    // 2. Optimized sync handle caching\n    // 3. No postMessage serialization overhead\n    if (this.syncKernelReady) {\n      if (isWorkerContext) {\n        // In Worker: use blocking Atomics.wait (fastest)\n        return Promise.resolve(this.syncCallTier1(type, filePath, payload));\n      } else {\n        // Main thread: use Atomics.waitAsync (non-blocking but still fast)\n        return this.syncCallTier1Async(type, filePath, payload);\n      }\n    }\n    // Fallback to async worker\n    return this.asyncCall(type, filePath, payload);\n  }\n\n  promises: FileSystemPromises = {\n    readFile: async (filePath: string, options?: ReadOptions | Encoding | null) => {\n      // Validate path - isomorphic-git sometimes calls with no args\n      if (!filePath) {\n        throw createENOENT('read', filePath || '');\n      }\n      const encoding = typeof options === 'string' ? options : options?.encoding;\n\n      // Use sync kernel if available (faster than async worker)\n      if (this.syncKernelReady) {\n        if (isWorkerContext) {\n          // Worker: blocking wait (fastest)\n          const result = this.syncCallTier1('read', filePath);\n          if (!result.data) throw createENOENT('read', filePath);\n          return decodeData(result.data, encoding);\n        } else {\n          // Main thread: use Atomics.waitAsync (non-blocking)\n          const result = await this.syncCallTier1Async('read', filePath);\n          if (!result.data) throw createENOENT('read', filePath);\n          return decodeData(result.data, encoding);\n        }\n      }\n\n      // Fallback to async worker (no sync kernel) - ensures consistent read/write path\n      // Using asyncCall ensures reads go through same worker as writes,\n      // which is important for file locking and cache consistency\n      const result = await this.asyncCall('read', filePath);\n      if (!result.data) throw createENOENT('read', filePath);\n      return decodeData(result.data, encoding);\n    },\n\n    writeFile: async (filePath: string, data: Uint8Array | string, options?: WriteOptions | Encoding) => {\n      const opts = typeof options === 'string' ? { encoding: options } : options;\n      const encoded = encodeData(data, opts?.encoding);\n      await this.fastCall('write', filePath, { data: encoded, flush: opts?.flush });\n      this.invalidateStat(filePath);\n    },\n\n    appendFile: async (filePath: string, data: Uint8Array | string, options?: WriteOptions | Encoding) => {\n      const opts = typeof options === 'string' ? { encoding: options } : options;\n      const encoded = encodeData(data, opts?.encoding);\n      await this.fastCall('append', filePath, { data: encoded, flush: opts?.flush });\n      this.invalidateStat(filePath);\n    },\n\n    mkdir: async (filePath: string, options?: MkdirOptions | number) => {\n      const recursive = typeof options === 'object' ? options?.recursive : false;\n      await this.fastCall('mkdir', filePath, { recursive });\n      return recursive ? filePath : undefined;\n    },\n\n    rmdir: async (filePath: string, options?: RmdirOptions) => {\n      await this.fastCall('rmdir', filePath, { recursive: options?.recursive });\n    },\n\n    rm: async (filePath: string, options?: RmOptions) => {\n      try {\n        const result = await this.fastCall('stat', filePath);\n        try {\n          if (result.isDirectory || result.type === 'directory') {\n            await this.fastCall('rmdir', filePath, { recursive: options?.recursive });\n            if (options?.recursive) {\n              this.invalidateStatsUnder(filePath);\n            } else {\n              this.invalidateStat(filePath);\n            }\n          } else {\n            await this.fastCall('unlink', filePath);\n            this.invalidateStat(filePath);\n          }\n        } catch (e) {\n          // Handle errors from rmdir/unlink with force option\n          if (!options?.force) throw e;\n        }\n      } catch (e) {\n        // Handle errors from stat with force option\n        if (!options?.force) throw e;\n      }\n    },\n\n    unlink: async (filePath: string) => {\n      await this.fastCall('unlink', filePath);\n    },\n\n    readdir: async (filePath: string, options?: ReaddirOptions | Encoding | null) => {\n      const result = await this.fastCall('readdir', filePath);\n      const entries = result.entries || [];\n      const opts = typeof options === 'object' ? options : { encoding: options };\n\n      if (opts?.withFileTypes) {\n        const dirents: Dirent[] = [];\n        for (const name of entries) {\n          try {\n            const stat = await this.fastCall('stat', path.join(filePath, name));\n            // Check type first (from kernel result), fall back to isDirectory boolean\n            const isDir = stat.type === 'directory' || stat.isDirectory === true;\n            dirents.push(createDirent(name, isDir));\n          } catch {\n            dirents.push(createDirent(name, false));\n          }\n        }\n        return dirents;\n      }\n\n      return entries;\n    },\n\n    stat: async (filePath: string) => {\n      const result = await this.fastCall('stat', filePath);\n      return createStats(result);\n    },\n\n    access: async (filePath: string, _mode?: number) => {\n      const result = await this.fastCall('exists', filePath);\n      if (!result.exists) {\n        throw createENOENT('access', filePath);\n      }\n    },\n\n    rename: async (oldFilePath: string, newFilePath: string) => {\n      await this.fastCall('rename', oldFilePath, { newPath: path.resolve(newFilePath) });\n    },\n\n    copyFile: async (srcPath: string, destPath: string) => {\n      await this.fastCall('copy', srcPath, { newPath: path.resolve(destPath) });\n    },\n\n    truncate: async (filePath: string, len = 0) => {\n      await this.fastCall('truncate', filePath, { len });\n      this.invalidateStat(filePath);\n    },\n\n    lstat: async (filePath: string) => {\n      const result = await this.fastCall('stat', filePath);\n      const stats = createStats(result);\n      // Check if it's a symlink\n      if (stats.isFile()) {\n        const isSymlink = await this.isSymlinkAsync(filePath);\n        if (isSymlink) {\n          return this.createSymlinkStats(stats);\n        }\n      }\n      return stats;\n    },\n\n    realpath: async (filePath: string) => {\n      // Verify the path exists\n      await this.promises.access(filePath);\n      return path.normalize(path.resolve(filePath));\n    },\n\n    exists: async (filePath: string) => {\n      try {\n        const result = await this.fastCall('exists', filePath);\n        return result.exists ?? false;\n      } catch {\n        return false;\n      }\n    },\n\n    chmod: async (_filePath: string, _mode: number) => {\n      // No-op: OPFS doesn't support file permissions\n    },\n\n    chown: async (_filePath: string, _uid: number, _gid: number) => {\n      // No-op: OPFS doesn't support file ownership\n    },\n\n    utimes: async (_filePath: string, _atime: Date | number, _mtime: Date | number) => {\n      // No-op: OPFS doesn't support modifying timestamps\n    },\n\n    symlink: async (target: string, filePath: string, _type?: string) => {\n      const content = OPFSFileSystem.SYMLINK_MAGIC + target;\n      await this.promises.writeFile(filePath, content);\n    },\n\n    readlink: async (filePath: string): Promise<string> => {\n      const content = await this.promises.readFile(filePath, { encoding: 'utf8' }) as string;\n      if (!content.startsWith(OPFSFileSystem.SYMLINK_MAGIC)) {\n        throw new FSError('EINVAL', -22, `EINVAL: invalid argument, readlink '${filePath}'`, 'readlink', filePath);\n      }\n      return content.slice(OPFSFileSystem.SYMLINK_MAGIC.length);\n    },\n\n    link: async (existingPath: string, newPath: string) => {\n      // Emulate hard link by copying the file\n      await this.promises.copyFile(existingPath, newPath);\n    },\n\n    open: async (filePath: string, flags: string | number = 'r', _mode?: number): Promise<FileHandle> => {\n      // Use async existence check instead of sync to work in main thread\n      const flagNum = typeof flags === 'string' ? this.parseFlags(flags) : flags;\n      const isReadOnly = (flagNum & constants.O_WRONLY) === 0 && (flagNum & constants.O_RDWR) === 0;\n\n      if (isReadOnly) {\n        const exists = await this.promises.exists(filePath);\n        if (!exists) {\n          throw createENOENT('open', filePath);\n        }\n      }\n\n      const fd = this.nextFd++;\n      this.fdTable.set(fd, {\n        path: path.normalize(path.resolve(filePath)),\n        flags: flagNum,\n        position: 0,\n      });\n      return this.createFileHandle(fd, filePath);\n    },\n\n    opendir: async (dirPath: string): Promise<Dir> => {\n      return this.createDir(dirPath);\n    },\n\n    mkdtemp: async (prefix: string): Promise<string> => {\n      const suffix = Math.random().toString(36).substring(2, 8);\n      const tmpDir = `${prefix}${suffix}`;\n      await this.promises.mkdir(tmpDir, { recursive: true });\n      return tmpDir;\n    },\n\n    watch: (filePath: string, options?: WatchOptions): AsyncIterable<WatchEventType> => {\n      return this.createAsyncWatcher(filePath, options);\n    },\n\n    /**\n     * Flush all pending writes to storage.\n     * Use after writes with { flush: false } to ensure data is persisted.\n     */\n    flush: async () => {\n      await this.fastCall('flush', '/');\n    },\n\n    /**\n     * Purge all kernel caches.\n     * Use between major operations to ensure clean state.\n     */\n    purge: async () => {\n      await this.fastCall('purge', '/');\n      this.statCache.clear();\n    },\n  };\n\n  /**\n   * Async flush - use after promises.writeFile with { flush: false }\n   */\n  async flush(): Promise<void> {\n    await this.fastCall('flush', '/');\n  }\n\n  /**\n   * Async purge - clears all kernel caches\n   */\n  async purge(): Promise<void> {\n    await this.fastCall('purge', '/');\n    this.statCache.clear();\n  }\n\n  /**\n   * Release all cached file handles.\n   * Call this before expecting external tools (OPFS Explorer, browser console, etc.)\n   * to modify files. This allows external access without waiting for the idle timeout.\n   * Unlike purge(), this only releases file handles without clearing directory caches.\n   */\n  async releaseAllHandles(): Promise<void> {\n    await this.fastCall('releaseAllHandles', '/');\n  }\n\n  /**\n   * Release a specific file's handle.\n   * Use this when you know a specific file needs to be externally modified.\n   */\n  async releaseHandle(filePath: string): Promise<void> {\n    await this.fastCall('releaseHandle', filePath);\n  }\n\n  // Constants\n  constants = constants;\n\n  // --- FileHandle Implementation ---\n\n  private createFileHandle(fd: number, filePath: string): FileHandle {\n    const self = this;\n    const absPath = path.normalize(path.resolve(filePath));\n\n    return {\n      fd,\n\n      async read(buffer: Uint8Array, offset = 0, length?: number, position: number | null = null): Promise<{ bytesRead: number; buffer: Uint8Array }> {\n        const len = length ?? buffer.length - offset;\n        const entry = self.fdTable.get(fd);\n        if (!entry) throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n\n        const readPos = position !== null ? position : entry.position;\n        const result = await self.fastCall('read', absPath, { offset: readPos, len });\n\n        if (!result.data) {\n          return { bytesRead: 0, buffer };\n        }\n\n        const bytesRead = Math.min(result.data.length, len);\n        buffer.set(result.data.subarray(0, bytesRead), offset);\n\n        if (position === null) {\n          entry.position += bytesRead;\n        }\n\n        return { bytesRead, buffer };\n      },\n\n      async write(buffer: Uint8Array, offset = 0, length?: number, position: number | null = null): Promise<{ bytesWritten: number; buffer: Uint8Array }> {\n        const len = length ?? buffer.length - offset;\n        const entry = self.fdTable.get(fd);\n        if (!entry) throw new FSError('EBADF', -9, `bad file descriptor: ${fd}`);\n\n        const writePos = position !== null ? position : entry.position;\n        const data = buffer.subarray(offset, offset + len);\n\n        await self.fastCall('write', absPath, { data, offset: writePos, truncate: false });\n        self.invalidateStat(absPath);\n\n        if (position === null) {\n          entry.position += len;\n        }\n\n        return { bytesWritten: len, buffer };\n      },\n\n      async readFile(options?: ReadOptions | Encoding | null): Promise<Uint8Array | string> {\n        return self.promises.readFile(absPath, options);\n      },\n\n      async writeFile(data: Uint8Array | string, options?: WriteOptions | Encoding): Promise<void> {\n        return self.promises.writeFile(absPath, data, options);\n      },\n\n      async truncate(len = 0): Promise<void> {\n        await self.fastCall('truncate', absPath, { len });\n        self.invalidateStat(absPath);\n      },\n\n      async stat(): Promise<Stats> {\n        return self.promises.stat(absPath);\n      },\n\n      async sync(): Promise<void> {\n        await self.fastCall('flush', '/');\n      },\n\n      async datasync(): Promise<void> {\n        await self.fastCall('flush', '/');\n      },\n\n      async close(): Promise<void> {\n        self.fdTable.delete(fd);\n      },\n    };\n  }\n\n  // --- Dir Implementation ---\n\n  private createDir(dirPath: string): Dir {\n    const self = this;\n    const absPath = path.normalize(path.resolve(dirPath));\n    let entries: string[] | null = null;\n    let index = 0;\n    let closed = false;\n\n    const loadEntries = async () => {\n      if (entries === null) {\n        const result = await self.fastCall('readdir', absPath);\n        entries = result.entries || [];\n      }\n    };\n\n    const dir: Dir = {\n      path: absPath,\n\n      async read(): Promise<Dirent | null> {\n        if (closed) throw new FSError('EBADF', -9, 'Directory handle was closed');\n        await loadEntries();\n        if (index >= entries!.length) return null;\n\n        const name = entries![index++];\n        try {\n          const stat = await self.fastCall('stat', path.join(absPath, name));\n          const isDir = stat.type === 'directory' || stat.isDirectory === true;\n          return createDirent(name, isDir);\n        } catch {\n          return createDirent(name, false);\n        }\n      },\n\n      async close(): Promise<void> {\n        closed = true;\n        entries = null;\n      },\n\n      [Symbol.asyncIterator](): AsyncIterableIterator<Dirent> {\n        const iterator: AsyncIterableIterator<Dirent> = {\n          next: async (): Promise<IteratorResult<Dirent>> => {\n            const dirent = await dir.read();\n            if (dirent === null) {\n              return { done: true, value: undefined };\n            }\n            return { done: false, value: dirent };\n          },\n          [Symbol.asyncIterator]() {\n            return this;\n          },\n        };\n        return iterator;\n      },\n    };\n\n    return dir;\n  }\n\n  // --- Watch Implementation (Native FileSystemObserver with polling fallback) ---\n\n  private watchedFiles = new Map<string, { interval?: ReturnType<typeof setInterval>; observer?: FileSystemObserverInterface; listeners: Set<WatchFileListener>; lastStat: Stats | null }>();\n\n  // Check if native FileSystemObserver is available\n  private static readonly hasNativeObserver = typeof globalThis.FileSystemObserver !== 'undefined';\n\n  // Get OPFS directory handle for a path\n  private async getDirectoryHandle(dirPath: string, create = false): Promise<FileSystemDirectoryHandle> {\n    const parts = dirPath.split('/').filter(Boolean);\n    let current = await navigator.storage.getDirectory();\n    for (const part of parts) {\n      current = await current.getDirectoryHandle(part, { create });\n    }\n    return current;\n  }\n\n  // Get OPFS file handle for a path\n  private async getFileHandle(filePath: string, create = false): Promise<FileSystemFileHandle> {\n    const parts = filePath.split('/').filter(Boolean);\n    const fileName = parts.pop();\n    if (!fileName) throw new Error('Invalid file path');\n\n    let current = await navigator.storage.getDirectory();\n    for (const part of parts) {\n      current = await current.getDirectoryHandle(part, { create });\n    }\n    return current.getFileHandle(fileName, { create });\n  }\n\n  // Convert FileSystemObserver change type to Node.js event type\n  private mapChangeType(type: FileSystemChangeRecord['type']): 'rename' | 'change' {\n    switch (type) {\n      case 'appeared':\n      case 'disappeared':\n      case 'moved':\n        return 'rename';\n      case 'modified':\n        return 'change';\n      default:\n        return 'change';\n    }\n  }\n\n  private createAsyncWatcher(filePath: string, options?: WatchOptions): AsyncIterable<WatchEventType> {\n    const absPath = path.normalize(path.resolve(filePath));\n\n    // Use native FileSystemObserver if available\n    if (OPFSFileSystem.hasNativeObserver) {\n      return this.createNativeAsyncWatcher(absPath, options);\n    }\n\n    // Fallback to polling\n    return this.createPollingAsyncWatcher(absPath, options);\n  }\n\n  private createNativeAsyncWatcher(absPath: string, options?: WatchOptions): AsyncIterable<WatchEventType> {\n    const self = this;\n\n    return {\n      [Symbol.asyncIterator](): AsyncIterableIterator<WatchEventType> {\n        const eventQueue: WatchEventType[] = [];\n        let resolveNext: ((value: IteratorResult<WatchEventType>) => void) | null = null;\n        let observer: FileSystemObserverInterface | null = null;\n        let aborted = false;\n        let initialized = false;\n\n        // Handle abort signal\n        if (options?.signal) {\n          options.signal.addEventListener('abort', () => {\n            aborted = true;\n            observer?.disconnect();\n            if (resolveNext) {\n              resolveNext({ done: true, value: undefined });\n              resolveNext = null;\n            }\n          });\n        }\n\n        const callback: FileSystemObserverCallback = (records) => {\n          for (const record of records) {\n            if (record.type === 'errored' || record.type === 'unknown') continue;\n\n            const filename = record.relativePathComponents.length > 0\n              ? record.relativePathComponents[record.relativePathComponents.length - 1]\n              : path.basename(absPath);\n\n            const event: WatchEventType = {\n              eventType: self.mapChangeType(record.type),\n              filename,\n            };\n\n            if (resolveNext) {\n              resolveNext({ done: false, value: event });\n              resolveNext = null;\n            } else {\n              eventQueue.push(event);\n            }\n          }\n        };\n\n        const init = async () => {\n          if (initialized) return;\n          initialized = true;\n\n          try {\n            observer = new globalThis.FileSystemObserver!(callback);\n            const stat = await self.promises.stat(absPath);\n            const handle = stat.isDirectory()\n              ? await self.getDirectoryHandle(absPath)\n              : await self.getFileHandle(absPath);\n            await observer.observe(handle, { recursive: options?.recursive });\n          } catch (e) {\n            // If native observer fails, we should return done\n            aborted = true;\n          }\n        };\n\n        const iterator: AsyncIterableIterator<WatchEventType> = {\n          async next(): Promise<IteratorResult<WatchEventType>> {\n            if (aborted) {\n              return { done: true, value: undefined };\n            }\n\n            await init();\n\n            if (aborted) {\n              return { done: true, value: undefined };\n            }\n\n            // Return queued event if available\n            if (eventQueue.length > 0) {\n              return { done: false, value: eventQueue.shift()! };\n            }\n\n            // Wait for next event\n            return new Promise(resolve => {\n              resolveNext = resolve;\n            });\n          },\n          [Symbol.asyncIterator]() {\n            return this;\n          },\n        };\n        return iterator;\n      },\n    };\n  }\n\n  private createPollingAsyncWatcher(absPath: string, options?: WatchOptions): AsyncIterable<WatchEventType> {\n    const self = this;\n    const interval = 1000;\n\n    return {\n      [Symbol.asyncIterator](): AsyncIterableIterator<WatchEventType> {\n        let lastMtimeMs: number | null = null;\n        let lastEntries: Set<string> | null = null;\n        let aborted = false;\n        let pollTimeout: ReturnType<typeof setTimeout> | null = null;\n\n        if (options?.signal) {\n          options.signal.addEventListener('abort', () => {\n            aborted = true;\n            if (pollTimeout) clearTimeout(pollTimeout);\n          });\n        }\n\n        const checkForChanges = async (): Promise<WatchEventType | null> => {\n          if (aborted) return null;\n\n          try {\n            const stat = await self.promises.stat(absPath);\n\n            if (stat.isDirectory()) {\n              const entries = await self.promises.readdir(absPath) as string[];\n              const currentEntries = new Set(entries);\n\n              if (lastEntries === null) {\n                lastEntries = currentEntries;\n                return null;\n              }\n\n              for (const entry of currentEntries) {\n                if (!lastEntries.has(entry)) {\n                  lastEntries = currentEntries;\n                  return { eventType: 'rename', filename: entry };\n                }\n              }\n\n              for (const entry of lastEntries) {\n                if (!currentEntries.has(entry)) {\n                  lastEntries = currentEntries;\n                  return { eventType: 'rename', filename: entry };\n                }\n              }\n\n              lastEntries = currentEntries;\n            } else {\n              if (lastMtimeMs === null) {\n                lastMtimeMs = stat.mtimeMs;\n                return null;\n              }\n\n              if (stat.mtimeMs !== lastMtimeMs) {\n                lastMtimeMs = stat.mtimeMs;\n                return { eventType: 'change', filename: path.basename(absPath) };\n              }\n            }\n          } catch {\n            if (lastMtimeMs !== null || lastEntries !== null) {\n              lastMtimeMs = null;\n              lastEntries = null;\n              return { eventType: 'rename', filename: path.basename(absPath) };\n            }\n          }\n\n          return null;\n        };\n\n        const iterator: AsyncIterableIterator<WatchEventType> = {\n          async next(): Promise<IteratorResult<WatchEventType>> {\n            if (aborted) {\n              return { done: true, value: undefined };\n            }\n\n            while (!aborted) {\n              const event = await checkForChanges();\n              if (event) {\n                return { done: false, value: event };\n              }\n\n              await new Promise<void>(resolve => {\n                pollTimeout = setTimeout(resolve, interval);\n              });\n            }\n\n            return { done: true, value: undefined };\n          },\n          [Symbol.asyncIterator]() {\n            return this;\n          },\n        };\n        return iterator;\n      },\n    };\n  }\n\n  /**\n   * Watch a file or directory for changes.\n   * Uses native FileSystemObserver when available, falls back to polling.\n   */\n  watch(filePath: string, options: WatchOptions | WatchListener = {}, listener?: WatchListener): FSWatcher {\n    const absPath = path.normalize(path.resolve(filePath));\n    const opts = typeof options === 'function' ? {} : options;\n    const cb = typeof options === 'function' ? options : listener;\n\n    // Use native FileSystemObserver if available\n    if (OPFSFileSystem.hasNativeObserver) {\n      return this.createNativeWatcher(absPath, opts, cb);\n    }\n\n    // Fallback to polling\n    return this.createPollingWatcher(absPath, cb);\n  }\n\n  private createNativeWatcher(absPath: string, opts: WatchOptions, cb?: WatchListener): FSWatcher {\n    const self = this;\n    let observer: FileSystemObserverInterface | null = null;\n    let closed = false;\n\n    const callback: FileSystemObserverCallback = async (records) => {\n      if (closed) return;\n\n      // Release all file handles before notifying callbacks\n      // This allows external tools to immediately access/modify files after changes\n      await self.releaseAllHandles();\n\n      for (const record of records) {\n        if (record.type === 'errored' || record.type === 'unknown') continue;\n\n        const filename = record.relativePathComponents.length > 0\n          ? record.relativePathComponents[record.relativePathComponents.length - 1]\n          : path.basename(absPath);\n\n        cb?.(self.mapChangeType(record.type), filename);\n      }\n    };\n\n    // Initialize observer asynchronously\n    (async () => {\n      if (closed) return;\n      try {\n        observer = new globalThis.FileSystemObserver!(callback);\n        const stat = await self.promises.stat(absPath);\n        const handle = stat.isDirectory()\n          ? await self.getDirectoryHandle(absPath)\n          : await self.getFileHandle(absPath);\n        await observer.observe(handle, { recursive: opts.recursive });\n      } catch {\n        // Silently fail - watcher will just not work\n      }\n    })();\n\n    const watcher: FSWatcher = {\n      close: () => {\n        closed = true;\n        observer?.disconnect();\n      },\n      ref: () => watcher,\n      unref: () => watcher,\n    };\n\n    return watcher;\n  }\n\n  private createPollingWatcher(absPath: string, cb?: WatchListener): FSWatcher {\n    const interval = 1000;\n    let lastMtimeMs: number | null = null;\n    let lastEntries: Set<string> | null = null;\n    let closed = false;\n\n    const poll = async () => {\n      if (closed) return;\n\n      try {\n        const stat = await this.promises.stat(absPath);\n\n        if (stat.isDirectory()) {\n          const entries = await this.promises.readdir(absPath) as string[];\n          const currentEntries = new Set(entries);\n\n          if (lastEntries !== null) {\n            // Check for changes\n            let hasChanges = false;\n            const added: string[] = [];\n            const removed: string[] = [];\n            for (const entry of currentEntries) {\n              if (!lastEntries.has(entry)) {\n                added.push(entry);\n                hasChanges = true;\n              }\n            }\n            for (const entry of lastEntries) {\n              if (!currentEntries.has(entry)) {\n                removed.push(entry);\n                hasChanges = true;\n              }\n            }\n            // Release handles before notifying callbacks\n            if (hasChanges) {\n              await this.releaseAllHandles();\n              for (const entry of added) cb?.('rename', entry);\n              for (const entry of removed) cb?.('rename', entry);\n            }\n          }\n          lastEntries = currentEntries;\n        } else {\n          if (lastMtimeMs !== null && stat.mtimeMs !== lastMtimeMs) {\n            // Release handles before notifying callbacks\n            await this.releaseAllHandles();\n            cb?.('change', path.basename(absPath));\n          }\n          lastMtimeMs = stat.mtimeMs;\n        }\n      } catch {\n        if (lastMtimeMs !== null || lastEntries !== null) {\n          // Release handles before notifying callbacks\n          await this.releaseAllHandles();\n          cb?.('rename', path.basename(absPath));\n          lastMtimeMs = null;\n          lastEntries = null;\n        }\n      }\n    };\n\n    const intervalId = setInterval(poll, interval);\n    poll();\n\n    const watcher: FSWatcher = {\n      close: () => {\n        closed = true;\n        clearInterval(intervalId);\n      },\n      ref: () => watcher,\n      unref: () => watcher,\n    };\n\n    return watcher;\n  }\n\n  /**\n   * Watch a file for changes using native FileSystemObserver or stat polling.\n   */\n  watchFile(filePath: string, options: WatchFileOptions | WatchFileListener = {}, listener?: WatchFileListener): StatWatcher {\n    const absPath = path.normalize(path.resolve(filePath));\n    const opts = typeof options === 'function' ? {} : options;\n    const cb = typeof options === 'function' ? options : listener;\n    const interval = opts.interval ?? 5007;\n\n    let lastStat: Stats | null = null;\n    let closed = false;\n    let observer: FileSystemObserverInterface | undefined;\n\n    // Polling function used as fallback or primary\n    const poll = async () => {\n      if (closed) return;\n\n      try {\n        const stat = await this.promises.stat(absPath);\n        if (lastStat !== null) {\n          if (stat.mtimeMs !== lastStat.mtimeMs || stat.size !== lastStat.size) {\n            // Release handles before notifying callbacks\n            await this.releaseAllHandles();\n            cb?.(stat, lastStat);\n          }\n        }\n        lastStat = stat;\n      } catch {\n        const emptyStat = createStats({ type: 'file', size: 0, mtimeMs: 0, mode: 0 });\n        if (lastStat !== null) {\n          // Release handles before notifying callbacks\n          await this.releaseAllHandles();\n          cb?.(emptyStat, lastStat);\n        }\n        lastStat = emptyStat;\n      }\n    };\n\n    // Try native observer first, fall back to polling\n    if (OPFSFileSystem.hasNativeObserver && cb) {\n      const self = this;\n\n      const observerCallback: FileSystemObserverCallback = async () => {\n        if (closed) return;\n        // Release handles before notifying callbacks\n        await self.releaseAllHandles();\n        try {\n          const stat = await self.promises.stat(absPath);\n          if (lastStat !== null && (stat.mtimeMs !== lastStat.mtimeMs || stat.size !== lastStat.size)) {\n            cb(stat, lastStat);\n          }\n          lastStat = stat;\n        } catch {\n          const emptyStat = createStats({ type: 'file', size: 0, mtimeMs: 0, mode: 0 });\n          if (lastStat !== null) {\n            cb(emptyStat, lastStat);\n          }\n          lastStat = emptyStat;\n        }\n      };\n\n      (async () => {\n        if (closed) return;\n        try {\n          // Get initial stat\n          lastStat = await self.promises.stat(absPath);\n\n          observer = new globalThis.FileSystemObserver!(observerCallback);\n          const handle = await self.getFileHandle(absPath);\n          await observer.observe(handle);\n        } catch {\n          // Native observer failed, fall back to polling\n          if (!closed && !this.watchedFiles.get(absPath)?.interval) {\n            const entry = this.watchedFiles.get(absPath);\n            if (entry) {\n              entry.interval = setInterval(poll, interval);\n            }\n          }\n        }\n      })();\n\n      if (!this.watchedFiles.has(absPath)) {\n        this.watchedFiles.set(absPath, {\n          observer,\n          listeners: new Set(),\n          lastStat: null,\n        });\n      }\n      this.watchedFiles.get(absPath)!.listeners.add(cb);\n    } else {\n      // Polling fallback (no native observer available)\n      if (!this.watchedFiles.has(absPath)) {\n        this.watchedFiles.set(absPath, {\n          interval: setInterval(poll, interval),\n          listeners: new Set(),\n          lastStat: null,\n        });\n      }\n      if (cb) this.watchedFiles.get(absPath)!.listeners.add(cb);\n\n      poll();\n    }\n\n    const watcher: StatWatcher = {\n      ref: () => watcher,\n      unref: () => watcher,\n    };\n\n    return watcher;\n  }\n\n  /**\n   * Stop watching a file.\n   */\n  unwatchFile(filePath: string, listener?: WatchFileListener): void {\n    const absPath = path.normalize(path.resolve(filePath));\n    const entry = this.watchedFiles.get(absPath);\n\n    if (entry) {\n      if (listener) {\n        entry.listeners.delete(listener);\n        if (entry.listeners.size === 0) {\n          if (entry.interval) clearInterval(entry.interval);\n          if (entry.observer) entry.observer.disconnect();\n          this.watchedFiles.delete(absPath);\n        }\n      } else {\n        if (entry.interval) clearInterval(entry.interval);\n        if (entry.observer) entry.observer.disconnect();\n        this.watchedFiles.delete(absPath);\n      }\n    }\n  }\n\n  // --- Stream Implementation ---\n\n  /**\n   * Create a readable stream for a file.\n   */\n  createReadStream(filePath: string, options?: ReadStreamOptions | string): ReadableStream<Uint8Array> {\n    const opts = typeof options === 'string' ? { encoding: options as Encoding } : options ?? {};\n    const absPath = path.normalize(path.resolve(filePath));\n    const start = opts.start ?? 0;\n    const end = opts.end;\n    const highWaterMark = opts.highWaterMark ?? 64 * 1024;\n\n    let position = start;\n    let closed = false;\n    const self = this;\n\n    return new ReadableStream<Uint8Array>({\n      async pull(controller) {\n        if (closed) {\n          controller.close();\n          return;\n        }\n\n        try {\n          const maxRead = end !== undefined ? Math.min(highWaterMark, end - position + 1) : highWaterMark;\n          if (maxRead <= 0) {\n            controller.close();\n            closed = true;\n            return;\n          }\n\n          const result = await self.fastCall('read', absPath, { offset: position, len: maxRead });\n\n          if (!result.data || result.data.length === 0) {\n            controller.close();\n            closed = true;\n            return;\n          }\n\n          controller.enqueue(result.data);\n          position += result.data.length;\n\n          if (end !== undefined && position > end) {\n            controller.close();\n            closed = true;\n          }\n        } catch (e) {\n          controller.error(e);\n          closed = true;\n        }\n      },\n\n      cancel() {\n        closed = true;\n      },\n    });\n  }\n\n  /**\n   * Create a writable stream for a file.\n   */\n  createWriteStream(filePath: string, options?: WriteStreamOptions | string): WritableStream<Uint8Array> {\n    const opts = typeof options === 'string' ? { encoding: options as Encoding } : options ?? {};\n    const absPath = path.normalize(path.resolve(filePath));\n    const start = opts.start ?? 0;\n    const shouldFlush = opts.flush !== false;\n\n    let position = start;\n    let initialized = false;\n    const self = this;\n\n    return new WritableStream<Uint8Array>({\n      async write(chunk) {\n        // Truncate on first write if starting from beginning\n        if (!initialized && start === 0) {\n          await self.fastCall('write', absPath, { data: chunk, offset: 0, flush: false });\n          position = chunk.length;\n          initialized = true;\n        } else {\n          await self.fastCall('write', absPath, { data: chunk, offset: position, truncate: false, flush: false });\n          position += chunk.length;\n          initialized = true;\n        }\n        self.invalidateStat(absPath);\n      },\n\n      async close() {\n        if (shouldFlush) {\n          await self.fastCall('flush', '/');\n        }\n      },\n\n      async abort() {\n        // Nothing to clean up\n      },\n    });\n  }\n\n  // --- Sync methods for opendir and mkdtemp ---\n\n  /**\n   * Open a directory for iteration (sync).\n   */\n  opendirSync(dirPath: string): Dir {\n    return this.createDir(dirPath);\n  }\n\n  /**\n   * Create a unique temporary directory (sync).\n   */\n  mkdtempSync(prefix: string): string {\n    const suffix = Math.random().toString(36).substring(2, 8);\n    const tmpDir = `${prefix}${suffix}`;\n    this.mkdirSync(tmpDir, { recursive: true });\n    return tmpDir;\n  }\n}\n","/**\n * OPFS-FS: Battle-tested OPFS-based Node.js fs polyfill\n *\n * Provides a Node.js-compatible filesystem API that works in browsers using OPFS.\n *\n * Features:\n * - Synchronous API: fs.readFileSync, fs.writeFileSync, etc. (requires crossOriginIsolated)\n * - Async Promises API: fs.promises.readFile, fs.promises.writeFile, etc.\n * - Cross-tab safety via navigator.locks\n *\n * Performance Tiers:\n * - Tier 1 (Sync): SharedArrayBuffer + Atomics - requires crossOriginIsolated (COOP/COEP headers)\n * - Tier 2 (Async): Promises API - always available\n *\n * @example\n * ```typescript\n * import { fs } from '@componentor/fs';\n *\n * // Sync API (requires crossOriginIsolated)\n * fs.writeFileSync('/hello.txt', 'Hello World!');\n * const data = fs.readFileSync('/hello.txt', 'utf8');\n *\n * // Async API (always available)\n * await fs.promises.writeFile('/async.txt', 'Async data');\n * const content = await fs.promises.readFile('/async.txt', 'utf8');\n * ```\n */\n\nexport { OPFSFileSystem } from './filesystem.js';\nexport { constants } from './constants.js';\nexport { FSError, createENOENT, createEEXIST, createEISDIR, createENOTDIR, createENOTEMPTY, createEACCES, createEINVAL, mapErrorCode } from './errors.js';\nexport * as path from './path.js';\nexport type {\n  Stats,\n  Dirent,\n  ReadOptions,\n  WriteOptions,\n  MkdirOptions,\n  RmdirOptions,\n  RmOptions,\n  ReaddirOptions,\n  Encoding,\n  FileSystemPromises,\n  PathLike,\n} from './types.js';\n\nimport { OPFSFileSystem } from './filesystem.js';\n\n// Default singleton instance\nexport const fs = new OPFSFileSystem();\n\n// Default export for convenience\nexport default fs;\n"]}