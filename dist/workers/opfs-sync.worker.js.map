{"version":3,"sources":["../../src/src/workers/opfs-sync.worker.ts"],"sourcesContent":["/**\n * OPFS Sync Worker — optional bidirectional mirror between VFS and real OPFS.\n *\n * Spawned by the server worker when opfsSync is enabled.\n * Receives mutation events from the server, writes them to real OPFS files.\n * Uses FileSystemObserver to detect external OPFS changes and syncs them back.\n */\n\ninterface SyncEvent {\n  op: 'write' | 'delete' | 'mkdir' | 'rename';\n  path: string;\n  newPath?: string;\n  data?: ArrayBuffer;\n  ts: number;\n}\n\nlet serverPort: MessagePort;\nlet mirrorRoot: FileSystemDirectoryHandle;\n\n// Normalize path: ensure leading /, collapse //, strip trailing /\nfunction normalizePath(p: string): string {\n  if (p.charCodeAt(0) !== 47) p = '/' + p;\n  if (p.length > 1 && p.charCodeAt(p.length - 1) === 47) p = p.slice(0, -1);\n  if (p.indexOf('//') !== -1) p = p.replace(/\\/\\/+/g, '/');\n  return p;\n}\n\n// Echo suppression — two structures:\n//\n// pendingPaths (Set): paths currently in the queue or being processed.\n//   Added on enqueue, removed after OPFS operation completes.\n//   No timeout — stays as long as the item is in the queue.\n//   Prevents false externals when queue takes >1s (e.g., 500-file batches).\n//\n// completedPaths (Map<path, timestamp>): paths recently written by us.\n//   Added when processing completes, removed ONLY by periodic cleanup.\n//   Grace window catches delayed/batched observer events after processing.\n//\n// Parent path check (opt-in): if /dir was deleted by us, /dir/file disappearing\n// is also our echo (recursive removeEntry fires per-child events).\n// ONLY used for 'disappeared' events — NOT for 'appeared'/'modified', since\n// creating /dir doesn't mean /dir/new-file appearing is our echo.\n\nconst pendingPaths = new Set<string>();\nconst completedPaths = new Map<string, number>();\nconst GRACE_MS = 3000;\n\nfunction trackPending(path: string): void {\n  pendingPaths.add(normalizePath(path));\n}\n\nfunction untrackPending(path: string): void {\n  pendingPaths.delete(normalizePath(path));\n}\n\nfunction trackCompleted(path: string): void {\n  completedPaths.set(normalizePath(path), Date.now());\n}\n\nfunction isOurEcho(path: string, checkParents = false): boolean {\n  path = normalizePath(path);\n  const now = Date.now();\n\n  // Check exact path\n  if (pendingPaths.has(path)) return true;\n  const ts = completedPaths.get(path);\n  if (ts && now - ts < GRACE_MS) return true;\n\n  // Walk up parent paths — ONLY for 'disappeared' events.\n  // Handles recursive delete cascading: removeEntry(dir, {recursive:true})\n  // fires individual 'disappeared' for every child file.\n  // NOT used for 'appeared'/'modified' — a parent being tracked doesn't mean\n  // a new file appearing inside it is our echo (could be genuinely external).\n  if (checkParents) {\n    let parent = path;\n    while (true) {\n      const slash = parent.lastIndexOf('/');\n      if (slash <= 0) break;\n      parent = parent.substring(0, slash);\n      if (pendingPaths.has(parent)) return true;\n      const pts = completedPaths.get(parent);\n      if (pts && now - pts < GRACE_MS) return true;\n    }\n  }\n\n  return false;\n}\n\n// Periodic cleanup — the ONLY way completedPaths entries get removed\nsetInterval(() => {\n  const cutoff = Date.now() - GRACE_MS;\n  for (const [p, ts] of completedPaths) {\n    if (ts < cutoff) completedPaths.delete(p);\n  }\n}, 5000);\n\n// Event queue — process one at a time, in order\nconst queue: SyncEvent[] = [];\nlet processing = false;\n\nfunction enqueue(event: SyncEvent): void {\n  trackPending(event.path);\n  if (event.op === 'rename' && event.newPath) {\n    trackPending(event.newPath);\n  }\n  queue.push(event);\n  if (!processing) processNext();\n}\n\nasync function processNext(): Promise<void> {\n  if (queue.length === 0) {\n    processing = false;\n    return;\n  }\n  processing = true;\n\n  const event = queue.shift()!;\n\n  try {\n    switch (event.op) {\n      case 'write':\n        if (event.data && event.data.byteLength > 0) {\n          await writeToOPFS(event.path, event.data);\n        } else {\n          console.warn('[opfs-sync] write skipped — no data for:', event.path);\n        }\n        break;\n      case 'delete':\n        await deleteFromOPFS(event.path);\n        break;\n      case 'mkdir':\n        await mkdirInOPFS(event.path);\n        break;\n      case 'rename':\n        await renameInOPFS(event.path, event.newPath!);\n        break;\n    }\n  } catch (err) {\n    console.warn('[opfs-sync] mirror failed:', event.op, event.path, err);\n  }\n\n  // Move from pending → completed (starts grace window for delayed observer events)\n  untrackPending(event.path);\n  trackCompleted(event.path);\n  if (event.op === 'rename' && event.newPath) {\n    untrackPending(event.newPath);\n    trackCompleted(event.newPath);\n  }\n\n  processNext();\n}\n\nasync function ensureParentDirs(path: string): Promise<FileSystemDirectoryHandle> {\n  const parts = path.split('/').filter(Boolean);\n  parts.pop(); // Remove filename\n\n  let dir = mirrorRoot;\n  for (const part of parts) {\n    dir = await dir.getDirectoryHandle(part, { create: true });\n  }\n  return dir;\n}\n\nfunction basename(path: string): string {\n  const parts = path.split('/');\n  return parts[parts.length - 1];\n}\n\nasync function writeToOPFS(path: string, data: ArrayBuffer): Promise<void> {\n  const dir = await ensureParentDirs(path);\n  const name = basename(path);\n  const fileHandle = await dir.getFileHandle(name, { create: true });\n  // Use createSyncAccessHandle for reliable writes in Worker context\n  // (createWritable can silently fail in nested workers for OPFS files)\n  const accessHandle = await fileHandle.createSyncAccessHandle();\n  try {\n    accessHandle.truncate(0);\n    accessHandle.write(new Uint8Array(data), { at: 0 });\n    accessHandle.flush();\n  } finally {\n    accessHandle.close();\n  }\n}\n\nasync function deleteFromOPFS(path: string): Promise<void> {\n  try {\n    const dir = await navigateToParent(path);\n    await dir.removeEntry(basename(path), { recursive: true });\n  } catch {\n    // File may not exist in OPFS — that's fine\n  }\n}\n\nasync function mkdirInOPFS(path: string): Promise<void> {\n  let dir = mirrorRoot;\n  const parts = path.split('/').filter(Boolean);\n  for (const part of parts) {\n    dir = await dir.getDirectoryHandle(part, { create: true });\n  }\n}\n\nasync function renameInOPFS(oldPath: string, newPath: string): Promise<void> {\n  // OPFS doesn't have a native rename — copy + delete\n  try {\n    const oldDir = await navigateToParent(oldPath);\n    const oldHandle = await oldDir.getFileHandle(basename(oldPath));\n    const file = await oldHandle.getFile();\n    const data = await file.arrayBuffer();\n\n    const newDir = await ensureParentDirs(newPath);\n    const newHandle = await newDir.getFileHandle(basename(newPath), { create: true });\n    const accessHandle = await newHandle.createSyncAccessHandle();\n    try {\n      accessHandle.truncate(0);\n      accessHandle.write(new Uint8Array(data), { at: 0 });\n      accessHandle.flush();\n    } finally {\n      accessHandle.close();\n    }\n\n    await oldDir.removeEntry(basename(oldPath));\n  } catch (err) {\n    console.warn('[opfs-sync] rename failed:', oldPath, '→', newPath, err);\n  }\n}\n\nasync function navigateToParent(path: string): Promise<FileSystemDirectoryHandle> {\n  const parts = path.split('/').filter(Boolean);\n  parts.pop();\n\n  let dir = mirrorRoot;\n  for (const part of parts) {\n    dir = await dir.getDirectoryHandle(part);\n  }\n  return dir;\n}\n\n// ========== FileSystemObserver for external changes ==========\n\nfunction setupObserver(): void {\n  if (typeof FileSystemObserver === 'undefined') {\n    console.warn('[opfs-sync] FileSystemObserver not available — external changes will not be detected');\n    return;\n  }\n\n  console.log('[opfs-sync] Setting up FileSystemObserver on mirrorRoot:', mirrorRoot.name || '(opfs-root)');\n\n  const observer = new FileSystemObserver((records) => {\n    //console.log(`[opfs-sync] observer fired: ${records.length} record(s), pending=${pendingPaths.size}, completed=${completedPaths.size}`);\n    for (const record of records) {\n      const path = normalizePath('/' + record.relativePathComponents.join('/'));\n\n      // Skip VFS binary file and internal files\n      if (path === '/.vfs.bin' || path === '/.vfs' || path.startsWith('/.vfs')) continue;\n\n      // Echo suppression — check parents only for 'disappeared' (recursive delete cascading)\n      const isDelete = record.type === 'disappeared';\n      if (isOurEcho(path, isDelete)) {\n        //console.log('[opfs-sync] suppressed (echo):', record.type, path);\n        continue;\n      }\n\n      //console.log('[opfs-sync] external:', record.type, path);\n      switch (record.type) {\n        case 'appeared':\n        case 'modified':\n          syncExternalChange(path, record.changedHandle);\n          break;\n        case 'disappeared':\n          syncExternalDelete(path);\n          break;\n        case 'moved': {\n          const from = normalizePath('/' + record.relativePathMovedFrom!.join('/'));\n          //console.log('[opfs-sync] external: moved from', from, '→', path);\n          syncExternalRename(from, path);\n          break;\n        }\n      }\n    }\n  });\n\n  observer.observe(mirrorRoot, { recursive: true });\n}\n\nasync function syncExternalChange(path: string, handle: FileSystemHandle | null): Promise<void> {\n  try {\n    if (!handle || handle.kind !== 'file') return;\n\n    const fileHandle = handle as FileSystemFileHandle;\n    const file = await fileHandle.getFile();\n    const data = await file.arrayBuffer();\n\n    serverPort.postMessage({\n      op: 'external-write',\n      path,\n      data,\n      ts: Date.now(),\n    }, [data]);\n  } catch (err) {\n    // File may have been deleted between observer event and our read, or\n    // a sync access handle may be holding the lock — either is fine to skip\n    console.warn('[opfs-sync] external change read failed:', path, err);\n  }\n}\n\nfunction syncExternalDelete(path: string): void {\n  serverPort.postMessage({\n    op: 'external-delete',\n    path,\n    ts: Date.now(),\n  });\n}\n\nfunction syncExternalRename(oldPath: string, newPath: string): void {\n  serverPort.postMessage({\n    op: 'external-rename',\n    path: oldPath,\n    newPath,\n    ts: Date.now(),\n  });\n}\n\n// ========== Initialization ==========\n\nself.onmessage = async (e: MessageEvent) => {\n  const msg = e.data;\n\n  if (msg.type === 'init') {\n    serverPort = e.ports[0];\n    mirrorRoot = await navigator.storage.getDirectory();\n\n    // Navigate to mirror root if specified\n    if (msg.root && msg.root !== '/') {\n      const segments = msg.root.split('/').filter(Boolean);\n      for (const segment of segments) {\n        mirrorRoot = await mirrorRoot.getDirectoryHandle(segment, { create: true });\n      }\n    }\n\n    console.log('[opfs-sync] initialized with root:', msg.root || '/', 'mirrorRoot.name:', mirrorRoot.name || '(opfs-root)');\n\n    // Set up FileSystemObserver\n    setupObserver();\n\n    // Listen for events from server\n    serverPort.onmessage = (ev: MessageEvent) => {\n      const event = ev.data as SyncEvent;\n      enqueue(event);\n    };\n    serverPort.start();\n\n    (self as unknown as Worker).postMessage({ type: 'ready' });\n    return;\n  }\n};\n"],"mappings":"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","names":[]}