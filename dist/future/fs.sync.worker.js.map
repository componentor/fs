{"version":3,"sources":["../../future/buffer-shim-bundled.js","../../node_modules/events/events.js","../../future/src/fs.sync.worker.ts","../../future/src/fs.vfs.ts","../../future/src/vfs/index.ts","../../future/src/vfs/state.ts","../../future/src/app-constants.ts","../../future/src/vfs/events.ts","../../future/src/vfs/path.ts","../../future/src/vfs/event-sab.ts","../../future/src/vfs/event-constants.ts","../../future/src/vfs/event-metrics.ts","../../future/src/vfs/index-ops.ts","../../future/src/vfs/compact.ts","../../future/src/vfs/files.ts","../../future/src/vfs/opfs-sync-queue.ts","../../future/src/config.ts","../../future/src/vfs/symlinks.ts","../../future/src/vfs/dirs.ts","../../future/src/vfs/metadata.ts","../../future/src/vfs/watch.ts","../../future/src/vfs/sync.ts","../../future/src/vfs/traverse.ts","../../future/src/vfs/import.ts","../../future/src/vfs/init.ts","../../future/src/fs.sync.loop.ts","../../future/src/fs.sync.methods.ts","../../future/src/methods/readFile.ts","../../future/src/classes/index.ts","../../future/src/classes/Stats.ts","../../future/src/constants.ts","../../future/src/classes/Dirent.ts","../../future/src/classes/Dir.ts","../../future/src/classes/FileHandle.ts","../../future/src/classes/ReadStream.ts","../../future/src/classes/WriteStream.ts","../../future/src/classes/FSError.ts","../../future/src/methods/writeFile.ts","../../future/src/methods/exists.ts","../../future/src/methods/unlink.ts","../../future/src/methods/mkdir.ts","../../future/src/methods/rmdir.ts","../../future/src/methods/readdir.ts","../../future/src/methods/stat.ts","../../future/src/methods/rename.ts","../../future/src/methods/copyFile.ts","../../future/src/methods/appendFile.ts","../../future/src/methods/rm.ts","../../future/src/methods/access.ts","../../future/src/methods/chmod.ts","../../future/src/methods/chown.ts","../../future/src/methods/lchmod.ts","../../future/src/methods/lchown.ts","../../future/src/methods/link.ts","../../future/src/methods/symlink.ts","../../future/src/methods/readlink.ts","../../future/src/methods/truncate.ts","../../future/src/methods/mkdtemp.ts","../../future/src/methods/realpath.ts","../../future/src/methods/utimes.ts","../../future/src/methods/lutimes.ts","../../future/src/methods/cp.ts","../../future/src/methods/opendir.ts","../../future/src/methods/statfs.ts","../../future/src/methods/open.ts","../../future/src/methods/close.ts","../../future/src/methods/read.ts","../../future/src/methods/write.ts","../../future/src/methods/fstat.ts","../../future/src/methods/fsync.ts","../../future/src/methods/fdatasync.ts","../../future/src/methods/ftruncate.ts","../../future/src/methods/fchmod.ts","../../future/src/methods/fchown.ts","../../future/src/methods/futimes.ts","../../future/src/methods/readv.ts","../../future/src/methods/writev.ts","../../future/src/fs.sync.queue.ts","../../future/src/fs.sab-utils.ts"],"sourcesContent":["var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\n\n// ../node_modules/base64-js/index.js\nvar require_base64_js = __commonJS({\n  \"../node_modules/base64-js/index.js\"(exports) {\n    \"use strict\";\n    exports.byteLength = byteLength;\n    exports.toByteArray = toByteArray;\n    exports.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for (i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    var i;\n    var len;\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      }\n      var validLen = b64.indexOf(\"=\");\n      if (validLen === -1) validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join(\"\");\n    }\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\"\n        );\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(\n          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\"\n        );\n      }\n      return parts.join(\"\");\n    }\n  }\n});\n\n// ../node_modules/ieee754/index.js\nvar require_ieee754 = __commonJS({\n  \"../node_modules/ieee754/index.js\"(exports) {\n    exports.read = function(buffer, offset, isLE, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE ? nBytes - 1 : 0;\n      var d = isLE ? -1 : 1;\n      var s = buffer[offset + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {\n      }\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n      var e, m, c;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE ? 0 : nBytes - 1;\n      var d = isLE ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n      }\n      e = e << mLen | m;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n      }\n      buffer[offset + i - d] |= s * 128;\n    };\n  }\n});\n\n// ../node_modules/buffer/index.js\nvar require_buffer = __commonJS({\n  \"../node_modules/buffer/index.js\"(exports) {\n    \"use strict\";\n    var base64 = require_base64_js();\n    var ieee754 = require_ieee754();\n    var customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer3;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    var K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\n        \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n      );\n    }\n    function typedArraySupport() {\n      try {\n        const arr = new Uint8Array(1);\n        const proto = { foo: function() {\n          return 42;\n        } };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    Object.defineProperty(Buffer3.prototype, \"parent\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer3.isBuffer(this)) return void 0;\n        return this.buffer;\n      }\n    });\n    Object.defineProperty(Buffer3.prototype, \"offset\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer3.isBuffer(this)) return void 0;\n        return this.byteOffset;\n      }\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      const buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer3.prototype);\n      return buf;\n    }\n    function Buffer3(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    Buffer3.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n        );\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      }\n      const valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer3.from(valueOf, encodingOrOffset, length);\n      }\n      const b = fromObject(value);\n      if (b) return b;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer3.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n      }\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value\n      );\n    }\n    Buffer3.from = function(value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer3, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    Buffer3.alloc = function(size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    Buffer3.allocUnsafe = function(size) {\n      return allocUnsafe(size);\n    };\n    Buffer3.allocUnsafeSlow = function(size) {\n      return allocUnsafe(size);\n    };\n    function fromString(string, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer3.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      const length = byteLength(string, encoding) | 0;\n      let buf = createBuffer(length);\n      const actual = buf.write(string, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    function fromArrayLike(array) {\n      const length = array.length < 0 ? 0 : checked(array.length) | 0;\n      const buf = createBuffer(length);\n      for (let i = 0; i < length; i += 1) {\n        buf[i] = array[i] & 255;\n      }\n      return buf;\n    }\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    function fromArrayBuffer(array, byteOffset, length) {\n      if (byteOffset < 0 || array.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      let buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array, byteOffset);\n      } else {\n        buf = new Uint8Array(array, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer3.prototype);\n      return buf;\n    }\n    function fromObject(obj) {\n      if (Buffer3.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer3.alloc(+length);\n    }\n    Buffer3.isBuffer = function isBuffer(b) {\n      return b != null && b._isBuffer === true && b !== Buffer3.prototype;\n    };\n    Buffer3.compare = function compare(a, b) {\n      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);\n      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);\n      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      }\n      if (a === b) return 0;\n      let x = a.length;\n      let y = b.length;\n      for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n          x = a[i];\n          y = b[i];\n          break;\n        }\n      }\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    };\n    Buffer3.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    };\n    Buffer3.concat = function concat(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer3.alloc(0);\n      }\n      let i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      const buffer = Buffer3.allocUnsafe(length);\n      let pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer.length) {\n            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);\n            buf.copy(buffer, pos);\n          } else {\n            Uint8Array.prototype.set.call(\n              buffer,\n              buf,\n              pos\n            );\n          }\n        } else if (!Buffer3.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer;\n    };\n    function byteLength(string, encoding) {\n      if (Buffer3.isBuffer(string)) {\n        return string.length;\n      }\n      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n        return string.byteLength;\n      }\n      if (typeof string !== \"string\") {\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string\n        );\n      }\n      const len = string.length;\n      const mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0) return 0;\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes(string).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes(string).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer3.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      let loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding) encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer3.prototype._isBuffer = true;\n    function swap(b, n, m) {\n      const i = b[n];\n      b[n] = b[m];\n      b[m] = i;\n    }\n    Buffer3.prototype.swap16 = function swap16() {\n      const len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (let i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    };\n    Buffer3.prototype.swap32 = function swap32() {\n      const len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (let i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    };\n    Buffer3.prototype.swap64 = function swap64() {\n      const len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (let i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    };\n    Buffer3.prototype.toString = function toString() {\n      const length = this.length;\n      if (length === 0) return \"\";\n      if (arguments.length === 0) return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;\n    Buffer3.prototype.equals = function equals(b) {\n      if (!Buffer3.isBuffer(b)) throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b) return true;\n      return Buffer3.compare(this, b) === 0;\n    };\n    Buffer3.prototype.inspect = function inspect() {\n      let str = \"\";\n      const max = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max) str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    };\n    if (customInspectSymbol) {\n      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;\n    }\n    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer3.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer3.isBuffer(target)) {\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target\n        );\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target) return 0;\n      let x = thisEnd - thisStart;\n      let y = end - start;\n      const len = Math.min(x, y);\n      const thisCopy = this.slice(thisStart, thisEnd);\n      const targetCopy = target.slice(start, end);\n      for (let i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n      if (x < y) return -1;\n      if (y < x) return 1;\n      return 0;\n    };\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      if (buffer.length === 0) return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n      }\n      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n      if (byteOffset >= buffer.length) {\n        if (dir) return -1;\n        else byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir) byteOffset = 0;\n        else return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer3.from(val, encoding);\n      }\n      if (Buffer3.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      let indexSize = 1;\n      let arrLength = arr.length;\n      let valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      let i;\n      if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1) foundIndex = i;\n            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1) i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j = 0; j < valLength; j++) {\n            if (read(arr, i + j) !== read(val, j)) {\n              found = false;\n              break;\n            }\n          }\n          if (found) return i;\n        }\n      }\n      return -1;\n    }\n    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n    function hexWrite(buf, string, offset, length) {\n      offset = Number(offset) || 0;\n      const remaining = buf.length - offset;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      const strLen = string.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      let i;\n      for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed)) return i;\n        buf[offset + i] = parsed;\n      }\n      return i;\n    }\n    function utf8Write(buf, string, offset, length) {\n      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    function asciiWrite(buf, string, offset, length) {\n      return blitBuffer(asciiToBytes(string), buf, offset, length);\n    }\n    function base64Write(buf, string, offset, length) {\n      return blitBuffer(base64ToBytes(string), buf, offset, length);\n    }\n    function ucs2Write(buf, string, offset, length) {\n      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n    }\n    Buffer3.prototype.write = function write(string, offset, length, encoding) {\n      if (offset === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset = 0;\n      } else if (length === void 0 && typeof offset === \"string\") {\n        encoding = offset;\n        length = this.length;\n        offset = 0;\n      } else if (isFinite(offset)) {\n        offset = offset >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0) encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      }\n      const remaining = this.length - offset;\n      if (length === void 0 || length > remaining) length = remaining;\n      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding) encoding = \"utf8\";\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string, offset, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string, offset, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string, offset, length);\n          case \"base64\":\n            return base64Write(this, string, offset, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string, offset, length);\n          default:\n            if (loweredCase) throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n    Buffer3.prototype.toJSON = function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      const res = [];\n      let i = start;\n      while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          let secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    var MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      const len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      let res = \"\";\n      let i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(\n          String,\n          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n        );\n      }\n      return res;\n    }\n    function asciiSlice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    function latin1Slice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    function hexSlice(buf, start, end) {\n      const len = buf.length;\n      if (!start || start < 0) start = 0;\n      if (!end || end < 0 || end > len) end = len;\n      let out = \"\";\n      for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    function utf16leSlice(buf, start, end) {\n      const bytes = buf.slice(start, end);\n      let res = \"\";\n      for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    Buffer3.prototype.slice = function slice(start, end) {\n      const len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0) start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0) end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start) end = start;\n      const newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer3.prototype);\n      return newBuf;\n    };\n    function checkOffset(offset, ext, length) {\n      if (offset % 1 !== 0 || offset < 0) throw new RangeError(\"offset is not uint\");\n      if (offset + ext > length) throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      return val;\n    };\n    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset, byteLength2, this.length);\n      }\n      let val = this[offset + --byteLength2];\n      let mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset + --byteLength2] * mul;\n      }\n      return val;\n    };\n    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      return this[offset];\n    };\n    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] | this[offset + 1] << 8;\n    };\n    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      return this[offset] << 8 | this[offset + 1];\n    };\n    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;\n    };\n    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n    };\n    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;\n      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;\n      return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    });\n    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;\n      return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    });\n    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let val = this[offset];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) checkOffset(offset, byteLength2, this.length);\n      let i = byteLength2;\n      let mul = 1;\n      let val = this[offset + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 1, this.length);\n      if (!(this[offset] & 128)) return this[offset];\n      return (255 - this[offset] + 1) * -1;\n    };\n    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      const val = this[offset] | this[offset + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 2, this.length);\n      const val = this[offset + 1] | this[offset] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n    };\n    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n    };\n    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);\n      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);\n    });\n    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {\n      offset = offset >>> 0;\n      validateNumber(offset, \"offset\");\n      const first = this[offset];\n      const last = this[offset + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset, this.length - 8);\n      }\n      const val = (first << 24) + // Overflow\n      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];\n      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);\n    });\n    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, true, 23, 4);\n    };\n    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 4, this.length);\n      return ieee754.read(this, offset, false, 23, 4);\n    };\n    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, true, 52, 8);\n    };\n    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n      offset = offset >>> 0;\n      if (!noAssert) checkOffset(offset, 8, this.length);\n      return ieee754.read(this, offset, false, 52, 8);\n    };\n    function checkInt(buf, value, offset, ext, max, min) {\n      if (!Buffer3.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n    }\n    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let mul = 1;\n      let i = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset, byteLength2, maxBytes, 0);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset + i] = value / mul & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset + 3] = value >>> 24;\n      this[offset + 2] = value >>> 16;\n      this[offset + 1] = value >>> 8;\n      this[offset] = value & 255;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    function wrtBigUInt64LE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      lo = lo >> 8;\n      buf[offset++] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      hi = hi >> 8;\n      buf[offset++] = hi;\n      return offset;\n    }\n    function wrtBigUInt64BE(buf, value, offset, min, max) {\n      checkIntBI(value, min, max, buf, offset, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset + 7] = lo;\n      lo = lo >> 8;\n      buf[offset + 6] = lo;\n      lo = lo >> 8;\n      buf[offset + 5] = lo;\n      lo = lo >> 8;\n      buf[offset + 4] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset + 3] = hi;\n      hi = hi >> 8;\n      buf[offset + 2] = hi;\n      hi = hi >> 8;\n      buf[offset + 1] = hi;\n      hi = hi >> 8;\n      buf[offset] = hi;\n      return offset + 8;\n    }\n    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = 0;\n      let mul = 1;\n      let sub = 0;\n      this[offset] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset, byteLength2, limit - 1, -limit);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      let sub = 0;\n      this[offset + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset + byteLength2;\n    };\n    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);\n      if (value < 0) value = 255 + value + 1;\n      this[offset] = value & 255;\n      return offset + 1;\n    };\n    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);\n      this[offset] = value >>> 8;\n      this[offset + 1] = value & 255;\n      return offset + 2;\n    };\n    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      this[offset] = value & 255;\n      this[offset + 1] = value >>> 8;\n      this[offset + 2] = value >>> 16;\n      this[offset + 3] = value >>> 24;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);\n      if (value < 0) value = 4294967295 + value + 1;\n      this[offset] = value >>> 24;\n      this[offset + 1] = value >>> 16;\n      this[offset + 2] = value >>> 8;\n      this[offset + 3] = value & 255;\n      return offset + 4;\n    };\n    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {\n      return wrtBigUInt64LE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {\n      return wrtBigUInt64BE(this, value, offset, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function checkIEEE754(buf, value, offset, ext, max, min) {\n      if (offset + ext > buf.length) throw new RangeError(\"Index out of range\");\n      if (offset < 0) throw new RangeError(\"Index out of range\");\n    }\n    function writeFloat(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 23, 4);\n      return offset + 4;\n    }\n    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, true, noAssert);\n    };\n    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n      return writeFloat(this, value, offset, false, noAssert);\n    };\n    function writeDouble(buf, value, offset, littleEndian, noAssert) {\n      value = +value;\n      offset = offset >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);\n      }\n      ieee754.write(buf, value, offset, littleEndian, 52, 8);\n      return offset + 8;\n    }\n    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, true, noAssert);\n    };\n    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n      return writeDouble(this, value, offset, false, noAssert);\n    };\n    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!Buffer3.isBuffer(target)) throw new TypeError(\"argument should be a Buffer\");\n      if (!start) start = 0;\n      if (!end && end !== 0) end = this.length;\n      if (targetStart >= target.length) targetStart = target.length;\n      if (!targetStart) targetStart = 0;\n      if (end > 0 && end < start) end = start;\n      if (end === start) return 0;\n      if (target.length === 0 || this.length === 0) return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length) throw new RangeError(\"Index out of range\");\n      if (end < 0) throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length) end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(\n          target,\n          this.subarray(start, end),\n          targetStart\n        );\n      }\n      return len;\n    };\n    Buffer3.prototype.fill = function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer3.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          const code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val) val = 0;\n      let i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    };\n    var errors = {};\n    function E(sym, getMessage, Base) {\n      errors[sym] = class NodeError extends Base {\n        constructor() {\n          super();\n          Object.defineProperty(this, \"message\", {\n            value: getMessage.apply(this, arguments),\n            writable: true,\n            configurable: true\n          });\n          this.name = `${this.name} [${sym}]`;\n          this.stack;\n          delete this.name;\n        }\n        get code() {\n          return sym;\n        }\n        set code(value) {\n          Object.defineProperty(this, \"code\", {\n            configurable: true,\n            enumerable: true,\n            value,\n            writable: true\n          });\n        }\n        toString() {\n          return `${this.name} [${sym}]: ${this.message}`;\n        }\n      };\n    }\n    E(\n      \"ERR_BUFFER_OUT_OF_BOUNDS\",\n      function(name) {\n        if (name) {\n          return `${name} is outside of buffer bounds`;\n        }\n        return \"Attempt to access memory outside buffer bounds\";\n      },\n      RangeError\n    );\n    E(\n      \"ERR_INVALID_ARG_TYPE\",\n      function(name, actual) {\n        return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n      },\n      TypeError\n    );\n    E(\n      \"ERR_OUT_OF_RANGE\",\n      function(str, range, input) {\n        let msg = `The value of \"${str}\" is out of range.`;\n        let received = input;\n        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n          received = addNumericalSeparator(String(input));\n        } else if (typeof input === \"bigint\") {\n          received = String(input);\n          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n            received = addNumericalSeparator(received);\n          }\n          received += \"n\";\n        }\n        msg += ` It must be ${range}. Received ${received}`;\n        return msg;\n      },\n      RangeError\n    );\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function checkBounds(buf, offset, byteLength2) {\n      validateNumber(offset, \"offset\");\n      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {\n        boundsError(offset, buf.length - (byteLength2 + 1));\n      }\n    }\n    function checkIntBI(value, min, max, buf, offset, byteLength2) {\n      if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        if (byteLength2 > 3) {\n          if (min === 0 || min === BigInt(0)) {\n            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n          } else {\n            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n          }\n        } else {\n          range = `>= ${min}${n} and <= ${max}${n}`;\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n      }\n      checkBounds(buf, offset, byteLength2);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n    }\n    function boundsError(value, length, type) {\n      if (Math.floor(value) !== value) {\n        validateNumber(value, type);\n        throw new errors.ERR_OUT_OF_RANGE(type || \"offset\", \"an integer\", value);\n      }\n      if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n      }\n      throw new errors.ERR_OUT_OF_RANGE(\n        type || \"offset\",\n        `>= ${type ? 1 : 0} and <= ${length}`,\n        value\n      );\n    }\n    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2) return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    function utf8ToBytes(string, units) {\n      units = units || Infinity;\n      let codePoint;\n      const length = string.length;\n      let leadSurrogate = null;\n      const bytes = [];\n      for (let i = 0; i < length; ++i) {\n        codePoint = string.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1) bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1) bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1) bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0) break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0) break;\n          bytes.push(\n            codePoint >> 6 | 192,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0) break;\n          bytes.push(\n            codePoint >> 12 | 224,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0) break;\n          bytes.push(\n            codePoint >> 18 | 240,\n            codePoint >> 12 & 63 | 128,\n            codePoint >> 6 & 63 | 128,\n            codePoint & 63 | 128\n          );\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    function asciiToBytes(str) {\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    function utf16leToBytes(str, units) {\n      let c, hi, lo;\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0) break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    function blitBuffer(src, dst, offset, length) {\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (i + offset >= dst.length || i >= src.length) break;\n        dst[i + offset] = src[i];\n      }\n      return i;\n    }\n    function isInstance(obj, type) {\n      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n    }\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    var hexSliceLookupTable = (function() {\n      const alphabet = \"0123456789abcdef\";\n      const table = new Array(256);\n      for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j = 0; j < 16; ++j) {\n          table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n      }\n      return table;\n    })();\n    function defineBigIntMethod(fn) {\n      return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n    }\n    function BufferBigIntNotDefined() {\n      throw new Error(\"BigInt not supported\");\n    }\n  }\n});\n\n// buffer-shim.js\nvar import_buffer = __toESM(require_buffer(), 1);\nglobalThis.Buffer = import_buffer.Buffer;\n/*! Bundled license information:\n\nieee754/index.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nbuffer/index.js:\n  (*!\n   * The buffer module from node.js, for the browser.\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * FS Sync Worker Entry Point\n * Web Worker that handles synchronous filesystem operations via SharedArrayBuffer\n */\n\nimport { init, setSharedArrayBuffer, validateAndClearCorruptedEventsSAB, enterDeferredFlushMode, exitDeferredFlushMode } from './fs.vfs'\nimport type { StorageMode } from './config'\nimport { startRequestLoop, setLogging } from './fs.sync.loop'\nimport { asyncQueue, asyncQueueMetrics, MAX_ASYNC_QUEUE_SIZE, enqueueFireAndForget } from './fs.sync.queue'\n\n// Worker-side configuration\nlet storageMode: StorageMode = 'hybrid'\nlet syncSAB: SharedArrayBuffer | null = null\n\nself.onmessage = async (event) => {\n  const { type, syncSAB: sync, eventsSAB: events, method, args, logging, storageMode: mode } = event.data\n\n  if (type === 'init') {\n    syncSAB = sync\n    setSharedArrayBuffer(events) // Pass events SAB to VFS\n\n    // Validate events SAB and clear if corrupted (handles persisted bad data from IndexedDB)\n    validateAndClearCorruptedEventsSAB()\n\n    // Set storage mode before initialization (startup-only setting)\n    if (mode) {\n      storageMode = mode as StorageMode\n    }\n\n    await init()\n    self.postMessage({ type: 'initialized' })\n\n    // Start the request loop after init\n    if (syncSAB) {\n      startRequestLoop(syncSAB, storageMode)\n    }\n  } else if (type === 'fireAndForget') {\n    // Queue fire-and-forget request - will be processed between SAB requests\n    enqueueFireAndForget(method, args)\n  } else if (type === 'setLogging') {\n    // Update logging configuration\n    setLogging(logging?.enabled ?? false, logging?.level ?? 'info')\n  } else if (type === 'getMetrics') {\n    // Return queue metrics for monitoring\n    self.postMessage({\n      type: 'metrics',\n      asyncQueue: {\n        ...asyncQueueMetrics,\n        currentSize: asyncQueue.length,\n        maxSize: MAX_ASYNC_QUEUE_SIZE,\n      },\n    })\n  } else if (type === 'enterDeferredFlush') {\n    // Enable deferred flush mode for bulk operations (trades durability for speed)\n    enterDeferredFlushMode()\n  } else if (type === 'exitDeferredFlush') {\n    // Disable deferred flush mode and flush pending data\n    exitDeferredFlushMode()\n  }\n}\n\nself.postMessage({ type: 'ready' })\n","// Virtual File System - Re-exports all VFS functionality from ./vfs modules\n// This file is kept for backwards compatibility with existing imports\n\nexport * from './vfs'\n","// VFS Module Index - Re-exports all VFS functionality\n\n// Types\nexport type { EventType, PendingEvent, FileMetadata, WatchListener, FileSystemSyncAccessHandle, FileSystemChangeRecord, FileSystemObserver, VfsFileEntry } from './types'\n\n// State & Getters\nexport { setSharedArrayBuffer, getSharedArrayBuffer, getRoot, getVfsHandle, defaultFileMetadata, defaultDirMetadata, isFireAndForgetMode, setFireAndForgetMode, enterFireAndForgetMode, exitFireAndForgetMode, isDeferredFlushMode, enterDeferredFlushMode, exitDeferredFlushMode } from './state'\n\n// Events\nexport { queueEvent, consumeEvent, readEventsFromSAB, writeEventsToSAB, clearEventsSAB, validateAndClearCorruptedEventsSAB, isEventQueuingDisabled, enableEventQueuing, disableEventQueuing, eventSabMetrics, resetEventMetrics, incrementExternalEvents, clearEventCounters, getPendingCount, getTotalPending, dumpEventQueue, getPendingPaths, checkPathDumpRequest, requestPendingPathsAsync } from './events'\n\n// Index Operations\nexport { loadIndex, saveIndex, flushIndex, isIndexDirty, indexSaveMetrics } from './index-ops'\n\n// File Operations\nexport { readFromVfs, readFileFromVfs, readChunkFromVfs, getFileSizeFromVfs, writeToVfs, writeFileToVfs, existsInVfs, deleteFromVfs, getVfsIndex } from './files'\n\n// Directory Operations\nexport { isDirectoryInVfs, createDirInVfs, deleteDirFromVfs, getVfsDirIndex } from './dirs'\n\n// Symlink Operations\nexport { createSymlinkInVfs, readSymlinkFromVfs, isSymlinkInVfs, deleteSymlinkFromVfs, resolveSymlinkInVfs, getVfsSymlinkIndex } from './symlinks'\n\n// Metadata Operations\nexport { getMetadataFromVfs, setMetadataInVfs, chmodInVfs, chownInVfs, utimesInVfs, getVfsMetadataIndex } from './metadata'\n\n// Watch Operations\nexport { addWatchListener, removeWatchListener, notifyWatchListeners } from './watch'\n\n// Compact Operations\nexport { compactSync, compact, maybeScheduleCompaction, scheduleCompaction, getCompactionStatus } from './compact'\n\n// Sync Operations\nexport type { SyncProgressCallback, SyncResult } from './sync'\nexport { syncFileToVfs, removeFileFromVfs, syncVfsToOpfs, syncOpfsToVfs } from './sync'\n\n// OPFS Background Sync Queue (VFS -> OPFS in hybrid mode)\nexport type { OpfsSyncType } from './opfs-sync-queue'\nexport { queueOpfsSync, flushOpfsSync, getOpfsSyncStatus, clearOpfsSyncQueue, terminateOpfsSyncWorker, opfsSyncMetrics } from './opfs-sync-queue'\n\n// Traverse Operations\nexport { traverseVfs, traverseOpfs } from './traverse'\n\n// Import Operations\nexport { importToVfs, importToOpfs } from './import'\n\n// Init & Lifecycle\nexport { init, teardown, unwatchOpfs } from './init'\n\n// Path Utilities\nexport { normalizePath, isRootPath, getParentPath, getBasename, joinPath } from './path'\n","// VFS Shared State\n\nimport type { FileMetadata, FileSystemSyncAccessHandle, FileSystemObserver, WatchListener, VfsFileEntry } from './types'\nimport { VFS } from '../app-constants'\n\n// Constants (re-exported from centralized constants)\nexport const VFS_FILENAME = VFS.FILENAME\nexport const INDEX_HEADER_SIZE = VFS.INDEX_HEADER_SIZE\nexport const COMPACTION_THRESHOLD = VFS.COMPACTION_THRESHOLD\nexport const COMPACTION_URGENT_THRESHOLD = VFS.COMPACTION_URGENT_THRESHOLD\nexport const COMPACTION_DEBOUNCE_MS = VFS.COMPACTION_DEBOUNCE_MS\nexport const COMPACTION_IDLE_TIMEOUT_MS = VFS.COMPACTION_IDLE_TIMEOUT_MS\n\n// Global state\nexport let root: FileSystemDirectoryHandle | null = null\nexport let vfsFileHandle: FileSystemFileHandle | null = null\nexport let vfsSyncHandle: FileSystemSyncAccessHandle | null = null\nexport let observer: FileSystemObserver | null = null\nexport let sharedArrayBuffer: SharedArrayBuffer | null = null\nexport let wastedBytes = 0\n\n// Fire-and-forget mode counter (replaces boolean flag for proper nesting)\n// When > 0, VFS writes should NOT trigger OPFS sync (because OPFS already has the data)\n// This is incremented/decremented by the sync worker when processing fire-and-forget requests\n// Using a counter instead of boolean handles nested/reentrant calls correctly\nlet fireAndForgetDepth = 0\nexport const isFireAndForgetMode = () => fireAndForgetDepth > 0\nexport const enterFireAndForgetMode = () => { fireAndForgetDepth++ }\nexport const exitFireAndForgetMode = () => { fireAndForgetDepth = Math.max(0, fireAndForgetDepth - 1) }\n// Legacy API for compatibility - setFireAndForgetMode(true) increments, false decrements\nexport const setFireAndForgetMode = (value: boolean) => { value ? fireAndForgetDepth++ : fireAndForgetDepth = Math.max(0, fireAndForgetDepth - 1) }\n\n// Deferred flush mode - when enabled, flushes are batched for performance\n// This trades durability for speed - data may be lost on crash\nlet deferredFlushMode = false\nlet deferredFlushTimer: ReturnType<typeof setTimeout> | null = null\nconst DEFERRED_FLUSH_INTERVAL_MS = VFS.DEFERRED_FLUSH_INTERVAL_MS\n\nexport const isDeferredFlushMode = () => deferredFlushMode\n\nexport const enterDeferredFlushMode = () => {\n    if (deferredFlushMode) return\n    deferredFlushMode = true\n\n    // Start periodic flush timer\n    const scheduleFlush = () => {\n        deferredFlushTimer = setTimeout(() => {\n            if (deferredFlushMode && vfsSyncHandle) {\n                vfsSyncHandle.flush()\n            }\n            if (deferredFlushMode) {\n                scheduleFlush()\n            }\n        }, DEFERRED_FLUSH_INTERVAL_MS)\n    }\n    scheduleFlush()\n}\n\nexport const exitDeferredFlushMode = () => {\n    if (!deferredFlushMode) return\n    deferredFlushMode = false\n\n    // Clear timer and do final flush\n    if (deferredFlushTimer) {\n        clearTimeout(deferredFlushTimer)\n        deferredFlushTimer = null\n    }\n    if (vfsSyncHandle) {\n        vfsSyncHandle.flush()\n    }\n}\n\n// Compaction scheduling state\nlet compactionScheduled = false\nlet compactionDebounceTimer: ReturnType<typeof setTimeout> | null = null\nlet compactionIdleCallback: number | null = null\n\n// Compaction metrics\nexport const compactionMetrics = {\n    totalCompactions: 0,\n    scheduledCompactions: 0,\n    urgentCompactions: 0,\n    totalBytesReclaimed: 0,\n    lastCompactionTime: 0,\n    lastCompactionDuration: 0,\n}\n\n// Setters for state\nexport const setRoot = (r: FileSystemDirectoryHandle | null) => { root = r }\nexport const setVfsFileHandle = (h: FileSystemFileHandle | null) => { vfsFileHandle = h }\nexport const setVfsSyncHandle = (h: FileSystemSyncAccessHandle | null) => { vfsSyncHandle = h }\nexport const setObserver = (o: FileSystemObserver | null) => { observer = o }\nexport const setSharedArrayBuffer = (sab: SharedArrayBuffer) => { sharedArrayBuffer = sab }\nexport const getSharedArrayBuffer = () => sharedArrayBuffer\nexport const addWastedBytes = (bytes: number) => { wastedBytes += bytes }\nexport const resetWastedBytes = () => { wastedBytes = 0 }\nexport const getWastedBytes = () => wastedBytes\n\n// Compaction scheduling helpers\nexport const isCompactionScheduled = () => compactionScheduled\nexport const setCompactionScheduled = (scheduled: boolean) => { compactionScheduled = scheduled }\n\nexport const clearCompactionTimers = () => {\n    if (compactionDebounceTimer) {\n        clearTimeout(compactionDebounceTimer)\n        compactionDebounceTimer = null\n    }\n    if (compactionIdleCallback !== null && typeof cancelIdleCallback !== 'undefined') {\n        cancelIdleCallback(compactionIdleCallback)\n        compactionIdleCallback = null\n    }\n}\n\nexport const setCompactionDebounceTimer = (timer: ReturnType<typeof setTimeout>) => {\n    compactionDebounceTimer = timer\n}\n\nexport const setCompactionIdleCallback = (id: number) => {\n    compactionIdleCallback = id\n}\n\n// VFS Indexes\nexport const vfsIndex = new Map<string, VfsFileEntry>()\nexport const vfsDirIndex = new Set<string>()\nexport const vfsSymlinkIndex = new Map<string, string>()\nexport const vfsMetadataIndex = new Map<string, FileMetadata>()\nexport const watchListeners = new Map<string, Set<WatchListener>>()\n\n// Getters for handles and root\nexport const getRoot = () => root\nexport const getVfsHandle = () => vfsSyncHandle\n\n// Default metadata factories\nexport const defaultFileMetadata = (): FileMetadata => ({\n    mode: 0o644,\n    uid: 0,\n    gid: 0,\n    mtime: Date.now(),\n    atime: Date.now(),\n})\n\nexport const defaultDirMetadata = (): FileMetadata => ({\n    mode: 0o755,\n    uid: 0,\n    gid: 0,\n    mtime: Date.now(),\n    atime: Date.now(),\n})\n","/**\n * Centralized Constants\n *\n * All configurable constants in one place for easy tuning and discovery.\n * Import from here rather than defining locally.\n */\n\n// =============================================================================\n// SHARED ARRAY BUFFER SIZES\n// =============================================================================\n\nexport const SAB_SIZES = {\n    /** 64MB - FS sync requests (large file operations) */\n    FS_SYNC: 64 * 1024 * 1024,\n\n    /** 256KB - FS event notifications */\n    FS_EVENTS: 256 * 1024,\n\n    /** 32MB - Exec worker sync communication */\n    EXEC_SYNC: 32 * 1024 * 1024,\n\n    /** 128MB - Rolldown bundler communication (vue-tsc + typescript can exceed 22MB) */\n    BUNDLER: 128 * 1024 * 1024,\n} as const\n\n// =============================================================================\n// TIMEOUTS\n// =============================================================================\n\nexport const TIMEOUTS = {\n    /** 60s - Worker initialization (WASM compilation can take 15-30s for large modules) */\n    WORKER_INIT: 60_000,\n\n    /** 600s - Script execution (WASM under V8 Liftoff can be 10-100x slower than native) */\n    EXECUTION: 600_000,\n\n    /** 60s - Bundle operation */\n    BUNDLE: 60_000,\n\n    /** 30s - Worker idle before termination */\n    WORKER_IDLE: 30_000,\n\n    /** 2s - Auto-scaling check interval */\n    SCALE_CHECK: 2_000,\n\n    /** 50ms - Execution polling interval */\n    EXEC_POLL: 50,\n} as const\n\n// =============================================================================\n// FILE CHUNKING\n// =============================================================================\n\nexport const CHUNK_SIZES = {\n    /** 60MB - Threshold for chunked file reads (SAB is 64MB, leave room for overhead) */\n    FILE_THRESHOLD: 60 * 1024 * 1024,\n\n    /** 50MB - Size per chunk when reading large files */\n    FILE_CHUNK: 50 * 1024 * 1024,\n\n    /** 1MB - Stream chunk size */\n    STREAM: 1024 * 1024,\n} as const\n\n// =============================================================================\n// WORKER POOL\n// =============================================================================\n\nexport const WORKER_POOL = {\n    /** Minimum workers to keep warm */\n    MIN_WORKERS: 1,\n\n    /** Maximum workers (defaults to CPU count) */\n    MAX_WORKERS: typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 4) : 4,\n\n    /** Queue depth to trigger immediate scale up */\n    SCALE_UP_THRESHOLD: 3,\n} as const\n\n// =============================================================================\n// VFS (Virtual File System)\n// =============================================================================\n\nexport const VFS = {\n    /** Binary file that stores all VFS data */\n    FILENAME: '.vfs-future.bin',\n\n    /** Header size in bytes for index */\n    INDEX_HEADER_SIZE: 4,\n\n    /** 1MB - Schedule compaction when wasted bytes exceed this */\n    COMPACTION_THRESHOLD: 1024 * 1024,\n\n    /** 5MB - Immediate compaction when wasted bytes exceed this */\n    COMPACTION_URGENT_THRESHOLD: 5 * 1024 * 1024,\n\n    /** 500ms - Wait after last write before compacting */\n    COMPACTION_DEBOUNCE_MS: 500,\n\n    /** 2s - Max wait for idle callback before forcing compaction */\n    COMPACTION_IDLE_TIMEOUT_MS: 2_000,\n\n    /** 100ms - Flush interval when in deferred mode */\n    DEFERRED_FLUSH_INTERVAL_MS: 100,\n} as const\n\n// =============================================================================\n// SAB PROTOCOL OFFSETS (Shared by multiple workers)\n// =============================================================================\n\nexport const SAB_OFFSETS = {\n    /** Byte offset for status flag */\n    STATUS: 0,\n\n    /** Byte offset for data length */\n    LENGTH: 4,\n\n    /** Byte offset for request/response type (FS only) */\n    TYPE: 8,\n\n    /** Byte offset where data payload starts (FS) */\n    DATA_FS: 9,\n\n    /** Byte offset where data payload starts (Exec/Bundler) */\n    DATA_SIMPLE: 8,\n\n    /**\n     * Byte offset for FS SAB lock (last 4 bytes of SAB).\n     * Prevents race conditions when multiple threads (exec worker + primary tab)\n     * share the same SAB for sync FS operations.\n     * Value: 0 = unlocked, 1 = locked. Uses Atomics.compareExchange for CAS.\n     */\n    FS_LOCK: SAB_SIZES.FS_SYNC - 4,\n} as const\n\n// =============================================================================\n// SAB STATUS VALUES\n// =============================================================================\n\nexport const SAB_STATUS = {\n    IDLE: 0,\n    REQUEST: 1,\n    RESPONSE: 2,\n    ERROR: 3,\n    OUTPUT: 4, // For streaming terminal output\n} as const\n\n// =============================================================================\n// SAB REQUEST/RESPONSE TYPES (FS protocol)\n// =============================================================================\n\nexport const SAB_TYPE = {\n    REQUEST_JSON: 0,\n    REQUEST_BINARY_ARG: 1,\n    RESPONSE_JSON: 0,\n    RESPONSE_BINARY: 1,\n} as const\n\n// =============================================================================\n// LOCK NAMES\n// =============================================================================\n\nexport const LOCKS = {\n    /** Web Lock for primary tab election */\n    FS_PRIMARY: 'fs_primary_lock',\n} as const\n\n// =============================================================================\n// DEBUG MODE\n// =============================================================================\n\nexport const DEBUG_KEY = 'NODECONTAINER_DEBUG'\n\n/**\n * Check if debug mode is enabled\n */\nexport function isDebugEnabled(): boolean {\n    if (typeof localStorage === 'undefined') return false\n    return localStorage.getItem(DEBUG_KEY) === 'true'\n}\n","/**\n * VFS Event Tracking - Exact Path-Based System\n */\n\nimport type { EventType } from './types'\nimport { sharedArrayBuffer, isFireAndForgetMode } from './state'\nimport { normalizePath } from './path'\nimport { getMetrics, getMetricsInt32, syncPathsToSAB, readPathsFromSAB } from './event-sab'\nimport {\n    METRIC_QUEUED_TOTAL, METRIC_QUEUED_CREATE, METRIC_QUEUED_UPDATE, METRIC_QUEUED_DELETE,\n    METRIC_INTERNAL_TOTAL, METRIC_INTERNAL_CREATE, METRIC_INTERNAL_UPDATE, METRIC_INTERNAL_DELETE,\n    METRIC_EXTERNAL_TOTAL, METRIC_EXTERNAL_CREATE, METRIC_EXTERNAL_UPDATE, METRIC_EXTERNAL_DELETE,\n    METRIC_QUEUE_PATH_COUNT, METRIC_COUNT, PATH_REQUEST_FLAG, PATH_RESPONSE_FLAG,\n    PATH_DATA_LENGTH, PATH_DATA_OFFSET, PATH_DATA_MAX_BYTES, RESET_GRACE_COUNTER, RESET_GRACE_PERIOD,\n    type PathQueueEntry\n} from './event-constants'\n\nexport { eventSabMetrics } from './event-metrics'\n\n// The queue - local Map\nconst pathQueue = new Map<string, PathQueueEntry>()\n\n// Queue an event (UP)\nexport const queueEvent = (type: EventType, path: string): void => {\n    if (isFireAndForgetMode()) return\n\n    const metrics = getMetrics()\n    if (metrics) {\n        const graceCounter = Atomics.load(metrics, RESET_GRACE_COUNTER)\n        if (graceCounter > 0) {\n            pathQueue.clear()\n            Atomics.store(metrics, RESET_GRACE_COUNTER, 0)\n            Atomics.store(metrics, PATH_DATA_LENGTH, 0)\n        }\n    }\n\n    const normalized = normalizePath(path)\n    let entry = pathQueue.get(normalized)\n\n    // Targeted self-consume for delete\n    if (type === 'delete' && entry && (entry.creates > 0 || entry.updates > 0)) {\n        if (metrics) {\n            Atomics.add(metrics, METRIC_QUEUED_TOTAL, 1)\n            Atomics.add(metrics, METRIC_QUEUED_DELETE, 1)\n        }\n\n        const totalCreates = entry.creates\n        const totalUpdates = entry.updates\n        const totalDeletes = entry.deletes + 1\n        pathQueue.delete(normalized)\n\n        if (metrics) {\n            Atomics.add(metrics, METRIC_INTERNAL_TOTAL, totalCreates + totalUpdates + totalDeletes)\n            Atomics.add(metrics, METRIC_INTERNAL_CREATE, totalCreates)\n            Atomics.add(metrics, METRIC_INTERNAL_UPDATE, totalUpdates)\n            Atomics.add(metrics, METRIC_INTERNAL_DELETE, totalDeletes)\n        }\n\n        syncPathsToSAB(pathQueue)\n        return\n    }\n\n    if (!entry) {\n        entry = { creates: 0, updates: 0, deletes: 0, lastMtime: 0 }\n        pathQueue.set(normalized, entry)\n    }\n\n    if (type === 'create') entry.creates++\n    else if (type === 'update') entry.updates++\n    else entry.deletes++\n\n    entry.lastMtime = Date.now()\n\n    if (metrics) {\n        Atomics.add(metrics, METRIC_QUEUED_TOTAL, 1)\n        if (type === 'create') Atomics.add(metrics, METRIC_QUEUED_CREATE, 1)\n        else if (type === 'update') Atomics.add(metrics, METRIC_QUEUED_UPDATE, 1)\n        else Atomics.add(metrics, METRIC_QUEUED_DELETE, 1)\n    }\n\n    syncPathsToSAB(pathQueue)\n}\n\n// Consume an event (DOWN)\nexport const consumeEvent = (type: EventType, path: string, observerMtime?: number, skipExternalCount = false): boolean => {\n    const normalized = normalizePath(path)\n    const metrics = getMetrics()\n\n    if (metrics) {\n        const graceCounter = Atomics.load(metrics, RESET_GRACE_COUNTER)\n        if (graceCounter > 0) {\n            Atomics.sub(metrics, RESET_GRACE_COUNTER, 1)\n            return true\n        }\n    }\n\n    const pathsToConsume: string[] = []\n    const prefix = normalized + '/'\n\n    for (const queuedPath of pathQueue.keys()) {\n        if (queuedPath === normalized || queuedPath.startsWith(prefix)) {\n            pathsToConsume.push(queuedPath)\n        }\n    }\n\n    const parts = normalized.split('/').filter(p => p.length > 0)\n    for (let i = 1; i < parts.length; i++) {\n        const parentPath = parts.slice(0, i).join('/')\n        if (pathQueue.has(parentPath) && !pathsToConsume.includes(parentPath)) {\n            pathsToConsume.push(parentPath)\n        }\n    }\n\n    if (pathsToConsume.length === 0) {\n        if (skipExternalCount) return true\n\n        if (type === 'update') console.log(`[EXTERNAL UPDATE] ${normalized}`)\n\n        if (metrics) {\n            Atomics.add(metrics, METRIC_EXTERNAL_TOTAL, 1)\n            if (type === 'create') Atomics.add(metrics, METRIC_EXTERNAL_CREATE, 1)\n            else if (type === 'update') Atomics.add(metrics, METRIC_EXTERNAL_UPDATE, 1)\n            else Atomics.add(metrics, METRIC_EXTERNAL_DELETE, 1)\n        }\n        return false\n    }\n\n    let totalCreates = 0, totalUpdates = 0, totalDeletes = 0\n    let latestMtime = 0\n\n    for (const p of pathsToConsume) {\n        const entry = pathQueue.get(p)\n        if (entry) {\n            totalCreates += entry.creates\n            totalUpdates += entry.updates\n            totalDeletes += entry.deletes\n            if (entry.lastMtime > latestMtime) latestMtime = entry.lastMtime\n            pathQueue.delete(p)\n        }\n    }\n\n    if (metrics) {\n        Atomics.add(metrics, METRIC_INTERNAL_TOTAL, totalCreates + totalUpdates + totalDeletes)\n        Atomics.add(metrics, METRIC_INTERNAL_CREATE, totalCreates)\n        Atomics.add(metrics, METRIC_INTERNAL_UPDATE, totalUpdates)\n        Atomics.add(metrics, METRIC_INTERNAL_DELETE, totalDeletes)\n    }\n\n    const isAlsoExternal = observerMtime !== undefined && observerMtime > latestMtime\n    if (isAlsoExternal && metrics) {\n        Atomics.add(metrics, METRIC_EXTERNAL_TOTAL, 1)\n        if (type === 'create') Atomics.add(metrics, METRIC_EXTERNAL_CREATE, 1)\n        else if (type === 'update') Atomics.add(metrics, METRIC_EXTERNAL_UPDATE, 1)\n        else Atomics.add(metrics, METRIC_EXTERNAL_DELETE, 1)\n    }\n\n    syncPathsToSAB(pathQueue)\n    return !isAlsoExternal\n}\n\nexport const incrementExternalEvents = (type: EventType): void => {\n    const metrics = getMetrics()\n    if (!metrics) return\n\n    Atomics.add(metrics, METRIC_EXTERNAL_TOTAL, 1)\n    if (type === 'create') Atomics.add(metrics, METRIC_EXTERNAL_CREATE, 1)\n    else if (type === 'update') Atomics.add(metrics, METRIC_EXTERNAL_UPDATE, 1)\n    else Atomics.add(metrics, METRIC_EXTERNAL_DELETE, 1)\n}\n\nexport const resetEventMetrics = (): void => {\n    pathQueue.clear()\n    const metrics = getMetrics()\n    if (metrics) {\n        for (let i = 0; i < METRIC_COUNT; i++) Atomics.store(metrics, i, 0)\n        Atomics.store(metrics, RESET_GRACE_COUNTER, RESET_GRACE_PERIOD)\n    }\n}\n\nexport const getPendingCount = (): number => {\n    let total = 0\n    for (const entry of pathQueue.values()) {\n        total += entry.creates + entry.updates + entry.deletes\n    }\n    return total\n}\n\nexport const getPendingPaths = (): string[] => {\n    if (pathQueue.size > 0) {\n        const result: string[] = []\n        for (const [path, entry] of pathQueue.entries()) {\n            result.push(`${path} (c=${entry.creates} u=${entry.updates} d=${entry.deletes})`)\n        }\n        return result\n    }\n    return readPathsFromSAB()\n}\n\nexport const getTotalPending = getPendingCount\n\nexport const clearEventCounters = (): void => {\n    const metrics = getMetrics()\n    if (metrics) Atomics.store(metrics, METRIC_QUEUE_PATH_COUNT, 0)\n    pathQueue.clear()\n}\n\nexport const dumpEventQueue = (): void => {\n    const metrics = getMetrics()\n    const sabPathCount = metrics ? Atomics.load(metrics, METRIC_QUEUE_PATH_COUNT) : 0\n    console.log(`[PENDING PATHS] SAB says ${sabPathCount} paths, local map has ${pathQueue.size}`)\n\n    if (pathQueue.size > 0) {\n        const paths: string[] = []\n        for (const [path, entry] of pathQueue.entries()) {\n            paths.push(`${path} (c=${entry.creates} u=${entry.updates} d=${entry.deletes})`)\n        }\n        console.log(`[PENDING PATHS]`, paths)\n    }\n}\n\nexport const checkPathDumpRequest = (): void => {\n    if (!sharedArrayBuffer) return\n    const metrics = getMetrics()\n    if (!metrics) return\n\n    if (Atomics.load(metrics, PATH_REQUEST_FLAG) !== 1) return\n\n    const paths: string[] = []\n    for (const [path, entry] of pathQueue.entries()) {\n        paths.push(`${path} (c=${entry.creates} u=${entry.updates} d=${entry.deletes})`)\n    }\n    const json = JSON.stringify(paths)\n    const bytes = new TextEncoder().encode(json)\n\n    const writeLen = Math.min(bytes.length, PATH_DATA_MAX_BYTES)\n    const sabBytes = new Uint8Array(sharedArrayBuffer, PATH_DATA_OFFSET, PATH_DATA_MAX_BYTES)\n    sabBytes.set(bytes.subarray(0, writeLen))\n\n    Atomics.store(metrics, PATH_DATA_LENGTH, writeLen)\n    Atomics.store(metrics, PATH_REQUEST_FLAG, 0)\n    Atomics.store(metrics, PATH_RESPONSE_FLAG, 1)\n\n    const metricsInt32 = getMetricsInt32()\n    if (metricsInt32) Atomics.notify(metricsInt32, PATH_RESPONSE_FLAG)\n}\n\nexport const requestPendingPathsAsync = async (timeoutMs = 1000): Promise<string[]> => {\n    if (!sharedArrayBuffer) return []\n    const metrics = getMetrics()\n    if (!metrics) return []\n\n    if (Atomics.load(metrics, METRIC_QUEUE_PATH_COUNT) === 0) return []\n\n    Atomics.store(metrics, PATH_RESPONSE_FLAG, 0)\n    Atomics.store(metrics, PATH_REQUEST_FLAG, 1)\n\n    const startTime = Date.now()\n    while (Date.now() - startTime < timeoutMs) {\n        if (Atomics.load(metrics, PATH_RESPONSE_FLAG) === 1) {\n            const length = Atomics.load(metrics, PATH_DATA_LENGTH)\n            if (length === 0) return []\n\n            const sabBytes = new Uint8Array(sharedArrayBuffer, PATH_DATA_OFFSET, length)\n            const copyBuffer = new Uint8Array(length)\n            copyBuffer.set(sabBytes)\n            const json = new TextDecoder().decode(copyBuffer)\n\n            Atomics.store(metrics, PATH_RESPONSE_FLAG, 0)\n            try { return JSON.parse(json) } catch { return ['(failed to parse)'] }\n        }\n        await new Promise(r => setTimeout(r, 10))\n    }\n\n    Atomics.store(metrics, PATH_REQUEST_FLAG, 0)\n    return ['(timeout)']\n}\n\n// Legacy exports\nexport const readEventsFromSAB = () => []\nexport const writeEventsToSAB = () => {}\nexport const clearEventsSAB = () => { clearEventCounters() }\nexport const validateAndClearCorruptedEventsSAB = () => true\nexport const isEventQueuingDisabled = () => false\nexport const enableEventQueuing = () => {}\nexport const disableEventQueuing = () => {}\nexport const cleanupExpiredEvents = () => 0\n","// VFS Path Utilities\n// Shared path normalization to ensure consistent path handling across all VFS operations\n\n/**\n * Normalizes a path for VFS storage and lookup.\n * - Removes leading and trailing slashes\n * - Handles empty paths, root, and current directory\n * - Returns empty string for root paths\n *\n * @example\n * normalizePath('/foo/bar/') -> 'foo/bar'\n * normalizePath('foo/bar')   -> 'foo/bar'\n * normalizePath('/')         -> ''\n * normalizePath('')          -> ''\n */\nexport const normalizePath = (path: string): string => {\n    return path.replace(/^\\/+|\\/+$/g, '')\n}\n\n/**\n * Checks if a path represents the root directory\n */\nexport const isRootPath = (path: string): boolean => {\n    const normalized = normalizePath(path)\n    return normalized === '' || path === '.' || path === '/'\n}\n\n/**\n * Gets the parent directory of a path\n * @example\n * getParentPath('foo/bar/baz') -> 'foo/bar'\n * getParentPath('foo')         -> ''\n * getParentPath('')            -> ''\n */\nexport const getParentPath = (path: string): string => {\n    const normalized = normalizePath(path)\n    const lastSlash = normalized.lastIndexOf('/')\n    return lastSlash === -1 ? '' : normalized.slice(0, lastSlash)\n}\n\n/**\n * Gets the basename (final component) of a path\n * @example\n * getBasename('foo/bar/baz') -> 'baz'\n * getBasename('foo')         -> 'foo'\n */\nexport const getBasename = (path: string): string => {\n    const normalized = normalizePath(path)\n    const lastSlash = normalized.lastIndexOf('/')\n    return lastSlash === -1 ? normalized : normalized.slice(lastSlash + 1)\n}\n\n/**\n * Joins path segments, normalizing the result\n * @example\n * joinPath('foo', 'bar')     -> 'foo/bar'\n * joinPath('/foo/', '/bar/') -> 'foo/bar'\n */\nexport const joinPath = (...segments: string[]): string => {\n    return normalizePath(segments.map(normalizePath).filter(Boolean).join('/'))\n}\n","/**\n * VFS Event SAB Helpers - SharedArrayBuffer access for metrics\n */\n\nimport { sharedArrayBuffer } from './state'\nimport {\n    METRICS_OFFSET, METRIC_COUNT, PATH_DATA_OFFSET, PATH_DATA_MAX_BYTES,\n    PATH_DATA_LENGTH, METRIC_QUEUE_PATH_COUNT, METRIC_PENDING_CREATE,\n    METRIC_PENDING_UPDATE, METRIC_PENDING_DELETE, type PathQueueEntry\n} from './event-constants'\n\n// Get metrics array view (Uint32 for counters)\nexport const getMetrics = (): Uint32Array | null => {\n    if (!sharedArrayBuffer) return null\n    return new Uint32Array(sharedArrayBuffer, METRICS_OFFSET, METRIC_COUNT)\n}\n\n// Get metrics as Int32Array (required for Atomics.notify)\nexport const getMetricsInt32 = (): Int32Array | null => {\n    if (!sharedArrayBuffer) return null\n    return new Int32Array(sharedArrayBuffer, METRICS_OFFSET, METRIC_COUNT)\n}\n\n// Sync pathQueue to SAB so main thread can read it directly\nexport const syncPathsToSAB = (pathQueue: Map<string, PathQueueEntry>): void => {\n    if (!sharedArrayBuffer) return\n\n    const metrics = getMetrics()\n    if (metrics) {\n        let pendingCreates = 0, pendingUpdates = 0, pendingDeletes = 0\n        for (const entry of pathQueue.values()) {\n            pendingCreates += entry.creates\n            pendingUpdates += entry.updates\n            pendingDeletes += entry.deletes\n        }\n\n        Atomics.store(metrics, METRIC_QUEUE_PATH_COUNT, pathQueue.size)\n        Atomics.store(metrics, METRIC_PENDING_CREATE, pendingCreates)\n        Atomics.store(metrics, METRIC_PENDING_UPDATE, pendingUpdates)\n        Atomics.store(metrics, METRIC_PENDING_DELETE, pendingDeletes)\n    }\n\n    if (pathQueue.size === 0) return\n\n    const paths: string[] = []\n    let estimatedSize = 2\n\n    for (const [path, entry] of pathQueue.entries()) {\n        const item = `${path} (c=${entry.creates} u=${entry.updates} d=${entry.deletes})`\n        const itemSize = item.length + 4\n        if (estimatedSize + itemSize > PATH_DATA_MAX_BYTES - 50) {\n            const remaining = pathQueue.size - paths.length\n            paths.push(`... and ${remaining} more paths`)\n            break\n        }\n        paths.push(item)\n        estimatedSize += itemSize\n    }\n\n    const json = JSON.stringify(paths)\n    const bytes = new TextEncoder().encode(json)\n\n    const sabBytes = new Uint8Array(sharedArrayBuffer, PATH_DATA_OFFSET, PATH_DATA_MAX_BYTES)\n    sabBytes.set(bytes)\n\n    if (metrics) {\n        Atomics.store(metrics, PATH_DATA_LENGTH, bytes.length)\n    }\n}\n\n// Read paths from SAB\nexport const readPathsFromSAB = (): string[] => {\n    if (!sharedArrayBuffer) return []\n    const metrics = getMetrics()\n    if (!metrics) return []\n\n    const length = Atomics.load(metrics, PATH_DATA_LENGTH)\n    if (length === 0) return []\n\n    const sabBytes = new Uint8Array(sharedArrayBuffer, PATH_DATA_OFFSET, length)\n    const copyBuffer = new Uint8Array(length)\n    copyBuffer.set(sabBytes)\n    const json = new TextDecoder().decode(copyBuffer)\n\n    try {\n        return JSON.parse(json)\n    } catch {\n        return [`(${length} bytes of path data - JSON truncated)`]\n    }\n}\n","/**\n * VFS Event Constants - SAB layout and metric indices\n */\n\n// SAB layout for metrics\nexport const METRICS_OFFSET = 0\nexport const METRIC_QUEUED_TOTAL = 0\nexport const METRIC_QUEUED_CREATE = 1\nexport const METRIC_QUEUED_UPDATE = 2\nexport const METRIC_QUEUED_DELETE = 3\nexport const METRIC_INTERNAL_TOTAL = 4\nexport const METRIC_INTERNAL_CREATE = 5\nexport const METRIC_INTERNAL_UPDATE = 6\nexport const METRIC_INTERNAL_DELETE = 7\nexport const METRIC_EXTERNAL_TOTAL = 8\nexport const METRIC_EXTERNAL_CREATE = 9\nexport const METRIC_EXTERNAL_UPDATE = 10\nexport const METRIC_EXTERNAL_DELETE = 11\nexport const METRIC_QUEUE_PATH_COUNT = 12\nexport const METRIC_PENDING_CREATE = 13\nexport const METRIC_PENDING_UPDATE = 14\nexport const METRIC_PENDING_DELETE = 15\n\n// Path dump request/response slots\nexport const PATH_REQUEST_FLAG = 16\nexport const PATH_RESPONSE_FLAG = 17\nexport const PATH_DATA_LENGTH = 18\nexport const RESET_GRACE_COUNTER = 19\n\nexport const METRIC_COUNT = 20\n\n// Grace period for reset\nexport const RESET_GRACE_PERIOD = 500\n\n// Path data region\nexport const PATH_DATA_OFFSET = METRIC_COUNT * 4  // 80 bytes\nexport const PATH_DATA_MAX_BYTES = 8192  // 8KB max\n\n// Per-path queue entry\nexport interface PathQueueEntry {\n    creates: number\n    updates: number\n    deletes: number\n    lastMtime: number\n}\n","/**\n * VFS Event Metrics - Accessor object for SAB metrics\n */\n\nimport { sharedArrayBuffer } from './state'\nimport { getMetrics, readPathsFromSAB } from './event-sab'\nimport {\n    METRIC_QUEUED_TOTAL, METRIC_QUEUED_CREATE, METRIC_QUEUED_UPDATE, METRIC_QUEUED_DELETE,\n    METRIC_INTERNAL_TOTAL, METRIC_INTERNAL_CREATE, METRIC_INTERNAL_UPDATE, METRIC_INTERNAL_DELETE,\n    METRIC_EXTERNAL_TOTAL, METRIC_EXTERNAL_CREATE, METRIC_EXTERNAL_UPDATE, METRIC_EXTERNAL_DELETE,\n    METRIC_QUEUE_PATH_COUNT, METRIC_PENDING_CREATE, METRIC_PENDING_UPDATE, METRIC_PENDING_DELETE,\n    PATH_DATA_OFFSET, PATH_DATA_LENGTH\n} from './event-constants'\n\nexport const eventSabMetrics = {\n    // Queued totals\n    get totalQueued(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_QUEUED_TOTAL) : 0\n    },\n    get queuedCreate(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_QUEUED_CREATE) : 0\n    },\n    get queuedUpdate(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_QUEUED_UPDATE) : 0\n    },\n    get queuedDelete(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_QUEUED_DELETE) : 0\n    },\n    // Internal consumed totals\n    get totalInternal(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_INTERNAL_TOTAL) : 0\n    },\n    get internalCreate(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_INTERNAL_CREATE) : 0\n    },\n    get internalUpdate(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_INTERNAL_UPDATE) : 0\n    },\n    get internalDelete(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_INTERNAL_DELETE) : 0\n    },\n    // External detected totals\n    get totalExternal(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_EXTERNAL_TOTAL) : 0\n    },\n    get externalCreate(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_EXTERNAL_CREATE) : 0\n    },\n    get externalUpdate(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_EXTERNAL_UPDATE) : 0\n    },\n    get externalDelete(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_EXTERNAL_DELETE) : 0\n    },\n    // Queue size\n    get queueSize(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_QUEUE_PATH_COUNT) : 0\n    },\n    // Authoritative pending counts\n    get pendingCreate(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_PENDING_CREATE) : 0\n    },\n    get pendingUpdate(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_PENDING_UPDATE) : 0\n    },\n    get pendingDelete(): number {\n        const metrics = getMetrics()\n        return metrics ? Atomics.load(metrics, METRIC_PENDING_DELETE) : 0\n    },\n    get totalPending(): number {\n        const metrics = getMetrics()\n        if (!metrics) return 0\n        return Atomics.load(metrics, METRIC_PENDING_CREATE) +\n               Atomics.load(metrics, METRIC_PENDING_UPDATE) +\n               Atomics.load(metrics, METRIC_PENDING_DELETE)\n    },\n    // Pending paths from SAB\n    get pendingPaths(): string[] {\n        return readPathsFromSAB()\n    },\n}\n","// VFS Index Load/Save Operations\n\nimport { INDEX_HEADER_SIZE, vfsIndex, vfsDirIndex, vfsSymlinkIndex, vfsMetadataIndex, vfsSyncHandle } from './state'\nimport { compactSync } from './compact'\n\n// Index save batching configuration\nconst INDEX_SAVE_DEBOUNCE_MS = 50 // Debounce saves for 50ms\n\n// Batching state\nlet indexDirty = false\nlet indexSaveTimer: ReturnType<typeof setTimeout> | null = null\nlet indexFirstDirtyTime: number | null = null\n\n// Metrics\nexport const indexSaveMetrics = {\n    totalSaves: 0,\n    batchedSaves: 0, // Saves that were batched (not immediate)\n    lastSaveTime: 0,\n}\n\n// Load index from VFS binary\nexport const loadIndex = () => {\n    if (!vfsSyncHandle) return\n\n    const size = vfsSyncHandle.getSize()\n    if (size < INDEX_HEADER_SIZE) return\n\n    const headerBuffer = new ArrayBuffer(INDEX_HEADER_SIZE)\n    vfsSyncHandle.read(new Uint8Array(headerBuffer), { at: 0 })\n    const indexSize = new DataView(headerBuffer).getUint32(0)\n\n    if (indexSize === 0 || indexSize > size - INDEX_HEADER_SIZE) {\n        return\n    }\n\n    // Validate index size is reasonable (max 10MB for index)\n    if (indexSize > 10 * 1024 * 1024) {\n        console.error('[VFS] Index size too large:', indexSize, '- possible corruption')\n        return\n    }\n\n    const indexBuffer = new Uint8Array(indexSize)\n    vfsSyncHandle.read(indexBuffer, { at: INDEX_HEADER_SIZE })\n\n    const indexJson = new TextDecoder().decode(indexBuffer)\n\n    // Handle empty or invalid JSON gracefully\n    if (!indexJson || indexJson.trim() === '') {\n        console.warn('[VFS] Empty index data, starting fresh')\n        return\n    }\n\n    let parsed: any\n    try {\n        parsed = JSON.parse(indexJson)\n    } catch (err) {\n        console.warn('[VFS] Failed to parse index JSON, starting fresh:', err)\n        return\n    }\n\n    vfsIndex.clear()\n    vfsDirIndex.clear()\n    vfsSymlinkIndex.clear()\n    vfsMetadataIndex.clear()\n\n    // Support both old format (array) and new format (object with files/dirs/symlinks/metadata)\n    if (Array.isArray(parsed)) {\n        // Old format: just file entries\n        for (const [path, entry] of parsed as Array<[string, { offset: number; size: number }]>) {\n            vfsIndex.set(path, entry)\n        }\n    } else {\n        // New format: { files: [...], dirs: [...], symlinks: [...], metadata: [...] }\n        for (const [path, entry] of parsed.files || []) {\n            vfsIndex.set(path, entry)\n        }\n        for (const dir of parsed.dirs || []) {\n            vfsDirIndex.add(dir)\n        }\n        for (const [path, target] of parsed.symlinks || []) {\n            vfsSymlinkIndex.set(path, target)\n        }\n        for (const [path, meta] of parsed.metadata || []) {\n            vfsMetadataIndex.set(path, meta)\n        }\n    }\n}\n\n// Internal: Actually perform the index save\nconst performIndexSave = () => {\n    if (!vfsSyncHandle) return\n\n    const indexData = {\n        files: Array.from(vfsIndex.entries()),\n        dirs: Array.from(vfsDirIndex),\n        symlinks: Array.from(vfsSymlinkIndex.entries()),\n        metadata: Array.from(vfsMetadataIndex.entries()),\n    }\n    const indexJson = JSON.stringify(indexData)\n    const indexBytes = new TextEncoder().encode(indexJson)\n    const newIndexEnd = INDEX_HEADER_SIZE + indexBytes.length\n\n    // Find minimum file data offset to check for overflow\n    let minFileOffset = Infinity\n    for (const { offset } of vfsIndex.values()) {\n        if (offset < minFileOffset) {\n            minFileOffset = offset\n        }\n    }\n\n    // If new index would overflow into file data, compact instead\n    if (minFileOffset !== Infinity && newIndexEnd > minFileOffset) {\n        compactSync()\n        return\n    }\n\n    const headerBuffer = new ArrayBuffer(INDEX_HEADER_SIZE)\n    new DataView(headerBuffer).setUint32(0, indexBytes.length)\n\n    vfsSyncHandle.write(new Uint8Array(headerBuffer), { at: 0 })\n    vfsSyncHandle.write(indexBytes, { at: INDEX_HEADER_SIZE })\n    vfsSyncHandle.flush()\n\n    // Update metrics\n    indexSaveMetrics.totalSaves++\n    indexSaveMetrics.lastSaveTime = Date.now()\n\n    // Reset dirty state\n    indexDirty = false\n    indexFirstDirtyTime = null\n}\n\n// Clear the save timer\nconst clearIndexSaveTimer = () => {\n    if (indexSaveTimer) {\n        clearTimeout(indexSaveTimer)\n        indexSaveTimer = null\n    }\n}\n\n// Schedule a batched index save\nconst scheduleIndexSave = () => {\n    // If a timer is already scheduled, let it run - don't reschedule\n    // This prevents indexFirstDirtyTime from accumulating indefinitely during rapid operations\n    // The timer will fire every INDEX_SAVE_DEBOUNCE_MS and reset the dirty time\n    if (indexSaveTimer) {\n        return\n    }\n\n    // Track when we first became dirty (only when scheduling a new timer)\n    indexFirstDirtyTime = Date.now()\n\n    // Schedule the save\n    indexSaveTimer = setTimeout(() => {\n        indexSaveTimer = null\n        indexSaveMetrics.batchedSaves++\n        performIndexSave()\n    }, INDEX_SAVE_DEBOUNCE_MS)\n}\n\n// Save index to VFS binary (batched - defers actual save)\nexport const saveIndex = () => {\n    if (!vfsSyncHandle) return\n\n    indexDirty = true\n    scheduleIndexSave()\n}\n\n// Force immediate index save (for explicit flush or before shutdown)\nexport const flushIndex = () => {\n    if (!vfsSyncHandle || !indexDirty) return\n\n    clearIndexSaveTimer()\n    performIndexSave()\n}\n\n// Check if index has unsaved changes\nexport const isIndexDirty = () => indexDirty\n","// VFS Compaction Operations with Smart Scheduling\n\nimport {\n    INDEX_HEADER_SIZE,\n    vfsIndex,\n    vfsDirIndex,\n    vfsSymlinkIndex,\n    vfsMetadataIndex,\n    vfsSyncHandle,\n    resetWastedBytes,\n    getWastedBytes,\n    COMPACTION_THRESHOLD,\n    COMPACTION_URGENT_THRESHOLD,\n    COMPACTION_DEBOUNCE_MS,\n    COMPACTION_IDLE_TIMEOUT_MS,\n    compactionMetrics,\n    isCompactionScheduled,\n    setCompactionScheduled,\n    clearCompactionTimers,\n    setCompactionDebounceTimer,\n    setCompactionIdleCallback,\n} from './state'\n\n// Internal compaction implementation\nfunction performCompaction(): number {\n    if (!vfsSyncHandle) return 0\n\n    const startTime = performance.now()\n    const wastedBefore = getWastedBytes()\n\n    // Read all current file data\n    const files: Array<{ path: string; data: Uint8Array }> = []\n\n    for (const [path, { offset, size }] of vfsIndex) {\n        // Validate entry before creating typed array\n        if (typeof size !== 'number' || size < 0 || !Number.isFinite(size) || !Number.isInteger(size)) {\n            throw new Error(`Invalid file size in vfsIndex: ${size} for path: ${path}`)\n        }\n\n        const buffer = new Uint8Array(size)\n        vfsSyncHandle.read(buffer, { at: offset })\n        files.push({ path, data: buffer })\n    }\n\n    // Preserve directories, symlinks, and metadata\n    const dirs = Array.from(vfsDirIndex)\n    const symlinks = Array.from(vfsSymlinkIndex.entries())\n    const metadata = Array.from(vfsMetadataIndex.entries())\n\n    // Calculate index size iteratively (same approach as syncOpfsToVfs)\n    // The index contains file offsets which depend on index size,\n    // and index size depends on the string length of those offsets\n    let indexSize = 0\n    let iterations = 0\n    const maxIterations = 10\n\n    while (iterations < maxIterations) {\n        iterations++\n        const headerSize = INDEX_HEADER_SIZE + indexSize\n\n        // Calculate offsets with current header size estimate\n        vfsIndex.clear()\n        let offset = headerSize\n        for (const { path, data } of files) {\n            vfsIndex.set(path, { offset, size: data.length })\n            offset += data.length\n        }\n\n        // Generate index JSON and measure its size\n        const indexData = {\n            files: Array.from(vfsIndex.entries()),\n            dirs,\n            symlinks,\n            metadata,\n        }\n        const indexJson = JSON.stringify(indexData)\n        const indexBytes = new TextEncoder().encode(indexJson)\n        const newIndexSize = indexBytes.length\n\n        if (newIndexSize === indexSize) {\n            // Converged - write the data\n            const headerBuffer = new ArrayBuffer(INDEX_HEADER_SIZE)\n            new DataView(headerBuffer).setUint32(0, indexBytes.length)\n            vfsSyncHandle.write(new Uint8Array(headerBuffer), { at: 0 })\n            vfsSyncHandle.write(indexBytes, { at: INDEX_HEADER_SIZE })\n            break\n        }\n\n        indexSize = newIndexSize\n    }\n\n    if (iterations >= maxIterations) {\n        throw new Error('Failed to converge index size calculation during compaction')\n    }\n\n    // Write file data\n    let writeOffset = INDEX_HEADER_SIZE + indexSize\n    for (const { data } of files) {\n        vfsSyncHandle.write(data, { at: writeOffset })\n        writeOffset += data.length\n    }\n\n    // Truncate excess\n    vfsSyncHandle.truncate(writeOffset)\n    vfsSyncHandle.flush()\n\n    resetWastedBytes()\n\n    // Update metrics\n    const duration = performance.now() - startTime\n    compactionMetrics.totalCompactions++\n    compactionMetrics.totalBytesReclaimed += wastedBefore\n    compactionMetrics.lastCompactionTime = Date.now()\n    compactionMetrics.lastCompactionDuration = duration\n\n    console.log(`[VFS] Compacted to ${writeOffset} bytes (reclaimed ${wastedBefore} bytes in ${duration.toFixed(1)}ms)`)\n\n    return wastedBefore\n}\n\n// Sync version of compact - runs immediately\nexport const compactSync = () => {\n    clearCompactionTimers()\n    setCompactionScheduled(false)\n    performCompaction()\n}\n\n// Async version of compact - runs immediately\nexport const compact = async () => {\n    clearCompactionTimers()\n    setCompactionScheduled(false)\n    performCompaction()\n}\n\n// Schedule compaction with debouncing and idle callback\n// This is the preferred way to trigger compaction from write operations\nexport const scheduleCompaction = () => {\n    const wasted = getWastedBytes()\n\n    // If wasted space is extremely high, compact immediately\n    if (wasted >= COMPACTION_URGENT_THRESHOLD) {\n        compactionMetrics.urgentCompactions++\n        compactSync()\n        return\n    }\n\n    // If below threshold, don't schedule\n    if (wasted < COMPACTION_THRESHOLD) {\n        return\n    }\n\n    // If already scheduled, just reset the debounce timer\n    if (isCompactionScheduled()) {\n        clearCompactionTimers()\n    }\n\n    setCompactionScheduled(true)\n    compactionMetrics.scheduledCompactions++\n\n    // Debounce: wait for activity to settle\n    const debounceTimer = setTimeout(() => {\n        // Try to use requestIdleCallback for non-blocking compaction\n        if (typeof requestIdleCallback !== 'undefined') {\n            const idleCallback = requestIdleCallback(\n                (deadline) => {\n                    // Only compact if we have enough idle time or timeout expired\n                    if (deadline.timeRemaining() > 10 || deadline.didTimeout) {\n                        setCompactionScheduled(false)\n                        performCompaction()\n                    } else {\n                        // Not enough idle time, reschedule\n                        scheduleCompaction()\n                    }\n                },\n                { timeout: COMPACTION_IDLE_TIMEOUT_MS }\n            )\n            setCompactionIdleCallback(idleCallback)\n        } else {\n            // No requestIdleCallback, use setTimeout as fallback\n            setTimeout(() => {\n                setCompactionScheduled(false)\n                performCompaction()\n            }, 0)\n        }\n    }, COMPACTION_DEBOUNCE_MS)\n\n    setCompactionDebounceTimer(debounceTimer)\n}\n\n// Check if compaction should be scheduled (call this after writes/deletes)\nexport const maybeScheduleCompaction = () => {\n    const wasted = getWastedBytes()\n\n    if (wasted >= COMPACTION_URGENT_THRESHOLD) {\n        // Urgent: compact immediately\n        compactionMetrics.urgentCompactions++\n        compactSync()\n    } else if (wasted >= COMPACTION_THRESHOLD && !isCompactionScheduled()) {\n        // Schedule for later\n        scheduleCompaction()\n    }\n}\n\n// Get compaction status and metrics\nexport const getCompactionStatus = () => ({\n    scheduled: isCompactionScheduled(),\n    wastedBytes: getWastedBytes(),\n    threshold: COMPACTION_THRESHOLD,\n    urgentThreshold: COMPACTION_URGENT_THRESHOLD,\n    ...compactionMetrics,\n})\n","// VFS File Operations\n\nimport { vfsIndex, vfsDirIndex, vfsMetadataIndex, vfsSyncHandle, addWastedBytes, isDeferredFlushMode, defaultFileMetadata } from './state'\nimport { saveIndex } from './index-ops'\nimport { maybeScheduleCompaction } from './compact'\nimport { queueOpfsSync } from './opfs-sync-queue'\nimport { normalizePath, isRootPath } from './path'\nimport { isSymlinkInVfs, resolveSymlinkInVfs } from './symlinks'\n\n// Read file from VFS (sync) - returns raw bytes\nexport const readFromVfs = (path: string): Uint8Array | null => {\n    let normalizedPath = normalizePath(path)\n\n    // Resolve symlinks to get actual file path\n    if (isSymlinkInVfs(normalizedPath)) {\n        normalizedPath = resolveSymlinkInVfs(normalizedPath)\n    }\n    const entry = vfsIndex.get(normalizedPath)\n    if (!entry || !vfsSyncHandle) return null\n\n    // Validate entry before creating typed array\n    if (typeof entry.size !== 'number' || entry.size < 0 || !Number.isFinite(entry.size)) {\n        console.error('[VFS] Invalid entry size:', entry.size, 'for path:', normalizedPath)\n        return null\n    }\n    if (typeof entry.offset !== 'number' || entry.offset < 0 || !Number.isFinite(entry.offset)) {\n        console.error('[VFS] Invalid entry offset:', entry.offset, 'for path:', normalizedPath)\n        return null\n    }\n\n    try {\n        const buffer = new Uint8Array(entry.size)\n        vfsSyncHandle.read(buffer, { at: entry.offset })\n        return buffer\n    } catch (err) {\n        console.error('[VFS] Error reading file:', normalizedPath, 'size:', entry.size, 'offset:', entry.offset, err)\n        throw err\n    }\n}\n\n// Read a chunk of a file from VFS (sync) - for large file streaming\nexport const readChunkFromVfs = (path: string, start: number, length: number): Uint8Array | null => {\n    let normalizedPath = normalizePath(path)\n\n    // Resolve symlinks to get actual file path\n    if (isSymlinkInVfs(normalizedPath)) {\n        normalizedPath = resolveSymlinkInVfs(normalizedPath)\n    }\n\n    const entry = vfsIndex.get(normalizedPath)\n    if (!entry || !vfsSyncHandle) return null\n\n    // Clamp to file bounds\n    const actualStart = Math.min(start, entry.size)\n    const actualLength = Math.min(length, entry.size - actualStart)\n    if (actualLength <= 0) return new Uint8Array(0)\n\n    const buffer = new Uint8Array(actualLength)\n    vfsSyncHandle.read(buffer, { at: entry.offset + actualStart })\n    return buffer\n}\n\n// Get file size from VFS without reading content\nexport const getFileSizeFromVfs = (path: string): number | null => {\n    let normalizedPath = normalizePath(path)\n\n    // Resolve symlinks to get actual file path\n    if (isSymlinkInVfs(normalizedPath)) {\n        normalizedPath = resolveSymlinkInVfs(normalizedPath)\n    }\n\n    const entry = vfsIndex.get(normalizedPath)\n    if (!entry) return null\n    return entry.size\n}\n\n// Read file from VFS (sync) - with encoding options\nexport const readFileFromVfs = (path: string, options?: { encoding?: BufferEncoding } | BufferEncoding): string | Buffer | null => {\n    const buffer = readFromVfs(path)\n    if (!buffer) return null\n\n    const encoding = typeof options === 'string' ? options : options?.encoding\n    if (encoding) {\n        return new TextDecoder(encoding).decode(buffer)\n    }\n    return Buffer.from(buffer)\n}\n\n// Write file to VFS (sync) - accepts raw bytes\nexport const writeToVfs = (path: string, data: Uint8Array) => {\n    if (!vfsSyncHandle) {\n        console.error(`[writeToVfs] SKIPPED - vfsSyncHandle is null! path: ${path}`)\n        return\n    }\n\n    const normalizedPath = normalizePath(path)\n    const existingEntry = vfsIndex.get(normalizedPath)\n\n    if (existingEntry && existingEntry.size === data.length) {\n        // Same size - overwrite in place\n        vfsSyncHandle.write(data, { at: existingEntry.offset })\n    } else {\n        if (existingEntry) {\n            addWastedBytes(existingEntry.size)\n        }\n        // Append after current data\n        const offset = vfsSyncHandle.getSize()\n        vfsSyncHandle.write(data, { at: offset })\n        vfsIndex.set(normalizedPath, { offset, size: data.length })\n        saveIndex()\n\n        // Schedule compaction if needed (debounced, runs during idle time)\n        maybeScheduleCompaction()\n    }\n\n    // Update mtime for 100% safe external change detection\n    // When observer fires, syncFileToVfs compares OPFS mtime vs VFS mtime\n    // If VFS mtime is newer, sync is skipped (prevents stale OPFS overwriting newer VFS)\n    const now = Date.now()\n    const existingMetadata = vfsMetadataIndex.get(normalizedPath) || defaultFileMetadata()\n    vfsMetadataIndex.set(normalizedPath, { ...existingMetadata, mtime: now })\n\n    // Flush unless in deferred flush mode (for bulk operations)\n    if (!isDeferredFlushMode()) {\n        vfsSyncHandle.flush()\n    }\n\n    // Queue background sync to OPFS (hybrid mode only)\n    queueOpfsSync('write', normalizedPath)\n}\n\n// Write file to VFS (sync) - accepts string or Buffer\nexport const writeFileToVfs = (path: string, data: string | Buffer) => {\n    const content = typeof data === 'string' ? new TextEncoder().encode(data) : new Uint8Array(data ?? new ArrayBuffer(0))\n    writeToVfs(path, content)\n}\n\n// Check if file exists in VFS (sync)\nexport const existsInVfs = (path: string): boolean => {\n    // Root and current directory always exist\n    if (isRootPath(path)) return true\n\n    const normalizedPath = normalizePath(path)\n    if (normalizedPath === '') return true\n\n    // Check if it's a symlink\n    if (isSymlinkInVfs(normalizedPath)) return true\n\n    // Check if it's a file\n    if (vfsIndex.has(normalizedPath)) return true\n\n    // Check if it's an explicit directory\n    if (vfsDirIndex.has(normalizedPath)) return true\n\n    // Check if it's an implicit directory (any file starts with this path)\n    const prefix = `${normalizedPath}/`\n    for (const filePath of vfsIndex.keys()) {\n        if (filePath.startsWith(prefix)) {\n            return true\n        }\n    }\n\n    // Check if any explicit dir starts with this path\n    for (const dirPath of vfsDirIndex) {\n        if (dirPath.startsWith(prefix)) {\n            return true\n        }\n    }\n\n    return false\n}\n\n// Delete file from VFS (sync)\nexport const deleteFromVfs = (path: string) => {\n    const normalizedPath = normalizePath(path)\n    const entry = vfsIndex.get(normalizedPath)\n    if (entry) {\n        addWastedBytes(entry.size)\n        vfsIndex.delete(normalizedPath)\n        saveIndex()\n\n        // Schedule compaction if needed (debounced, runs during idle time)\n        maybeScheduleCompaction()\n\n        // Queue background sync to OPFS (hybrid mode only)\n        queueOpfsSync('delete', normalizedPath)\n    }\n}\n\n// Get VFS file index (for readdir, etc.)\nexport const getVfsIndex = () => vfsIndex\n","// VFS to OPFS Background Sync Queue\n// Collects VFS changes and syncs to OPFS via dedicated worker (hybrid mode only)\n\nimport { readFromVfs } from './files'\nimport { isFireAndForgetMode } from './state'\nimport { getStorageMode } from '../config'\nimport { normalizePath } from './path'\n\n// Sync operation types\nexport type OpfsSyncType = 'write' | 'delete' | 'mkdir' | 'rmdir'\n\ninterface OpfsSyncEntry {\n    type: OpfsSyncType\n    path: string\n    timestamp: number\n}\n\ninterface OpfsSyncWorkerEntry {\n    type: OpfsSyncType\n    path: string\n    data?: Uint8Array\n}\n\n// Configuration\n// Reduced from 500ms to 100ms for better data consistency\n// Lower delay means faster sync to OPFS, reducing data loss risk on crash\nconst OPFS_SYNC_DEBOUNCE_MS = 100\n\n// Queue state\nconst pendingOpfsSync = new Map<string, OpfsSyncEntry>()\nlet opfsSyncScheduled = false\nlet opfsSyncDebounceTimer: ReturnType<typeof setTimeout> | null = null\nlet opfsSyncWorker: Worker | null = null\nlet workerReady = false\nlet pendingBatchId = 0\n\n// Metrics\nexport const opfsSyncMetrics = {\n    totalSyncs: 0,\n    totalWrites: 0,\n    totalDeletes: 0,\n    totalMkdirs: 0,\n    totalRmdirs: 0,\n    lastSyncTime: 0,\n    lastSyncDuration: 0,\n    queueHighWaterMark: 0,\n    batchesSent: 0,\n    entriesProcessed: 0,\n    errors: 0,\n}\n\n// Initialize the dedicated sync worker\nconst ensureWorker = (): Worker => {\n    if (!opfsSyncWorker) {\n        opfsSyncWorker = new Worker(\n            new URL('./opfs-sync.worker.js', import.meta.url),\n            { type: 'module' }\n        )\n\n        opfsSyncWorker.onmessage = (event) => {\n            const { type, id, results } = event.data\n\n            if (type === 'ready' || type === 'initialized') {\n                workerReady = true\n                // Process any pending queue\n                if (pendingOpfsSync.size > 0 && !opfsSyncScheduled) {\n                    maybeScheduleOpfsSync()\n                }\n                return\n            }\n\n            if (type === 'batch-complete') {\n                const duration = performance.now() - opfsSyncMetrics.lastSyncTime\n                opfsSyncMetrics.lastSyncDuration = duration\n\n                let successCount = 0\n                let errorCount = 0\n\n                for (const result of results) {\n                    if (result.success) {\n                        successCount++\n                    } else {\n                        errorCount++\n                        console.warn(`[OPFS Sync] Failed: ${result.path} - ${result.error}`)\n                    }\n                }\n\n                opfsSyncMetrics.entriesProcessed += successCount\n                opfsSyncMetrics.errors += errorCount\n\n                console.log(`[OPFS Sync] Batch ${id} complete: ${successCount} success, ${errorCount} errors in ${duration.toFixed(1)}ms`)\n\n                // Check if more entries queued during processing\n                if (pendingOpfsSync.size > 0) {\n                    maybeScheduleOpfsSync()\n                }\n            }\n        }\n\n        opfsSyncWorker.onerror = (err) => {\n            console.error('[OPFS Sync] Worker error:', err)\n            opfsSyncMetrics.errors++\n        }\n\n        // Initialize the worker\n        opfsSyncWorker.postMessage({ type: 'init' })\n    }\n\n    return opfsSyncWorker\n}\n\n// Clear scheduling timer\nconst clearOpfsSyncTimer = () => {\n    if (opfsSyncDebounceTimer) {\n        clearTimeout(opfsSyncDebounceTimer)\n        opfsSyncDebounceTimer = null\n    }\n}\n\n// Queue an OPFS sync operation (coalesces by path)\nexport const queueOpfsSync = (type: OpfsSyncType, path: string) => {\n    // Only queue in hybrid mode\n    if (getStorageMode() !== 'hybrid') return\n\n    // Skip if in fire-and-forget mode (OPFS already has the data from async method)\n    if (isFireAndForgetMode()) return\n\n    const normalizedPath = normalizePath(path)\n    if (!normalizedPath) return\n\n    // Coalesce by path - newer operation always supersedes older\n    // This handles sequences like: write  delete  write (recreate file)\n    // The latest operation is what matters for the final OPFS state\n    pendingOpfsSync.set(normalizedPath, { type, path: normalizedPath, timestamp: Date.now() })\n\n    // Track high water mark\n    if (pendingOpfsSync.size > opfsSyncMetrics.queueHighWaterMark) {\n        opfsSyncMetrics.queueHighWaterMark = pendingOpfsSync.size\n    }\n\n    maybeScheduleOpfsSync()\n}\n\n// Schedule OPFS sync with debouncing\nconst maybeScheduleOpfsSync = () => {\n    if (pendingOpfsSync.size === 0) return\n    if (opfsSyncScheduled) {\n        // Already scheduled, just reset debounce timer\n        clearOpfsSyncTimer()\n    }\n\n    opfsSyncScheduled = true\n\n    // Debounce: wait for activity to settle\n    opfsSyncDebounceTimer = setTimeout(() => {\n        dispatchToWorker()\n    }, OPFS_SYNC_DEBOUNCE_MS)\n}\n\n// Dispatch pending entries to the worker\nconst dispatchToWorker = () => {\n    if (pendingOpfsSync.size === 0) {\n        opfsSyncScheduled = false\n        return\n    }\n\n    // Ensure worker is ready\n    const worker = ensureWorker()\n    if (!workerReady) {\n        // Worker not ready yet, will be called when ready\n        opfsSyncScheduled = false\n        return\n    }\n\n    // Prepare batch with file content for writes\n    const entries: OpfsSyncWorkerEntry[] = []\n\n    for (const [path, entry] of pendingOpfsSync) {\n        const workerEntry: OpfsSyncWorkerEntry = {\n            type: entry.type,\n            path: entry.path,\n        }\n\n        // For writes, include the current VFS content\n        if (entry.type === 'write') {\n            const content = readFromVfs(entry.path)\n            if (content) {\n                workerEntry.data = content\n            } else {\n                // File no longer in VFS, skip or convert to delete\n                continue\n            }\n        }\n\n        entries.push(workerEntry)\n\n        // Update metrics\n        switch (entry.type) {\n            case 'write': opfsSyncMetrics.totalWrites++; break\n            case 'delete': opfsSyncMetrics.totalDeletes++; break\n            case 'mkdir': opfsSyncMetrics.totalMkdirs++; break\n            case 'rmdir': opfsSyncMetrics.totalRmdirs++; break\n        }\n    }\n\n    // Clear pending queue\n    pendingOpfsSync.clear()\n    opfsSyncScheduled = false\n\n    if (entries.length === 0) return\n\n    // Send batch to worker\n    const batchId = ++pendingBatchId\n    opfsSyncMetrics.batchesSent++\n    opfsSyncMetrics.totalSyncs++\n    opfsSyncMetrics.lastSyncTime = performance.now()\n\n    // Transfer ArrayBuffers for zero-copy\n    const transferables: ArrayBuffer[] = entries\n        .filter(e => e.data)\n        .map(e => e.data!.buffer as ArrayBuffer)\n\n    worker.postMessage(\n        { type: 'process-batch', id: batchId, entries },\n        transferables\n    )\n\n    console.log(`[OPFS Sync] Dispatched batch ${batchId} with ${entries.length} entries`)\n}\n\n// Force immediate sync (for testing or explicit flush)\nexport const flushOpfsSync = async (): Promise<void> => {\n    clearOpfsSyncTimer()\n\n    if (pendingOpfsSync.size > 0) {\n        dispatchToWorker()\n    }\n\n    // Wait a bit for worker to process\n    // In a real implementation, we'd wait for batch-complete message\n    await new Promise(resolve => setTimeout(resolve, 100))\n}\n\n// Get sync queue status\nexport const getOpfsSyncStatus = () => ({\n    scheduled: opfsSyncScheduled,\n    workerReady,\n    pendingCount: pendingOpfsSync.size,\n    pendingPaths: Array.from(pendingOpfsSync.keys()),\n    ...opfsSyncMetrics,\n})\n\n// Clear the queue (for testing)\nexport const clearOpfsSyncQueue = () => {\n    clearOpfsSyncTimer()\n    pendingOpfsSync.clear()\n    opfsSyncScheduled = false\n}\n\n// Terminate the worker (for cleanup)\nexport const terminateOpfsSyncWorker = () => {\n    if (opfsSyncWorker) {\n        opfsSyncWorker.terminate()\n        opfsSyncWorker = null\n        workerReady = false\n    }\n}\n","/**\n * FS Polyfill Configuration\n * Manages storage modes and other configuration options\n */\n\nimport type { LoggerConfig } from './logger'\n\n/**\n * Storage mode determines how sync and async operations are handled\n *\n * - 'hybrid' (default): Sync uses VFS binary file (single persistent OPFS file), async uses OPFS native structure\n * - 'vfs-only': Both sync and async use VFS binary file (async wraps sync)\n * - 'opfs-only': Both use OPFS native directory/file structure (sync uses SAB+async internally)\n */\nexport type StorageMode = 'hybrid' | 'vfs-only' | 'opfs-only'\n\n/**\n * Full FS polyfill configuration\n */\nexport interface FsConfig {\n    /**\n     * Storage mode - must be set before initialization\n     */\n    storageMode: StorageMode\n\n    /**\n     * Logging configuration\n     */\n    logging: LoggerConfig\n}\n\n/**\n * Default configuration\n */\nexport const defaultConfig: FsConfig = {\n    storageMode: 'hybrid',\n    logging: {\n        enabled: false,\n        level: 'info',\n        console: true,\n        buffer: false,\n        bufferSize: 1000,\n    },\n}\n\n// Current configuration state\nlet config: FsConfig = { ...defaultConfig, logging: { ...defaultConfig.logging } }\nlet initialized = false\n\n/**\n * Configure the FS polyfill\n * Must be called before any fs operation for storage mode to take effect\n */\nexport function configure(options: Partial<FsConfig>): void {\n    if (initialized && options.storageMode !== undefined && options.storageMode !== config.storageMode) {\n        console.warn(\n            '[FS Config] storageMode cannot be changed after initialization. ' +\n            `Current mode: ${config.storageMode}, requested: ${options.storageMode}`\n        )\n        // Still allow other options to be updated\n        const { storageMode, ...rest } = options\n        options = rest\n    }\n\n    if (options.storageMode !== undefined) {\n        config.storageMode = options.storageMode\n    }\n\n    if (options.logging !== undefined) {\n        config.logging = { ...config.logging, ...options.logging }\n    }\n}\n\n/**\n * Get current configuration\n */\nexport function getConfig(): FsConfig {\n    return {\n        ...config,\n        logging: { ...config.logging },\n    }\n}\n\n/**\n * Get current storage mode\n */\nexport function getStorageMode(): StorageMode {\n    return config.storageMode\n}\n\n/**\n * Mark the polyfill as initialized\n * After this, storage mode cannot be changed\n */\nexport function markInitialized(): void {\n    initialized = true\n}\n\n/**\n * Check if the polyfill has been initialized\n */\nexport function isInitialized(): boolean {\n    return initialized\n}\n\n/**\n * Reset configuration (mainly for testing)\n */\nexport function resetConfig(): void {\n    config = { ...defaultConfig, logging: { ...defaultConfig.logging } }\n    initialized = false\n}\n\n/**\n * Storage mode descriptions for help/documentation\n */\nexport const storageModeDescriptions: Record<StorageMode, string> = {\n    'hybrid': 'Sync operations use VFS binary file (single persistent OPFS file), async operations use OPFS native structure. Best performance for mixed workloads.',\n    'vfs-only': 'All operations use VFS binary file. Async methods wrap sync operations. Single file contains entire filesystem state.',\n    'opfs-only': 'All operations use OPFS native directory/file structure directly. Sync methods use SAB with async OPFS internally. No VFS binary file.',\n}\n\nexport default {\n    configure,\n    getConfig,\n    getStorageMode,\n    markInitialized,\n    isInitialized,\n    resetConfig,\n    storageModeDescriptions,\n}\n","// VFS Symlink Operations\n\nimport { vfsSymlinkIndex, vfsMetadataIndex } from './state'\nimport { saveIndex } from './index-ops'\nimport { normalizePath, getParentPath, joinPath } from './path'\n\n// Create symlink in VFS\nexport const createSymlinkInVfs = (linkPath: string, targetPath: string) => {\n    const normalizedLink = normalizePath(linkPath)\n    vfsSymlinkIndex.set(normalizedLink, targetPath)\n    // Set metadata for symlink (mode 0o120777 = symlink)\n    vfsMetadataIndex.set(normalizedLink, {\n        mode: 0o120777,\n        uid: 0,\n        gid: 0,\n        mtime: Date.now(),\n        atime: Date.now(),\n    })\n    saveIndex()\n}\n\n// Read symlink target from VFS\nexport const readSymlinkFromVfs = (linkPath: string): string | null => {\n    const normalizedLink = normalizePath(linkPath)\n    return vfsSymlinkIndex.get(normalizedLink) || null\n}\n\n// Check if path is a symlink in VFS\nexport const isSymlinkInVfs = (path: string): boolean => {\n    const normalizedPath = normalizePath(path)\n    return vfsSymlinkIndex.has(normalizedPath)\n}\n\n// Delete symlink from VFS\nexport const deleteSymlinkFromVfs = (linkPath: string) => {\n    const normalizedLink = normalizePath(linkPath)\n    vfsSymlinkIndex.delete(normalizedLink)\n    vfsMetadataIndex.delete(normalizedLink)\n    saveIndex()\n}\n\n// Resolve symlink (follow the chain)\nexport const resolveSymlinkInVfs = (path: string, maxDepth: number = 40): string => {\n    let currentPath = normalizePath(path)\n    let depth = 0\n\n    while (vfsSymlinkIndex.has(currentPath) && depth < maxDepth) {\n        const target = vfsSymlinkIndex.get(currentPath)!\n        // Handle relative vs absolute targets\n        if (target.startsWith('/')) {\n            currentPath = normalizePath(target)\n        } else {\n            // Relative to parent directory\n            const parentDir = getParentPath(currentPath)\n            currentPath = joinPath(parentDir, target)\n        }\n        depth++\n    }\n\n    if (depth >= maxDepth) {\n        throw new Error(`ELOOP: too many levels of symbolic links, '${path}'`)\n    }\n\n    return currentPath\n}\n\n// Get VFS symlink index\nexport const getVfsSymlinkIndex = () => vfsSymlinkIndex\n","// VFS Directory Operations\n\nimport { vfsIndex, vfsDirIndex } from './state'\nimport { saveIndex } from './index-ops'\nimport { queueOpfsSync } from './opfs-sync-queue'\nimport { normalizePath, isRootPath } from './path'\n\n// Common file extensions that indicate a path is likely a file, not a directory\n// Used as a defensive check to prevent false positive directory detection\nconst FILE_EXTENSIONS = /\\.(ts|tsx|js|jsx|mjs|cjs|mts|cts|vue|svelte|json|css|scss|sass|less|html|htm|md|txt|xml|yaml|yml|toml|wasm|map|d\\.ts)$/i\n\n// Check if path is a directory in VFS\nexport const isDirectoryInVfs = (path: string): boolean => {\n    // Root and current directory always exist\n    if (isRootPath(path)) return true\n\n    const normalizedPath = normalizePath(path)\n    if (!normalizedPath) return true // Empty = root\n\n    // Explicit directory - O(1) lookup\n    if (vfsDirIndex.has(normalizedPath)) return true\n\n    // Check if it's actually a file (not a directory)\n    if (vfsIndex.has(normalizedPath)) return false\n\n    // Skip implicit directory check for paths that look like files\n    // This prevents false positives from VFS state inconsistencies\n    if (FILE_EXTENSIONS.test(normalizedPath)) return false\n\n    // Implicit directory check - check if any file/dir has this as parent\n    // Exit early on first match for better average case\n    const prefix = `${normalizedPath}/`\n\n    for (const filePath of vfsIndex.keys()) {\n        if (filePath.startsWith(prefix)) return true\n    }\n\n    for (const dirPath of vfsDirIndex) {\n        if (dirPath.startsWith(prefix)) return true\n    }\n\n    return false\n}\n\n// Create directory in VFS (sync) - with optional save deferral for batching\nexport const createDirInVfs = (path: string, deferSave = false) => {\n    if (!path) return\n    const normalizedPath = normalizePath(path)\n    if (!normalizedPath) return\n\n    vfsDirIndex.add(normalizedPath)\n\n    if (!deferSave) {\n        saveIndex()\n    }\n\n    // Queue background sync to OPFS (hybrid mode only)\n    queueOpfsSync('mkdir', normalizedPath)\n}\n\n// Delete directory from VFS (sync)\nexport const deleteDirFromVfs = (path: string) => {\n    const normalizedPath = normalizePath(path)\n    vfsDirIndex.delete(normalizedPath)\n    saveIndex()\n\n    // Queue background sync to OPFS (hybrid mode only)\n    queueOpfsSync('rmdir', normalizedPath)\n}\n\n// Get VFS directory index\nexport const getVfsDirIndex = () => vfsDirIndex\n","// VFS Metadata Operations\n\nimport type { FileMetadata } from './types'\nimport { vfsMetadataIndex, defaultFileMetadata } from './state'\nimport { saveIndex } from './index-ops'\nimport { normalizePath } from './path'\n\n// Get file/dir metadata\nexport const getMetadataFromVfs = (path: string): FileMetadata | null => {\n    const normalizedPath = normalizePath(path)\n    return vfsMetadataIndex.get(normalizedPath) || null\n}\n\n// Set file/dir metadata\nexport const setMetadataInVfs = (path: string, metadata: Partial<FileMetadata>) => {\n    const normalizedPath = normalizePath(path)\n    const existing = vfsMetadataIndex.get(normalizedPath) || defaultFileMetadata()\n    vfsMetadataIndex.set(normalizedPath, { ...existing, ...metadata })\n    saveIndex()\n}\n\n// Set chmod (mode only)\nexport const chmodInVfs = (path: string, mode: number) => {\n    const normalizedPath = normalizePath(path)\n    const existing = vfsMetadataIndex.get(normalizedPath) || defaultFileMetadata()\n    vfsMetadataIndex.set(normalizedPath, { ...existing, mode })\n    saveIndex()\n}\n\n// Set chown (uid/gid)\nexport const chownInVfs = (path: string, uid: number, gid: number) => {\n    const normalizedPath = normalizePath(path)\n    const existing = vfsMetadataIndex.get(normalizedPath) || defaultFileMetadata()\n    vfsMetadataIndex.set(normalizedPath, { ...existing, uid, gid })\n    saveIndex()\n}\n\n// Set utimes (atime/mtime)\nexport const utimesInVfs = (path: string, atime: number, mtime: number) => {\n    const normalizedPath = normalizePath(path)\n    const existing = vfsMetadataIndex.get(normalizedPath) || defaultFileMetadata()\n    vfsMetadataIndex.set(normalizedPath, { ...existing, atime, mtime })\n    saveIndex()\n}\n\n// Get VFS metadata index\nexport const getVfsMetadataIndex = () => vfsMetadataIndex\n","// VFS Watch Listener Operations\n\nimport type { WatchListener } from './types'\nimport { watchListeners } from './state'\nimport { normalizePath, getBasename, getParentPath } from './path'\n\n// Register a watch listener for a path\nexport const addWatchListener = (path: string, listener: WatchListener) => {\n    const normalizedPath = normalizePath(path)\n    if (!watchListeners.has(normalizedPath)) {\n        watchListeners.set(normalizedPath, new Set())\n    }\n    watchListeners.get(normalizedPath)!.add(listener)\n}\n\n// Remove a watch listener\nexport const removeWatchListener = (path: string, listener: WatchListener) => {\n    const normalizedPath = normalizePath(path)\n    const listeners = watchListeners.get(normalizedPath)\n    if (listeners) {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n            watchListeners.delete(normalizedPath)\n        }\n    }\n}\n\n// Notify all listeners for a path (called when file changes)\nexport const notifyWatchListeners = (path: string, eventType: 'rename' | 'change') => {\n    const normalizedPath = normalizePath(path)\n    const filename = getBasename(normalizedPath)\n\n    // Notify exact path listeners\n    const listeners = watchListeners.get(normalizedPath)\n    if (listeners) {\n        for (const listener of listeners) {\n            try {\n                listener(eventType, filename)\n            } catch (e) {\n                console.error('[VFS] Watch listener error:', e)\n            }\n        }\n    }\n\n    // Notify parent directory listeners (for recursive watches)\n    const parentPath = getParentPath(normalizedPath)\n    if (parentPath) {\n        const parentListeners = watchListeners.get(parentPath)\n        if (parentListeners) {\n            for (const listener of parentListeners) {\n                try {\n                    listener(eventType, filename)\n                } catch (e) {\n                    console.error('[VFS] Watch listener error:', e)\n                }\n            }\n        }\n    }\n}\n","// VFS Sync Operations - OPFS <-> VFS synchronization\n\nimport { vfsIndex, vfsDirIndex, vfsSymlinkIndex, vfsMetadataIndex, vfsSyncHandle, root, VFS_FILENAME, INDEX_HEADER_SIZE, addWastedBytes, resetWastedBytes, defaultFileMetadata } from './state'\nimport { saveIndex } from './index-ops'\nimport { maybeScheduleCompaction } from './compact'\nimport { normalizePath } from './path'\n\n// Progress callback type\nexport type SyncProgressCallback = (info: {\n    phase: 'scanning' | 'deleting' | 'reading' | 'writing'\n    current: number\n    total: number\n    filename?: string\n}) => void\n\n// Result of sync attempt - used for metrics and logging\nexport type SyncResult = 'synced' | 'skipped_vfs_newer' | 'skipped_directory' | 'error'\n\n// Inline async readFile to avoid circular dependency\n// Handles nested paths like \"folder/subfolder/file.txt\"\n// Returns both content and mtime for safe sync comparison\n// Returns null if path is a directory (not a file)\nconst readFileFromOpfs = async (opfsRoot: FileSystemDirectoryHandle, path: string): Promise<{ content: Buffer; mtime: number } | null> => {\n    const parts = path.split('/').filter(p => p.length > 0)\n    if (parts.length === 0) throw new Error('Invalid path')\n\n    // Navigate to parent directory\n    let currentDir = opfsRoot\n    for (let i = 0; i < parts.length - 1; i++) {\n        currentDir = await currentDir.getDirectoryHandle(parts[i])\n    }\n\n    // Get file from final directory\n    const fileName = parts[parts.length - 1]\n    try {\n        const fileHandle = await currentDir.getFileHandle(fileName)\n        const file = await fileHandle.getFile()\n        const buffer = await file.arrayBuffer()\n        return {\n            content: Buffer.from(buffer),\n            mtime: file.lastModified\n        }\n    } catch (err) {\n        // TypeMismatchError means the path exists but is a directory, not a file\n        if ((err as Error).name === 'TypeMismatchError') {\n            return null\n        }\n        throw err\n    }\n}\n\n// Ensure parent directories exist in VFS dir index\nconst ensureParentDirs = (path: string) => {\n    const parts = path.split('/').filter(p => p.length > 0)\n    // Build parent paths and add to dir index\n    for (let i = 1; i < parts.length; i++) {\n        const dirPath = parts.slice(0, i).join('/')\n        vfsDirIndex.add(dirPath)\n    }\n}\n\n// Sync a file from OPFS to VFS binary\n// Returns SyncResult indicating what happened\n// IMPORTANT: This function is 100% safe - it will NEVER overwrite newer VFS data with stale OPFS data\n// by comparing mtimes before writing. This protects against race conditions where:\n// - VFS has version N+1, but OPFS sync queue hasn't caught up yet (still at N)\n// - Observer fires for version N\n// - Without mtime check, we'd overwrite N+1 with N (data loss!)\nexport const syncFileToVfs = async (path: string): Promise<SyncResult> => {\n    if (!root || !vfsSyncHandle) return 'error'\n\n    // Normalize path for VFS storage (removes leading/trailing slashes)\n    const normalizedPath = normalizePath(path)\n\n    // Read OPFS file with its mtime (returns null if path is a directory)\n    const fileData = await readFileFromOpfs(root, path)\n    if (fileData === null) {\n        // Path is a directory, not a file - just ensure it's tracked in VFS\n        vfsDirIndex.add(normalizedPath)\n        return 'skipped_directory'\n    }\n\n    const { content, mtime: opfsMtime } = fileData\n\n    // Check VFS mtime - if VFS is newer, don't overwrite (VFS is authoritative)\n    const vfsMetadata = vfsMetadataIndex.get(normalizedPath)\n    if (vfsMetadata && vfsMetadata.mtime > opfsMtime) {\n        // VFS has newer data than OPFS - this is an internal change that hasn't synced to OPFS yet\n        // Skip to avoid overwriting newer VFS data with stale OPFS data\n        return 'skipped_vfs_newer'\n    }\n\n    // Ensure parent directories are tracked\n    ensureParentDirs(normalizedPath)\n\n    const existingEntry = vfsIndex.get(normalizedPath)\n\n    if (existingEntry && existingEntry.size === content.length) {\n        // Same size - overwrite in place\n        vfsSyncHandle.write(content, { at: existingEntry.offset })\n    } else {\n        if (existingEntry) {\n            // Mark old space as wasted\n            addWastedBytes(existingEntry.size)\n        }\n        // Append to end\n        const offset = vfsSyncHandle.getSize()\n        vfsSyncHandle.write(content, { at: offset })\n        vfsIndex.set(normalizedPath, { offset, size: content.length })\n        saveIndex()\n\n        // Schedule compaction if needed (debounced, runs during idle time)\n        maybeScheduleCompaction()\n    }\n\n    // Update VFS metadata with OPFS mtime\n    const existingMetadata = vfsMetadataIndex.get(normalizedPath) || defaultFileMetadata()\n    vfsMetadataIndex.set(normalizedPath, { ...existingMetadata, mtime: opfsMtime })\n\n    vfsSyncHandle.flush()\n    return 'synced'\n}\n\n// Remove a file from VFS index (data remains until compaction)\nexport const removeFileFromVfs = (path: string) => {\n    const normalizedPath = normalizePath(path)\n    const entry = vfsIndex.get(normalizedPath)\n    if (entry) {\n        addWastedBytes(entry.size)\n        vfsIndex.delete(normalizedPath)\n        saveIndex()\n\n        // Schedule compaction if needed (debounced, runs during idle time)\n        maybeScheduleCompaction()\n    }\n}\n\n// Hydration: Extract all files from VFS binary to OPFS\n// Removes existing OPFS files first (except .vfs.bin)\nexport const syncVfsToOpfs = async (onProgress?: SyncProgressCallback) => {\n    if (!root || !vfsSyncHandle) throw new Error('VFS not initialized')\n\n    // Collect entries to delete first (for progress tracking)\n    const entriesToDelete: string[] = []\n    for await (const [name] of (root as any).entries()) {\n        if (name !== VFS_FILENAME) {\n            entriesToDelete.push(name)\n        }\n    }\n\n    // Delete existing files in OPFS (except .vfs.bin)\n    for (let i = 0; i < entriesToDelete.length; i++) {\n        const name = entriesToDelete[i]\n        onProgress?.({ phase: 'deleting', current: i + 1, total: entriesToDelete.length, filename: name })\n        await root.removeEntry(name, { recursive: true })\n    }\n\n    // Extract all files from VFS to OPFS\n    const entries = Array.from(vfsIndex.entries())\n    const directories = Array.from(vfsDirIndex)\n    const total = entries.length + directories.length\n\n    for (let i = 0; i < entries.length; i++) {\n        const [path, { offset, size }] = entries[i]\n        onProgress?.({ phase: 'writing', current: i + 1, total, filename: path })\n\n        const buffer = new Uint8Array(size)\n        vfsSyncHandle.read(buffer, { at: offset })\n\n        // Handle nested paths by creating directories\n        const parts = path.split('/')\n        let currentDir = root\n\n        for (let j = 0; j < parts.length - 1; j++) {\n            currentDir = await currentDir.getDirectoryHandle(parts[j], { create: true })\n        }\n\n        const fileName = parts[parts.length - 1]\n        const fileHandle = await currentDir.getFileHandle(fileName, { create: true })\n        const writable = await fileHandle.createWritable()\n        await writable.write(buffer)\n        await writable.close()\n    }\n\n    // Create empty directories from vfsDirIndex\n    for (let i = 0; i < directories.length; i++) {\n        const dirPath = directories[i]\n        onProgress?.({ phase: 'writing', current: entries.length + i + 1, total, filename: dirPath + '/' })\n\n        // Create nested directory structure\n        const parts = dirPath.split('/')\n        let currentDir = root\n\n        for (const part of parts) {\n            currentDir = await currentDir.getDirectoryHandle(part, { create: true })\n        }\n    }\n\n    console.log(`[VFS] Extracted ${vfsIndex.size} files, ${directories.length} dirs to OPFS`)\n}\n\n// Hydration: Pack all OPFS files into VFS binary\n// Scans OPFS recursively and adds all files to VFS\nexport const syncOpfsToVfs = async (onProgress?: SyncProgressCallback) => {\n    if (!root || !vfsSyncHandle) throw new Error('VFS not initialized')\n\n    const files: Array<{ path: string; data: Uint8Array }> = []\n    const directories: string[] = []\n    let scannedCount = 0\n\n    // Recursively collect all files and directories from OPFS\n    const collectEntries = async (dir: FileSystemDirectoryHandle, prefix: string): Promise<boolean> => {\n        let hasFiles = false\n\n        for await (const [name, handle] of (dir as any).entries()) {\n            const path = prefix ? `${prefix}/${name}` : name\n\n            // Skip the VFS binary itself\n            if (path === VFS_FILENAME) continue\n\n            if (handle.kind === 'file') {\n                scannedCount++\n                hasFiles = true\n                onProgress?.({ phase: 'scanning', current: scannedCount, total: 0, filename: path })\n                const file = await (handle as FileSystemFileHandle).getFile()\n                const buffer = await file.arrayBuffer()\n                files.push({ path, data: new Uint8Array(buffer) })\n            } else if (handle.kind === 'directory') {\n                const subHasFiles = await collectEntries(handle as FileSystemDirectoryHandle, path)\n                if (!subHasFiles) {\n                    // Empty directory - track it explicitly\n                    directories.push(path)\n                }\n                hasFiles = hasFiles || subHasFiles\n            }\n        }\n\n        return hasFiles\n    }\n\n    await collectEntries(root, '')\n\n    // Clear all existing VFS indexes and rebuild\n    vfsIndex.clear()\n    vfsDirIndex.clear()\n    vfsSymlinkIndex.clear()\n    vfsMetadataIndex.clear()\n\n    // Add explicit directories\n    for (const dir of directories) {\n        vfsDirIndex.add(dir)\n    }\n\n    // Calculate index size first (using the new format)\n    const tempIndex = new Map<string, { offset: number; size: number }>()\n    let dataOffset = 0\n    for (const { path, data } of files) {\n        tempIndex.set(path, { offset: dataOffset, size: data.length })\n        dataOffset += data.length\n    }\n\n    // We need to calculate the final index size iteratively because:\n    // - Index contains file offsets which depend on index size\n    // - Index size depends on the string length of those offsets\n    // This converges quickly (usually 1-2 iterations)\n    let indexSize = 0\n    let iterations = 0\n    const maxIterations = 10\n\n    while (iterations < maxIterations) {\n        iterations++\n        const headerSize = INDEX_HEADER_SIZE + indexSize\n\n        // Calculate offsets with current header size estimate\n        vfsIndex.clear()\n        let offset = headerSize\n        for (const { path, data } of files) {\n            vfsIndex.set(path, { offset, size: data.length })\n            offset += data.length\n        }\n\n        // Generate index JSON and measure its size\n        const indexData = {\n            files: Array.from(vfsIndex.entries()),\n            dirs: Array.from(vfsDirIndex),\n            symlinks: Array.from(vfsSymlinkIndex.entries()),\n            metadata: Array.from(vfsMetadataIndex.entries()),\n        }\n        const indexJson = JSON.stringify(indexData)\n        const indexBytes = new TextEncoder().encode(indexJson)\n        const newIndexSize = indexBytes.length\n\n        if (newIndexSize === indexSize) {\n            // Converged - write the data\n            const headerBuffer = new ArrayBuffer(INDEX_HEADER_SIZE)\n            new DataView(headerBuffer).setUint32(0, indexBytes.length)\n            vfsSyncHandle.write(new Uint8Array(headerBuffer), { at: 0 })\n            vfsSyncHandle.write(indexBytes, { at: INDEX_HEADER_SIZE })\n            break\n        }\n\n        indexSize = newIndexSize\n    }\n\n    if (iterations >= maxIterations) {\n        throw new Error('Failed to converge index size calculation')\n    }\n\n    // Write file data with progress\n    // File offsets are already stored in vfsIndex from the convergence loop\n    let writeOffset = INDEX_HEADER_SIZE + indexSize\n    for (let i = 0; i < files.length; i++) {\n        const { path, data } = files[i]\n        onProgress?.({ phase: 'writing', current: i + 1, total: files.length, filename: path })\n        vfsSyncHandle.write(data, { at: writeOffset })\n        writeOffset += data.length\n    }\n\n    // Truncate excess\n    vfsSyncHandle.truncate(writeOffset)\n    vfsSyncHandle.flush()\n\n    resetWastedBytes()\n    console.log(`[VFS] Packed ${files.length} files, ${directories.length} dirs from OPFS (${writeOffset} bytes)`)\n}\n","// VFS Traverse Operations\n\nimport { vfsIndex, vfsSyncHandle, root, VFS_FILENAME } from './state'\n\n// Traverse VFS - yields all files for use with zip/tar libraries\nexport function* traverseVfs(): Generator<{ path: string; data: Uint8Array }> {\n    if (!vfsSyncHandle) return\n\n    for (const [path, { offset, size }] of vfsIndex) {\n        const buffer = new Uint8Array(size)\n        vfsSyncHandle.read(buffer, { at: offset })\n        yield { path, data: buffer }\n    }\n}\n\n// Traverse OPFS - async generator that yields all files\nexport async function* traverseOpfs(\n    dir?: FileSystemDirectoryHandle,\n    prefix: string = ''\n): AsyncGenerator<{ path: string; data: Uint8Array }> {\n    const directory = dir || root\n    if (!directory) return\n\n    for await (const [name, handle] of (directory as any).entries()) {\n        const path = prefix ? `${prefix}/${name}` : name\n\n        // Skip the VFS binary itself\n        if (path === VFS_FILENAME) continue\n\n        if (handle.kind === 'file') {\n            const file = await (handle as FileSystemFileHandle).getFile()\n            const buffer = await file.arrayBuffer()\n            yield { path, data: new Uint8Array(buffer) }\n        } else if (handle.kind === 'directory') {\n            yield* traverseOpfs(handle as FileSystemDirectoryHandle, path)\n        }\n    }\n}\n","// VFS Import Operations\n\nimport { vfsIndex, vfsSyncHandle, root, INDEX_HEADER_SIZE, resetWastedBytes } from './state'\n\n// Import files to VFS from an iterable (e.g., from zip/tar extraction)\nexport const importToVfs = (files: Iterable<{ path: string; data: Uint8Array | ArrayBuffer }>) => {\n    if (!vfsSyncHandle) throw new Error('VFS not initialized')\n\n    const fileList: Array<{ path: string; data: Uint8Array }> = []\n\n    for (const file of files) {\n        const data = file.data instanceof ArrayBuffer ? new Uint8Array(file.data) : file.data\n        fileList.push({ path: file.path, data })\n    }\n\n    // Clear existing VFS and rebuild\n    vfsIndex.clear()\n\n    // Calculate index size first\n    const tempIndex = new Map<string, { offset: number; size: number }>()\n    let dataOffset = 0\n    for (const { path, data } of fileList) {\n        tempIndex.set(path, { offset: dataOffset, size: data.length })\n        dataOffset += data.length\n    }\n\n    const indexJson = JSON.stringify(Array.from(tempIndex.entries()))\n    const indexBytes = new TextEncoder().encode(indexJson)\n    const headerSize = INDEX_HEADER_SIZE + indexBytes.length\n\n    // Set final offsets accounting for header\n    let actualOffset = headerSize\n    for (const { path, data } of fileList) {\n        vfsIndex.set(path, { offset: actualOffset, size: data.length })\n        actualOffset += data.length\n    }\n\n    // Write header\n    const headerBuffer = new ArrayBuffer(INDEX_HEADER_SIZE)\n    new DataView(headerBuffer).setUint32(0, indexBytes.length)\n    vfsSyncHandle.write(new Uint8Array(headerBuffer), { at: 0 })\n\n    // Write index with correct offsets\n    const finalIndexJson = JSON.stringify(Array.from(vfsIndex.entries()))\n    const finalIndexBytes = new TextEncoder().encode(finalIndexJson)\n    vfsSyncHandle.write(finalIndexBytes, { at: INDEX_HEADER_SIZE })\n\n    // Write file data\n    let writeOffset = INDEX_HEADER_SIZE + finalIndexBytes.length\n    for (const { data } of fileList) {\n        vfsSyncHandle.write(data, { at: writeOffset })\n        writeOffset += data.length\n    }\n\n    // Truncate excess\n    vfsSyncHandle.truncate(writeOffset)\n    vfsSyncHandle.flush()\n\n    resetWastedBytes()\n    console.log(`[VFS] Imported ${fileList.length} files (${writeOffset} bytes)`)\n}\n\n// Import files to OPFS from an iterable (e.g., from zip/tar extraction)\nexport const importToOpfs = async (\n    files: Iterable<{ path: string; data: Uint8Array | ArrayBuffer }> | AsyncIterable<{ path: string; data: Uint8Array | ArrayBuffer }>\n) => {\n    if (!root) throw new Error('VFS not initialized')\n\n    let count = 0\n\n    for await (const file of files as AsyncIterable<{ path: string; data: Uint8Array | ArrayBuffer }>) {\n        const data = file.data instanceof ArrayBuffer ? new Uint8Array(file.data) : file.data\n\n        // Handle nested paths by creating directories\n        const parts = file.path.split('/')\n        let currentDir = root\n\n        for (let i = 0; i < parts.length - 1; i++) {\n            currentDir = await currentDir.getDirectoryHandle(parts[i], { create: true })\n        }\n\n        const fileName = parts[parts.length - 1]\n        const fileHandle = await currentDir.getFileHandle(fileName, { create: true })\n        const writable = await fileHandle.createWritable()\n        // Copy to regular ArrayBuffer (TypeScript complains about SharedArrayBuffer compatibility)\n        const buffer = new ArrayBuffer(data.length)\n        new Uint8Array(buffer).set(data)\n        await writable.write(buffer)\n        await writable.close()\n\n        count++\n    }\n\n    console.log(`[VFS] Imported ${count} files to OPFS`)\n}\n","// VFS Init and Lifecycle\n\nimport type { EventType, FileSystemChangeRecord } from './types'\nimport { VFS_FILENAME, setRoot, setVfsFileHandle, setVfsSyncHandle, observer, setObserver, root } from './state'\nimport { loadIndex } from './index-ops'\nimport { consumeEvent, disableEventQueuing, checkPathDumpRequest } from './events'\nimport { syncFileToVfs, removeFileFromVfs } from './sync'\nimport { notifyWatchListeners } from './watch'\n\n// Map FileSystemObserver types to our event types\nconst mapChangeType = (type: FileSystemChangeRecord['type']): EventType | 'moved' | null => {\n    switch (type) {\n        case 'appeared': return 'create'\n        case 'modified': return 'update'\n        case 'disappeared': return 'delete'\n        case 'moved': return 'moved'\n        default: return null\n    }\n}\n\n// Internal: watch OPFS for changes via FileSystemObserver (Chrome 129+ only)\nconst watchOpfs = async (callback: (records: FileSystemChangeRecord[]) => void) => {\n    if (!root) throw new Error('VFS not initialized')\n\n    try {\n        const obs = new FileSystemObserver((records) => {\n            callback(records)\n        })\n\n        await obs.observe(root, { recursive: true })\n        setObserver(obs)\n    } catch (err) {\n        console.warn('[VFS] FileSystemObserver not supported (Firefox/Safari) - external OPFS changes will not be detected automatically. This only affects detection of changes made by other applications; internal fs operations work normally.')\n        disableEventQueuing()\n    }\n}\n\nexport const unwatchOpfs = () => {\n    observer?.disconnect()\n    setObserver(null)\n}\n\nexport const init = async () => {\n    const opfsRoot = await navigator.storage.getDirectory()\n    setRoot(opfsRoot)\n\n    const vfsFileHandle = await opfsRoot.getFileHandle(VFS_FILENAME, { create: true })\n    setVfsFileHandle(vfsFileHandle)\n\n    const vfsSyncHandle = await (vfsFileHandle as any).createSyncAccessHandle()\n    setVfsSyncHandle(vfsSyncHandle)\n\n    // Load existing index from binary\n    loadIndex()\n    return\n    watchOpfs(async records => {\n        if (records.length > 0) {\n            const paths = records.map(r => r.relativePathComponents.join('/')).join(', ')\n            console.log(`[VFS Watcher] Received ${records.length} change(s): ${paths.substring(0, 200)}${paths.length > 200 ? '...' : ''}`)\n        }\n\n        for (const record of records) {\n            const path = record.relativePathComponents.join('/')\n\n            // Ignore the VFS binary itself\n            if (path === VFS_FILENAME) continue\n\n            const eventType = mapChangeType(record.type)\n            if (!eventType) continue\n\n            // Handle 'moved' events specially - they have both old and new paths\n            if (eventType === 'moved') {\n                const oldPath = record.relativePathMovedFrom?.join('/')\n                const newPath = path\n\n                // Skip if old path is the VFS binary\n                if (oldPath === VFS_FILENAME) continue\n\n                console.log(`[VFS Watcher] Move: ${oldPath} -> ${newPath}`)\n\n                // Remove from old path if we have it\n                if (oldPath) {\n                    removeFileFromVfs(oldPath)\n                    notifyWatchListeners(oldPath, 'rename')\n                }\n\n                // Sync at new path (mtime comparison ensures safety)\n                try {\n                    const result = await syncFileToVfs(newPath)\n                    if (result === 'synced') {\n                        console.log(`[VFS Watcher] Synced ${newPath} to VFS`)\n                    }\n                } catch (err) {\n                    const errorName = (err as Error).name\n                    if (errorName === 'NotFoundError') {\n                        console.log(`[VFS Watcher] File ${newPath} no longer exists, skipping sync`)\n                    } else if (errorName === 'NotReadableError') {\n                        console.log(`[VFS Watcher] File ${newPath} is locked, skipping sync`)\n                    } else {\n                        console.error(`[VFS Watcher] Error syncing ${newPath}:`, err)\n                    }\n                }\n                notifyWatchListeners(newPath, 'rename')\n\n                continue\n            }\n\n            // For create/update: always attempt sync - mtime comparison in syncFileToVfs is 100% safe\n            // It will only sync if OPFS mtime >= VFS mtime, preventing stale OPFS from overwriting newer VFS\n            // This eliminates the need for unreliable event queue matching\n            if (eventType === 'create' || eventType === 'update') {\n                try {\n                    const result = await syncFileToVfs(path)\n\n                    // Use sync result to determine if this was truly external\n                    // - 'synced': OPFS was newer or equal - this is a real external change\n                    // - 'skipped_vfs_newer': VFS was newer - this is our internal change, OPFS just caught up\n                    if (result === 'synced') {\n                        // consumeEvent handles metrics: returns true if internal, false if external\n                        const wasOurs = consumeEvent(eventType, path)\n                        console.log(`[VFS Watcher] ${wasOurs ? 'Internal' : 'External'} ${eventType}: ${path} (synced to VFS)`)\n                    } else if (result === 'skipped_vfs_newer') {\n                        // VFS is newer - this is definitely our internal change\n                        // Skip external counting since duplicate observer reports for same path are not external\n                        consumeEvent(eventType, path, undefined, true)\n                    } else if (result === 'skipped_directory') {\n                        // Directory event - consume all queued events for this path and children\n                        consumeEvent(eventType, path)\n                        console.log(`[VFS Watcher] Directory ${eventType}: ${path} (consumed children)`)\n                    }\n                } catch (err) {\n                    const errorName = (err as Error).name\n                    // Still consume events even if sync fails - the observer reported this path\n                    // Skip external counting since these are known internal events (file was deleted or locked by us)\n                    consumeEvent(eventType, path, undefined, true)\n                    if (errorName === 'NotFoundError') {\n                        console.log(`[VFS Watcher] File ${path} no longer exists, consumed events`)\n                    } else if (errorName === 'NotReadableError') {\n                        console.log(`[VFS Watcher] File ${path} is locked, consumed events`)\n                    } else {\n                        console.error(`[VFS Watcher] Error syncing ${path}:`, err)\n                    }\n                }\n            } else if (eventType === 'delete') {\n                // consumeEvent handles metrics: returns true if internal, false if external\n                const wasOurs = consumeEvent(eventType, path)\n                console.log(`[VFS Watcher] ${wasOurs ? 'Internal' : 'External'} ${eventType}: ${path}`)\n                // Always remove from VFS - safe because delete is idempotent\n                removeFileFromVfs(path)\n            }\n\n            // Notify fs.watch listeners (for both internal and external changes)\n            const watchEventType = eventType === 'create' || eventType === 'delete' ? 'rename' : 'change'\n            notifyWatchListeners(path, watchEventType)\n        }\n\n        // Check if main thread requested path dump via SAB (Atomics-based fetch)\n        checkPathDumpRequest()\n    })\n}\n\nexport const teardown = async () => {\n    unwatchOpfs()\n}\n","/**\n * FS Sync Worker - Request Processing Loop\n * Handles sync requests via SharedArrayBuffer + Atomics\n */\n\nimport type { StorageMode } from './config'\nimport { getRoot } from './fs.vfs'\nimport { syncMethods, opfsMethods, asyncVfsMethods } from './fs.sync.methods'\nimport { processAsyncQueue } from './fs.sync.queue'\nimport {\n  SYNC_STATUS_OFFSET,\n  SYNC_LENGTH_OFFSET,\n  SYNC_TYPE_OFFSET,\n  SYNC_DATA_OFFSET,\n  STATUS_IDLE,\n  STATUS_REQUEST,\n  STATUS_RESPONSE,\n  STATUS_ERROR,\n  REQUEST_TYPE_BINARY_ARG,\n  RESPONSE_TYPE_JSON,\n  RESPONSE_TYPE_BINARY,\n} from './fs.sab-utils'\n\n// Logging configuration\nlet loggingEnabled = false\nlet logLevel: 'none' | 'info' | 'verbose' | 'debug' = 'info'\nlet nextLogId = 1\n\nexport const setLogging = (enabled: boolean, level: 'none' | 'info' | 'verbose' | 'debug') => {\n  loggingEnabled = enabled\n  logLevel = level\n}\n\nfunction log(method: string, args: unknown[], phase: 'START' | 'END', duration?: number, error?: string) {\n  if (!loggingEnabled) return\n  const id = phase === 'START' ? nextLogId++ : nextLogId - 1\n  const timestamp = performance.now().toFixed(2)\n  const argsStr = args.map(a => typeof a === 'string' ? `\"${a.slice(0, 30)}\"` : String(a)).join(', ')\n  if (phase === 'START' && logLevel === 'verbose') {\n    console.log(`%c[FS:${id.toString().padStart(3, '0')} +${timestamp}ms] ${method}(${argsStr}) START [sync]`, 'color: #888')\n  } else if (phase === 'END') {\n    const durStr = duration !== undefined ? ` (${duration.toFixed(2)}ms)` : ''\n    const status = error ? '' : ''\n    const color = error ? 'color: #a44' : 'color: #4a4'\n    const errMsg = error ? ` - ${error}` : ''\n    console.log(`%c[FS:${id.toString().padStart(3, '0')} +${timestamp}ms] ${method}(${argsStr}) END${durStr} ${status}${errMsg}`, color)\n  }\n}\n\n// Request processing loop\n// Uses a tight synchronous loop for minimal latency on sync operations.\n// Only yields to event loop (setTimeout) when idle, to process fire-and-forget postMessages.\nexport const startRequestLoop = (syncSAB: SharedArrayBuffer, storageMode: StorageMode) => {\n  const statusArray = new Int32Array(syncSAB, SYNC_STATUS_OFFSET, 1)\n  const lengthView = new DataView(syncSAB, SYNC_LENGTH_OFFSET, 4)\n  const encoder = new TextEncoder()\n  const decoder = new TextDecoder()\n\n  const processLoop = () => {\n    // Process any queued fire-and-forget requests (filled by postMessage while we were yielded)\n    processAsyncQueue()\n\n    // Tight loop for handling sync requests - no yielding between requests\n    while (true) {\n      // Wait for a request (with timeout to periodically yield for fire-and-forget)\n      const waitResult = Atomics.wait(statusArray, 0, STATUS_IDLE, 100)\n\n      if (waitResult === 'timed-out') {\n        // No sync request - yield to event loop for postMessages, then continue\n        setTimeout(processLoop, 0)\n        return\n      }\n\n      // Got notified or status changed - check if it's a request\n      const status = Atomics.load(statusArray, 0)\n      if (status !== STATUS_REQUEST) {\n        continue // Spurious wakeup, keep waiting\n      }\n\n      // Read request: type byte at offset 8, payload at offset 9\n      const requestType = new Uint8Array(syncSAB, SYNC_TYPE_OFFSET, 1)[0]\n      const payloadLength = lengthView.getUint32(0)\n\n      // Validate payload length to catch corruption early\n      if (payloadLength > 60 * 1024 * 1024) { // Max ~60MB\n        console.error('[SyncWorker] Invalid payload length:', payloadLength)\n        Atomics.store(statusArray, 0, STATUS_IDLE)\n        continue\n      }\n\n      let method: string\n      let args: unknown[]\n\n      try {\n        if (requestType === REQUEST_TYPE_BINARY_ARG) {\n          // Binary arg request: [jsonLen:4][bufIdx:1][json:jsonLen][buffer:rest]\n          const headerView = new DataView(syncSAB, SYNC_DATA_OFFSET, 5)\n          const jsonLen = headerView.getUint32(0)\n          const bufferArgIndex = headerView.getUint8(4)\n\n          // Validate json length\n          if (jsonLen > payloadLength - 5) {\n            console.error('[SyncWorker] Invalid JSON length:', jsonLen, 'payload:', payloadLength)\n            Atomics.store(statusArray, 0, STATUS_IDLE)\n            continue\n          }\n\n          const jsonData = new Uint8Array(syncSAB, SYNC_DATA_OFFSET + 5, jsonLen).slice()\n          const parsed = JSON.parse(decoder.decode(jsonData))\n          method = parsed.method\n          args = parsed.args\n\n          // Extract raw buffer bytes and reconstruct Buffer at the right arg index\n          const bufferStart = SYNC_DATA_OFFSET + 5 + jsonLen\n          const bufferLen = payloadLength - 5 - jsonLen\n          if (bufferLen > 0) {\n            const bufferView = new Uint8Array(syncSAB, bufferStart, bufferLen)\n            args[bufferArgIndex] = Buffer.from(new Uint8Array(bufferView))\n          }\n        } else {\n          // Pure JSON request\n          const requestData = new Uint8Array(syncSAB, SYNC_DATA_OFFSET, payloadLength).slice()\n          const parsed = JSON.parse(decoder.decode(requestData))\n          method = parsed.method\n          args = parsed.args\n        }\n      } catch (parseErr) {\n        console.error('[SyncWorker] Failed to parse request:', parseErr)\n        Atomics.store(statusArray, 0, STATUS_IDLE)\n        continue\n      }\n\n      let responseStatus = STATUS_RESPONSE\n      let responseData: Uint8Array\n      let responseType = RESPONSE_TYPE_JSON\n\n      const startTime = performance.now()\n      log(method, args, 'START')\n\n      try {\n        let result: unknown\n\n        // Check for async VFS methods first (vfsLoad, vfsExtract, etc.)\n        const asyncVfsFn = asyncVfsMethods[method]\n        if (asyncVfsFn) {\n          // Async VFS methods need to break out of sync loop\n          // Run async method, then re-enter loop via setTimeout\n          ;(async () => {\n            try {\n              result = await asyncVfsFn(...(args as unknown[]))\n              writeResponse(result)\n            } catch (err) {\n              writeError((err as Error).message)\n            }\n            log(method, args, 'END', performance.now() - startTime)\n            setTimeout(processLoop, 0)\n          })()\n          return // Exit sync loop, will re-enter after async completes\n        } else if (storageMode === 'opfs-only') {\n          // OPFS-only mode: use async OPFS methods\n          const fn = opfsMethods[method]\n          if (!fn) throw new Error(`Unknown method: ${method}`)\n\n          const root = getRoot()\n          if (!root) throw new Error('OPFS root not initialized')\n\n          // Async - need to break out of sync loop\n          ;(async () => {\n            try {\n              result = await fn(root, ...(args as unknown[]))\n              writeResponse(result)\n            } catch (err) {\n              writeError((err as Error).message)\n            }\n            log(method, args, 'END', performance.now() - startTime)\n            setTimeout(processLoop, 0)\n          })()\n          return // Exit sync loop\n        } else {\n          // Hybrid or VFS-only mode: use sync VFS methods (stays in loop)\n          const fn = syncMethods[method]\n          if (!fn) throw new Error(`Unknown method: ${method}`)\n          result = fn(...(args as unknown[]))\n        }\n\n        // Use binary response for Buffer results (much more efficient than JSON)\n        if (Buffer.isBuffer(result)) {\n          responseType = RESPONSE_TYPE_BINARY\n          responseData = new Uint8Array(result)\n        } else if (result instanceof Uint8Array) {\n          responseType = RESPONSE_TYPE_BINARY\n          responseData = result\n        } else {\n          responseType = RESPONSE_TYPE_JSON\n          responseData = encoder.encode(JSON.stringify({ result }))\n        }\n        log(method, args, 'END', performance.now() - startTime)\n      } catch (err) {\n        responseStatus = STATUS_ERROR\n        responseType = RESPONSE_TYPE_JSON\n        const e = err as any\n        responseData = encoder.encode(JSON.stringify({\n          error: e.message,\n          code: e.code,\n          errno: e.errno,\n          syscall: e.syscall,\n          path: e.path\n        }))\n        log(method, args, 'END', performance.now() - startTime, (err as Error).message)\n      }\n\n      // Write response: type byte at offset 8, data at offset 9\n      const typeView = new Uint8Array(syncSAB, SYNC_TYPE_OFFSET, 1)\n      typeView[0] = responseType\n      lengthView.setUint32(0, responseData.length)\n\n      new Uint8Array(syncSAB, SYNC_DATA_OFFSET, responseData.length).set(responseData)\n      Atomics.store(statusArray, 0, responseStatus)\n      Atomics.notify(statusArray, 0)\n\n      // Wait briefly for main thread to reset to IDLE, then reset ourselves if needed\n      const resetResult = Atomics.wait(statusArray, 0, responseStatus, 10)\n      if (resetResult === 'timed-out') {\n        Atomics.store(statusArray, 0, STATUS_IDLE)\n      }\n\n      // Continue loop immediately - no yielding for sequential sync operations\n    }\n  }\n\n  // Helper to write response for async methods\n  const writeResponse = (result: unknown) => {\n    let responseType = RESPONSE_TYPE_JSON\n    let responseData: Uint8Array\n\n    if (Buffer.isBuffer(result)) {\n      responseType = RESPONSE_TYPE_BINARY\n      responseData = new Uint8Array(result)\n    } else if (result instanceof Uint8Array) {\n      responseType = RESPONSE_TYPE_BINARY\n      responseData = result\n    } else {\n      responseType = RESPONSE_TYPE_JSON\n      responseData = encoder.encode(JSON.stringify({ result }))\n    }\n\n    const typeView = new Uint8Array(syncSAB, SYNC_TYPE_OFFSET, 1)\n    typeView[0] = responseType\n    lengthView.setUint32(0, responseData.length)\n    new Uint8Array(syncSAB, SYNC_DATA_OFFSET, responseData.length).set(responseData)\n    Atomics.store(statusArray, 0, STATUS_RESPONSE)\n    Atomics.notify(statusArray, 0)\n  }\n\n  // Helper to write error for async methods\n  const writeError = (error: string) => {\n    const typeView = new Uint8Array(syncSAB, SYNC_TYPE_OFFSET, 1)\n    typeView[0] = RESPONSE_TYPE_JSON\n    const responseData = encoder.encode(JSON.stringify({ error }))\n    lengthView.setUint32(0, responseData.length)\n    new Uint8Array(syncSAB, SYNC_DATA_OFFSET, responseData.length).set(responseData)\n    Atomics.store(statusArray, 0, STATUS_ERROR)\n    Atomics.notify(statusArray, 0)\n  }\n\n  processLoop()\n}\n","/**\n * FS Sync Worker Methods Maps\n * Maps method names to their implementations for sync/async execution\n */\n\n// Sync methods (VFS-based)\nimport { readFileSync, readFileSyncChunk, getFileSizeSync } from './methods/readFile'\nimport { writeFileSync } from './methods/writeFile'\nimport { existsSync } from './methods/exists'\nimport { unlinkSync } from './methods/unlink'\nimport { mkdirSync } from './methods/mkdir'\nimport { rmdirSync } from './methods/rmdir'\nimport { readdirSync } from './methods/readdir'\nimport { statSync, lstatSync } from './methods/stat'\nimport { renameSync } from './methods/rename'\nimport { copyFileSync } from './methods/copyFile'\nimport { appendFileSync } from './methods/appendFile'\nimport { rmSync } from './methods/rm'\nimport { accessSync } from './methods/access'\nimport { chmodSync } from './methods/chmod'\nimport { chownSync } from './methods/chown'\nimport { lchmodSync } from './methods/lchmod'\nimport { lchownSync } from './methods/lchown'\nimport { linkSync } from './methods/link'\nimport { symlinkSync } from './methods/symlink'\nimport { readlinkSync } from './methods/readlink'\nimport { truncateSync } from './methods/truncate'\nimport { mkdtempSync } from './methods/mkdtemp'\nimport { realpathSync } from './methods/realpath'\nimport { utimesSync } from './methods/utimes'\nimport { lutimesSync } from './methods/lutimes'\nimport { cpSync } from './methods/cp'\nimport { opendirSync } from './methods/opendir'\nimport { statfsSync } from './methods/statfs'\nimport { openSync } from './methods/open'\nimport { closeSync } from './methods/close'\nimport { readSync } from './methods/read'\nimport { writeSync } from './methods/write'\nimport { fstatSync } from './methods/fstat'\nimport { fsyncSync } from './methods/fsync'\nimport { fdatasyncSync } from './methods/fdatasync'\nimport { ftruncateSync } from './methods/ftruncate'\nimport { fchmodSync } from './methods/fchmod'\nimport { fchownSync } from './methods/fchown'\nimport { futimesSync } from './methods/futimes'\nimport { readvSync } from './methods/readv'\nimport { writevSync } from './methods/writev'\n\n// Async methods (OPFS-based) for OPFS-only mode\nimport { readFile } from './methods/readFile'\nimport { writeFile } from './methods/writeFile'\nimport { exists } from './methods/exists'\nimport { unlink } from './methods/unlink'\nimport { mkdir } from './methods/mkdir'\nimport { rmdir } from './methods/rmdir'\nimport { readdir } from './methods/readdir'\nimport { stat, lstat } from './methods/stat'\nimport { rename } from './methods/rename'\nimport { copyFile } from './methods/copyFile'\nimport { appendFile } from './methods/appendFile'\nimport { rm } from './methods/rm'\nimport { access } from './methods/access'\nimport { chmod } from './methods/chmod'\nimport { chown } from './methods/chown'\nimport { lchmod } from './methods/lchmod'\nimport { lchown } from './methods/lchown'\nimport { link } from './methods/link'\nimport { symlink } from './methods/symlink'\nimport { readlink } from './methods/readlink'\nimport { truncate } from './methods/truncate'\nimport { mkdtemp } from './methods/mkdtemp'\nimport { realpath } from './methods/realpath'\nimport { utimes } from './methods/utimes'\nimport { lutimes } from './methods/lutimes'\nimport { cp } from './methods/cp'\nimport { opendir } from './methods/opendir'\nimport { statfs } from './methods/statfs'\n\nimport { syncOpfsToVfs, syncVfsToOpfs } from './fs.vfs'\n\n// Sync methods map (VFS-based) - used in hybrid and vfs-only modes\nexport const syncMethods: Record<string, Function> = {\n  // Sync method names (called from sync polyfill)\n  readFileSync,\n  readFileSyncChunk,\n  getFileSizeSync,\n  writeFileSync,\n  existsSync,\n  unlinkSync,\n  mkdirSync,\n  rmdirSync,\n  readdirSync,\n  statSync,\n  lstatSync,\n  renameSync,\n  copyFileSync,\n  appendFileSync,\n  rmSync,\n  accessSync,\n  chmodSync,\n  chownSync,\n  lchmodSync,\n  lchownSync,\n  linkSync,\n  symlinkSync,\n  readlinkSync,\n  truncateSync,\n  mkdtempSync,\n  realpathSync,\n  utimesSync,\n  lutimesSync,\n  cpSync,\n  opendirSync,\n  statfsSync,\n  openSync,\n  closeSync,\n  readSync,\n  writeSync,\n  fstatSync,\n  fsyncSync,\n  fdatasyncSync,\n  ftruncateSync,\n  fchmodSync,\n  fchownSync,\n  futimesSync,\n  readvSync,\n  writevSync,\n  // Async method name aliases (called from async polyfill in vfs-only mode\n  // or from secondary tabs routing async methods through sync worker)\n  readFile: readFileSync,\n  readFileChunk: readFileSyncChunk,\n  getFileSize: getFileSizeSync,\n  writeFile: writeFileSync,\n  exists: existsSync,\n  unlink: unlinkSync,\n  mkdir: mkdirSync,\n  rmdir: rmdirSync,\n  readdir: readdirSync,\n  stat: statSync,\n  lstat: lstatSync,\n  rename: renameSync,\n  copyFile: copyFileSync,\n  appendFile: appendFileSync,\n  rm: rmSync,\n  access: accessSync,\n  chmod: chmodSync,\n  chown: chownSync,\n  lchmod: lchmodSync,\n  lchown: lchownSync,\n  link: linkSync,\n  symlink: symlinkSync,\n  readlink: readlinkSync,\n  truncate: truncateSync,\n  mkdtemp: mkdtempSync,\n  realpath: realpathSync,\n  utimes: utimesSync,\n  lutimes: lutimesSync,\n  cp: cpSync,\n  opendir: opendirSync,\n  statfs: statfsSync,\n  open: openSync,\n  close: closeSync,\n  read: readSync,\n  write: writeSync,\n  fstat: fstatSync,\n  fsync: fsyncSync,\n  fdatasync: fdatasyncSync,\n  ftruncate: ftruncateSync,\n  fchmod: fchmodSync,\n  fchown: fchownSync,\n  futimes: futimesSync,\n  readv: readvSync,\n  writev: writevSync,\n}\n\n// Async methods map (OPFS-based) - used in opfs-only mode\n// Maps sync method names to async OPFS implementations\nexport const opfsMethods: Record<string, Function> = {\n  readFileSync: readFile,\n  writeFileSync: writeFile,\n  existsSync: exists,\n  unlinkSync: unlink,\n  mkdirSync: mkdir,\n  rmdirSync: rmdir,\n  readdirSync: readdir,\n  statSync: stat,\n  lstatSync: lstat,\n  renameSync: rename,\n  copyFileSync: copyFile,\n  appendFileSync: appendFile,\n  rmSync: rm,\n  accessSync: access,\n  chmodSync: chmod,\n  chownSync: chown,\n  lchmodSync: lchmod,\n  lchownSync: lchown,\n  linkSync: link,\n  symlinkSync: symlink,\n  readlinkSync: readlink,\n  truncateSync: truncate,\n  mkdtempSync: mkdtemp,\n  realpathSync: realpath,\n  utimesSync: utimes,\n  lutimesSync: lutimes,\n  cpSync: cp,\n  opendirSync: opendir,\n  statfsSync: statfs,\n  // fd-based methods don't have direct OPFS equivalents, fall back to VFS\n  openSync,\n  closeSync,\n  readSync,\n  writeSync,\n  fstatSync,\n  fsyncSync,\n  fdatasyncSync,\n  ftruncateSync,\n  fchmodSync,\n  fchownSync,\n  futimesSync,\n  readvSync,\n  writevSync,\n}\n\n// Async VFS methods (require await, run in worker context)\nexport const asyncVfsMethods: Record<string, Function> = {\n  vfsLoad: syncOpfsToVfs,\n  vfsExtract: syncVfsToOpfs,\n}\n","// readFile implementation using OPFS\n\nimport { readFileFromVfs, readChunkFromVfs, getFileSizeFromVfs, isDirectoryInVfs } from '../fs.vfs'\nimport { createENOENT, createEISDIR } from '../classes'\n\n// Navigate to a file handle through OPFS directory tree\nconst navigateToFile = async (\n  root: FileSystemDirectoryHandle,\n  path: string,\n  options?: FileSystemGetFileOptions\n): Promise<FileSystemFileHandle> => {\n  const parts = path.split('/').filter(p => p.length > 0)\n  let currentDir = root\n  for (let i = 0; i < parts.length - 1; i++) {\n    currentDir = await currentDir.getDirectoryHandle(parts[i])\n  }\n  return currentDir.getFileHandle(parts[parts.length - 1], options)\n}\n\n// Async - uses getFile()\nexport const readFile = async (\n  root: FileSystemDirectoryHandle,\n  path: string,\n  options?: { encoding?: BufferEncoding } | BufferEncoding\n): Promise<string | Buffer> => {\n  const encoding = typeof options === 'string' ? options : options?.encoding\n\n  const fileHandle = await navigateToFile(root, path)\n  const file = await fileHandle.getFile()\n  const buffer = await file.arrayBuffer()\n\n  if (encoding) {\n    return new TextDecoder(encoding).decode(buffer)\n  }\n  return Buffer.from(buffer)\n}\n\n// Read a specific chunk of a file (for streaming large files)\nexport const readFileChunk = async (\n  root: FileSystemDirectoryHandle,\n  path: string,\n  start: number,\n  end: number\n): Promise<Buffer> => {\n  const fileHandle = await navigateToFile(root, path)\n  const file = await fileHandle.getFile()\n\n  // Use slice to read only the needed portion\n  const slice = file.slice(start, end)\n  const buffer = await slice.arrayBuffer()\n\n  return Buffer.from(buffer)\n}\n\n// Get file size without reading content\nexport const getFileSize = async (\n  root: FileSystemDirectoryHandle,\n  path: string\n): Promise<number> => {\n  const fileHandle = await navigateToFile(root, path)\n  const file = await fileHandle.getFile()\n  return file.size\n}\n\n// Sync - reads from VFS binary\nexport const readFileSync = (\n  path: string,\n  options?: { encoding?: BufferEncoding } | BufferEncoding\n): string | Buffer => {\n  // Check if path is a directory - throw EISDIR to match Node.js behavior\n  if (isDirectoryInVfs(path)) {\n    throw createEISDIR('read', path)\n  }\n  const result = readFileFromVfs(path, options)\n  if (result === null) {\n    throw createENOENT('open', path)\n  }\n  return result\n}\n\n// Sync - read a chunk of a file (for large file streaming)\nexport const readFileSyncChunk = (\n  path: string,\n  start: number,\n  length: number\n): Buffer => {\n  const result = readChunkFromVfs(path, start, length)\n  if (result === null) {\n    throw createENOENT('open', path)\n  }\n  return Buffer.from(result)\n}\n\n// Sync - get file size without reading content\nexport const getFileSizeSync = (path: string): number => {\n  const size = getFileSizeFromVfs(path)\n  if (size === null) {\n    throw createENOENT('stat', path)\n  }\n  return size\n}\n","// Export all fs classes\n\nexport { Stats, BigIntStats, createStats } from './Stats'\nexport type { StatsInit } from './Stats'\n\nexport { Dirent, createDirent } from './Dirent'\nexport type { DirentInit } from './Dirent'\n\nexport { Dir } from './Dir'\nexport type { DirInit } from './Dir'\n\nexport { FileHandle, setFileHandleAsyncRequestFn } from './FileHandle'\nexport type { ReadResult, WriteResult } from './FileHandle'\n\nexport { ReadStream, setReadStreamReadFn, setReadStreamChunkFn, setReadStreamSizeFn } from './ReadStream'\nexport type { ReadStreamOptions } from './ReadStream'\n\nexport { WriteStream, setWriteStreamWriteFn, setWriteStreamAppendFn } from './WriteStream'\nexport type { WriteStreamOptions } from './WriteStream'\n\nexport {\n    FSError,\n    ERROR_CODES,\n    createENOENT,\n    createEEXIST,\n    createENOTDIR,\n    createEISDIR,\n    createENOTEMPTY,\n    createEACCES,\n    createEPERM,\n    createEBADF,\n    createEINVAL,\n    createELOOP,\n} from './FSError'\n","// Node.js fs.Stats class implementation\n// https://nodejs.org/api/fs.html#class-fsstats\n\nimport { S_IFMT, S_IFREG, S_IFDIR, S_IFLNK, S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK } from '../constants'\n\nexport interface StatsInit {\n    dev?: number\n    ino?: number\n    mode: number\n    nlink?: number\n    uid: number\n    gid: number\n    rdev?: number\n    size: number\n    blksize?: number\n    blocks?: number\n    atimeMs: number\n    mtimeMs: number\n    ctimeMs: number\n    birthtimeMs?: number\n}\n\nexport class Stats {\n    dev: number\n    ino: number\n    mode: number\n    nlink: number\n    uid: number\n    gid: number\n    rdev: number\n    size: number\n    blksize: number\n    blocks: number\n    atimeMs: number\n    mtimeMs: number\n    ctimeMs: number\n    birthtimeMs: number\n    atime: Date\n    mtime: Date\n    ctime: Date\n    birthtime: Date\n\n    constructor(init: StatsInit) {\n        this.dev = init.dev ?? 0\n        this.ino = init.ino ?? 0\n        this.mode = init.mode\n        this.nlink = init.nlink ?? 1\n        this.uid = init.uid\n        this.gid = init.gid\n        this.rdev = init.rdev ?? 0\n        this.size = init.size\n        this.blksize = init.blksize ?? 4096\n        this.blocks = init.blocks ?? Math.ceil(init.size / 512)\n        this.atimeMs = init.atimeMs\n        this.mtimeMs = init.mtimeMs\n        this.ctimeMs = init.ctimeMs\n        this.birthtimeMs = init.birthtimeMs ?? init.ctimeMs\n        this.atime = new Date(this.atimeMs)\n        this.mtime = new Date(this.mtimeMs)\n        this.ctime = new Date(this.ctimeMs)\n        this.birthtime = new Date(this.birthtimeMs)\n    }\n\n    isFile(): boolean {\n        return (this.mode & S_IFMT) === S_IFREG\n    }\n\n    isDirectory(): boolean {\n        return (this.mode & S_IFMT) === S_IFDIR\n    }\n\n    isBlockDevice(): boolean {\n        return (this.mode & S_IFMT) === S_IFBLK\n    }\n\n    isCharacterDevice(): boolean {\n        return (this.mode & S_IFMT) === S_IFCHR\n    }\n\n    isSymbolicLink(): boolean {\n        return (this.mode & S_IFMT) === S_IFLNK\n    }\n\n    isFIFO(): boolean {\n        return (this.mode & S_IFMT) === S_IFIFO\n    }\n\n    isSocket(): boolean {\n        return (this.mode & S_IFMT) === S_IFSOCK\n    }\n\n    // For JSON serialization\n    toJSON() {\n        return {\n            __type: 'Stats',\n            dev: this.dev,\n            ino: this.ino,\n            mode: this.mode,\n            nlink: this.nlink,\n            uid: this.uid,\n            gid: this.gid,\n            rdev: this.rdev,\n            size: this.size,\n            blksize: this.blksize,\n            blocks: this.blocks,\n            atimeMs: this.atimeMs,\n            mtimeMs: this.mtimeMs,\n            ctimeMs: this.ctimeMs,\n            birthtimeMs: this.birthtimeMs\n        }\n    }\n\n    // Reconstruct from JSON\n    static fromJSON(obj: StatsInit & { __type?: string }): Stats {\n        return new Stats(obj)\n    }\n}\n\n// BigInt version for stat({ bigint: true })\nexport class BigIntStats {\n    dev: bigint\n    ino: bigint\n    mode: bigint\n    nlink: bigint\n    uid: bigint\n    gid: bigint\n    rdev: bigint\n    size: bigint\n    blksize: bigint\n    blocks: bigint\n    atimeMs: bigint\n    mtimeMs: bigint\n    ctimeMs: bigint\n    birthtimeMs: bigint\n    atimeNs: bigint\n    mtimeNs: bigint\n    ctimeNs: bigint\n    birthtimeNs: bigint\n    atime: Date\n    mtime: Date\n    ctime: Date\n    birthtime: Date\n\n    constructor(init: StatsInit) {\n        this.dev = BigInt(init.dev ?? 0)\n        this.ino = BigInt(init.ino ?? 0)\n        this.mode = BigInt(init.mode)\n        this.nlink = BigInt(init.nlink ?? 1)\n        this.uid = BigInt(init.uid)\n        this.gid = BigInt(init.gid)\n        this.rdev = BigInt(init.rdev ?? 0)\n        this.size = BigInt(init.size)\n        this.blksize = BigInt(init.blksize ?? 4096)\n        this.blocks = BigInt(init.blocks ?? Math.ceil(init.size / 512))\n        this.atimeMs = BigInt(Math.floor(init.atimeMs))\n        this.mtimeMs = BigInt(Math.floor(init.mtimeMs))\n        this.ctimeMs = BigInt(Math.floor(init.ctimeMs))\n        this.birthtimeMs = BigInt(Math.floor(init.birthtimeMs ?? init.ctimeMs))\n        this.atimeNs = this.atimeMs * 1000000n\n        this.mtimeNs = this.mtimeMs * 1000000n\n        this.ctimeNs = this.ctimeMs * 1000000n\n        this.birthtimeNs = this.birthtimeMs * 1000000n\n        this.atime = new Date(Number(this.atimeMs))\n        this.mtime = new Date(Number(this.mtimeMs))\n        this.ctime = new Date(Number(this.ctimeMs))\n        this.birthtime = new Date(Number(this.birthtimeMs))\n    }\n\n    isFile(): boolean {\n        return (Number(this.mode) & S_IFMT) === S_IFREG\n    }\n\n    isDirectory(): boolean {\n        return (Number(this.mode) & S_IFMT) === S_IFDIR\n    }\n\n    isBlockDevice(): boolean {\n        return (Number(this.mode) & S_IFMT) === S_IFBLK\n    }\n\n    isCharacterDevice(): boolean {\n        return (Number(this.mode) & S_IFMT) === S_IFCHR\n    }\n\n    isSymbolicLink(): boolean {\n        return (Number(this.mode) & S_IFMT) === S_IFLNK\n    }\n\n    isFIFO(): boolean {\n        return (Number(this.mode) & S_IFMT) === S_IFIFO\n    }\n\n    isSocket(): boolean {\n        return (Number(this.mode) & S_IFMT) === S_IFSOCK\n    }\n}\n\n// Helper to create Stats from VFS metadata\nexport const createStats = (\n    size: number,\n    mode: number,\n    uid: number,\n    gid: number,\n    atimeMs: number,\n    mtimeMs: number,\n    ctimeMs?: number,\n    bigint?: boolean\n): Stats | BigIntStats => {\n    const init: StatsInit = {\n        mode,\n        uid,\n        gid,\n        size,\n        atimeMs,\n        mtimeMs,\n        ctimeMs: ctimeMs ?? mtimeMs,\n    }\n\n    return bigint ? new BigIntStats(init) : new Stats(init)\n}\n\nexport default Stats\n","// Node.js fs constants\n// https://nodejs.org/api/fs.html#file-access-constants\n\n// File Access Constants (for fs.access)\nexport const F_OK = 0 // File exists\nexport const R_OK = 4 // File can be read\nexport const W_OK = 2 // File can be written\nexport const X_OK = 1 // File can be executed\n\n// File Copy Constants (for fs.copyFile)\nexport const COPYFILE_EXCL = 1 // Fail if dest exists\nexport const COPYFILE_FICLONE = 2 // Use copy-on-write if supported\nexport const COPYFILE_FICLONE_FORCE = 4 // Force copy-on-write, fail if not supported\n\n// File Open Constants (for fs.open)\nexport const O_RDONLY = 0 // Open for reading only\nexport const O_WRONLY = 1 // Open for writing only\nexport const O_RDWR = 2 // Open for reading and writing\nexport const O_CREAT = 64 // Create file if it doesn't exist (0o100)\nexport const O_EXCL = 128 // Fail if file exists (with O_CREAT) (0o200)\nexport const O_NOCTTY = 256 // Don't assign controlling terminal (0o400)\nexport const O_TRUNC = 512 // Truncate file to zero length (0o1000)\nexport const O_APPEND = 1024 // Append to file (0o2000)\nexport const O_DIRECTORY = 65536 // Fail if not a directory (0o200000)\nexport const O_NOATIME = 262144 // Don't update access time (0o1000000)\nexport const O_NOFOLLOW = 131072 // Don't follow symlinks (0o400000)\nexport const O_SYNC = 1052672 // Synchronous I/O (0o4010000)\nexport const O_DSYNC = 4096 // Synchronous data I/O (0o10000)\nexport const O_SYMLINK = 2097152 // Open symlink itself (0o10000000)\nexport const O_DIRECT = 16384 // Direct I/O (0o40000)\nexport const O_NONBLOCK = 2048 // Non-blocking I/O (0o4000)\n\n// File Type Constants (for stat mode)\nexport const S_IFMT = 61440 // File type mask (0o170000)\nexport const S_IFREG = 32768 // Regular file (0o100000)\nexport const S_IFDIR = 16384 // Directory (0o40000)\nexport const S_IFCHR = 8192 // Character device (0o20000)\nexport const S_IFBLK = 24576 // Block device (0o60000)\nexport const S_IFIFO = 4096 // FIFO/pipe (0o10000)\nexport const S_IFLNK = 40960 // Symbolic link (0o120000)\nexport const S_IFSOCK = 49152 // Socket (0o140000)\n\n// File Mode Constants (permissions)\nexport const S_IRWXU = 448 // Owner read/write/execute (0o700)\nexport const S_IRUSR = 256 // Owner read (0o400)\nexport const S_IWUSR = 128 // Owner write (0o200)\nexport const S_IXUSR = 64 // Owner execute (0o100)\nexport const S_IRWXG = 56 // Group read/write/execute (0o70)\nexport const S_IRGRP = 32 // Group read (0o40)\nexport const S_IWGRP = 16 // Group write (0o20)\nexport const S_IXGRP = 8 // Group execute (0o10)\nexport const S_IRWXO = 7 // Others read/write/execute (0o7)\nexport const S_IROTH = 4 // Others read (0o4)\nexport const S_IWOTH = 2 // Others write (0o2)\nexport const S_IXOTH = 1 // Others execute (0o1)\n\n// Special mode bits\nexport const S_ISUID = 2048 // Set user ID on execution (0o4000)\nexport const S_ISGID = 1024 // Set group ID on execution (0o2000)\nexport const S_ISVTX = 512 // Sticky bit (0o1000)\n\n// Combined constants object (like fs.constants in Node.js)\nexport const constants = {\n    // File Access\n    F_OK,\n    R_OK,\n    W_OK,\n    X_OK,\n\n    // File Copy\n    COPYFILE_EXCL,\n    COPYFILE_FICLONE,\n    COPYFILE_FICLONE_FORCE,\n\n    // File Open\n    O_RDONLY,\n    O_WRONLY,\n    O_RDWR,\n    O_CREAT,\n    O_EXCL,\n    O_NOCTTY,\n    O_TRUNC,\n    O_APPEND,\n    O_DIRECTORY,\n    O_NOATIME,\n    O_NOFOLLOW,\n    O_SYNC,\n    O_DSYNC,\n    O_SYMLINK,\n    O_DIRECT,\n    O_NONBLOCK,\n\n    // File Type\n    S_IFMT,\n    S_IFREG,\n    S_IFDIR,\n    S_IFCHR,\n    S_IFBLK,\n    S_IFIFO,\n    S_IFLNK,\n    S_IFSOCK,\n\n    // File Mode (permissions)\n    S_IRWXU,\n    S_IRUSR,\n    S_IWUSR,\n    S_IXUSR,\n    S_IRWXG,\n    S_IRGRP,\n    S_IWGRP,\n    S_IXGRP,\n    S_IRWXO,\n    S_IROTH,\n    S_IWOTH,\n    S_IXOTH,\n\n    // Special mode bits\n    S_ISUID,\n    S_ISGID,\n    S_ISVTX,\n}\n\nexport default constants\n","// Node.js fs.Dirent class implementation\n// https://nodejs.org/api/fs.html#class-fsdirent\n\nimport { S_IFMT, S_IFREG, S_IFDIR, S_IFLNK, S_IFCHR, S_IFBLK, S_IFIFO, S_IFSOCK } from '../constants'\n\nexport interface DirentInit {\n    name: string\n    path?: string\n    mode: number\n}\n\nexport class Dirent {\n    name: string\n    path: string\n    // Use public _mode for JSON serialization (private # fields don't serialize)\n    _mode: number\n\n    constructor(init: DirentInit) {\n        this.name = init.name\n        this.path = init.path ?? ''\n        this._mode = init.mode\n    }\n\n    isFile(): boolean {\n        return (this._mode & S_IFMT) === S_IFREG\n    }\n\n    isDirectory(): boolean {\n        return (this._mode & S_IFMT) === S_IFDIR\n    }\n\n    isBlockDevice(): boolean {\n        return (this._mode & S_IFMT) === S_IFBLK\n    }\n\n    isCharacterDevice(): boolean {\n        return (this._mode & S_IFMT) === S_IFCHR\n    }\n\n    isSymbolicLink(): boolean {\n        return (this._mode & S_IFMT) === S_IFLNK\n    }\n\n    isFIFO(): boolean {\n        return (this._mode & S_IFMT) === S_IFIFO\n    }\n\n    isSocket(): boolean {\n        return (this._mode & S_IFMT) === S_IFSOCK\n    }\n\n    // For JSON serialization\n    toJSON() {\n        return {\n            __type: 'Dirent',\n            name: this.name,\n            path: this.path,\n            _mode: this._mode\n        }\n    }\n\n    // Reconstruct from JSON\n    static fromJSON(obj: { name: string; path: string; _mode: number }): Dirent {\n        return new Dirent({ name: obj.name, path: obj.path, mode: obj._mode })\n    }\n}\n\n// Helper to create Dirent from VFS entry\nexport const createDirent = (\n    name: string,\n    isDir: boolean,\n    isSymlink: boolean,\n    parentPath?: string\n): Dirent => {\n    let mode: number\n    if (isSymlink) {\n        mode = S_IFLNK | 0o777\n    } else if (isDir) {\n        mode = S_IFDIR | 0o755\n    } else {\n        mode = S_IFREG | 0o644\n    }\n\n    return new Dirent({\n        name,\n        path: parentPath,\n        mode,\n    })\n}\n\nexport default Dirent\n","// Node.js fs.Dir class implementation\n// https://nodejs.org/api/fs.html#class-fsdir\n\nimport { Dirent } from './Dirent'\n\nexport interface DirInit {\n    path: string\n    entries: Dirent[]\n}\n\nexport class Dir implements AsyncIterable<Dirent> {\n    readonly path: string\n    #entries: Dirent[]\n    #index: number = 0\n    #closed: boolean = false\n\n    constructor(init: DirInit) {\n        this.path = init.path\n        this.#entries = init.entries\n    }\n\n    // Async read one entry at a time\n    async read(): Promise<Dirent | null> {\n        if (this.#closed) {\n            throw new Error('Directory handle was closed')\n        }\n\n        if (this.#index >= this.#entries.length) {\n            return null\n        }\n\n        return this.#entries[this.#index++]\n    }\n\n    // Sync read one entry at a time\n    readSync(): Dirent | null {\n        if (this.#closed) {\n            throw new Error('Directory handle was closed')\n        }\n\n        if (this.#index >= this.#entries.length) {\n            return null\n        }\n\n        return this.#entries[this.#index++]\n    }\n\n    // Close the directory handle\n    async close(): Promise<void> {\n        this.#closed = true\n    }\n\n    // Sync close\n    closeSync(): void {\n        this.#closed = true\n    }\n\n    // Async iterator support\n    async *[Symbol.asyncIterator](): AsyncIterableIterator<Dirent> {\n        if (this.#closed) {\n            throw new Error('Directory handle was closed')\n        }\n\n        for (const entry of this.#entries) {\n            yield entry\n        }\n    }\n\n    // For...of support (sync)\n    *[Symbol.iterator](): IterableIterator<Dirent> {\n        if (this.#closed) {\n            throw new Error('Directory handle was closed')\n        }\n\n        for (const entry of this.#entries) {\n            yield entry\n        }\n    }\n}\n\nexport default Dir\n","// Node.js fs.FileHandle class implementation (promises API)\n// https://nodejs.org/api/fs.html#class-filehandle\n\nimport { Stats } from './Stats'\n\n// Types for async request function\ntype AsyncRequestFn = (method: string, args: unknown[]) => Promise<unknown>\n\nlet asyncRequestFn: AsyncRequestFn | null = null\n\nexport const setFileHandleAsyncRequestFn = (fn: AsyncRequestFn) => {\n    asyncRequestFn = fn\n}\n\nconst asyncRequest = (method: string, args: unknown[]): Promise<unknown> => {\n    if (!asyncRequestFn) throw new Error('FileHandle async request function not initialized')\n    return asyncRequestFn(method, args)\n}\n\nexport interface ReadResult {\n    bytesRead: number\n    buffer: Buffer\n}\n\nexport interface WriteResult {\n    bytesWritten: number\n    buffer: Buffer\n}\n\nexport class FileHandle {\n    readonly fd: number\n    #closed: boolean = false\n\n    constructor(fd: number) {\n        this.fd = fd\n    }\n\n    #checkClosed(): void {\n        if (this.#closed) {\n            throw new Error('file closed')\n        }\n    }\n\n    async appendFile(data: string | Buffer, options?: { encoding?: string }): Promise<void> {\n        this.#checkClosed()\n        const encoding = options?.encoding ?? 'utf8'\n        const buffer = typeof data === 'string' ? Buffer.from(data, encoding as BufferEncoding) : data\n        await asyncRequest('write', [this.fd, buffer, 0, buffer.length, null])\n    }\n\n    async chmod(mode: number): Promise<void> {\n        this.#checkClosed()\n        await asyncRequest('fchmod', [this.fd, mode])\n    }\n\n    async chown(uid: number, gid: number): Promise<void> {\n        this.#checkClosed()\n        await asyncRequest('fchown', [this.fd, uid, gid])\n    }\n\n    async close(): Promise<void> {\n        if (this.#closed) return\n        this.#closed = true\n        await asyncRequest('close', [this.fd])\n    }\n\n    async datasync(): Promise<void> {\n        this.#checkClosed()\n        await asyncRequest('fdatasync', [this.fd])\n    }\n\n    async read(\n        buffer: Buffer,\n        offset?: number,\n        length?: number,\n        position?: number | null\n    ): Promise<ReadResult>\n    async read(options?: {\n        buffer?: Buffer\n        offset?: number\n        length?: number\n        position?: number | null\n    }): Promise<ReadResult>\n    async read(\n        bufferOrOptions?: Buffer | { buffer?: Buffer; offset?: number; length?: number; position?: number | null },\n        offset?: number,\n        length?: number,\n        position?: number | null\n    ): Promise<ReadResult> {\n        this.#checkClosed()\n\n        let buffer: Buffer\n        let off: number\n        let len: number\n        let pos: number | null\n\n        if (Buffer.isBuffer(bufferOrOptions)) {\n            buffer = bufferOrOptions\n            off = offset ?? 0\n            len = length ?? buffer.length - off\n            pos = position ?? null\n        } else {\n            const opts = bufferOrOptions ?? {}\n            buffer = opts.buffer ?? Buffer.alloc(16384)\n            off = opts.offset ?? 0\n            len = opts.length ?? buffer.length - off\n            pos = opts.position ?? null\n        }\n\n        const bytesRead = await asyncRequest('read', [this.fd, buffer, off, len, pos]) as number\n        return { bytesRead, buffer }\n    }\n\n    async readFile(options?: { encoding?: string; flag?: string }): Promise<Buffer | string> {\n        this.#checkClosed()\n        // Read entire file from current position\n        const stat = await this.stat()\n        const buffer = Buffer.alloc(stat.size)\n        await this.read(buffer, 0, stat.size, 0)\n\n        if (options?.encoding) {\n            return buffer.toString(options.encoding as BufferEncoding)\n        }\n        return buffer\n    }\n\n    async readLines(options?: { encoding?: string }): Promise<AsyncIterable<string>> {\n        this.#checkClosed()\n        const content = await this.readFile({ encoding: options?.encoding ?? 'utf8' }) as string\n        const lines = content.split(/\\r?\\n/)\n\n        return {\n            async *[Symbol.asyncIterator]() {\n                for (const line of lines) {\n                    yield line\n                }\n            }\n        }\n    }\n\n    async readv(buffers: Buffer[], position?: number | null): Promise<{ bytesRead: number; buffers: Buffer[] }> {\n        this.#checkClosed()\n        const bytesRead = await asyncRequest('readv', [this.fd, buffers, position ?? null]) as number\n        return { bytesRead, buffers }\n    }\n\n    async stat(options?: { bigint?: boolean }): Promise<Stats> {\n        this.#checkClosed()\n        const result = await asyncRequest('fstat', [this.fd, options])\n        return result as Stats\n    }\n\n    async sync(): Promise<void> {\n        this.#checkClosed()\n        await asyncRequest('fsync', [this.fd])\n    }\n\n    async truncate(len?: number): Promise<void> {\n        this.#checkClosed()\n        await asyncRequest('ftruncate', [this.fd, len ?? 0])\n    }\n\n    async utimes(atime: number | string | Date, mtime: number | string | Date): Promise<void> {\n        this.#checkClosed()\n        await asyncRequest('futimes', [this.fd, atime, mtime])\n    }\n\n    async write(\n        buffer: Buffer,\n        offset?: number,\n        length?: number,\n        position?: number | null\n    ): Promise<WriteResult>\n    async write(\n        data: string,\n        position?: number | null,\n        encoding?: string\n    ): Promise<WriteResult>\n    async write(\n        bufferOrData: Buffer | string,\n        offsetOrPosition?: number | null,\n        lengthOrEncoding?: number | string,\n        position?: number | null\n    ): Promise<WriteResult> {\n        this.#checkClosed()\n\n        let buffer: Buffer\n        let off: number\n        let len: number\n        let pos: number | null\n\n        if (Buffer.isBuffer(bufferOrData)) {\n            buffer = bufferOrData\n            off = (offsetOrPosition as number) ?? 0\n            len = (lengthOrEncoding as number) ?? buffer.length - off\n            pos = position ?? null\n        } else {\n            const encoding = (lengthOrEncoding as string) ?? 'utf8'\n            buffer = Buffer.from(bufferOrData, encoding as BufferEncoding)\n            off = 0\n            len = buffer.length\n            pos = (offsetOrPosition as number) ?? null\n        }\n\n        const bytesWritten = await asyncRequest('write', [this.fd, buffer, off, len, pos]) as number\n        return { bytesWritten, buffer }\n    }\n\n    async writeFile(data: string | Buffer, options?: { encoding?: string }): Promise<void> {\n        this.#checkClosed()\n        await this.truncate(0)\n        const buffer = typeof data === 'string'\n            ? Buffer.from(data, (options?.encoding ?? 'utf8') as BufferEncoding)\n            : data\n        await this.write(buffer, 0, buffer.length, 0)\n    }\n\n    async writev(buffers: Buffer[], position?: number | null): Promise<{ bytesWritten: number; buffers: Buffer[] }> {\n        this.#checkClosed()\n        const bytesWritten = await asyncRequest('writev', [this.fd, buffers, position ?? null]) as number\n        return { bytesWritten, buffers }\n    }\n\n    // createReadStream and createWriteStream are omitted - they need stream implementation\n}\n\nexport default FileHandle\n","// Node.js fs.ReadStream class implementation\n// https://nodejs.org/api/fs.html#class-fsreadstream\n\nimport { EventEmitter } from 'events'\n\n// Type for async read function (full file)\ntype ReadFn = (path: string, options?: { start?: number; end?: number }) => Promise<Buffer>\n\n// Type for chunked read function (for streaming large files)\ntype ReadChunkFn = (path: string, start: number, end: number) => Promise<Buffer>\n\n// Type for getting file size\ntype GetSizeFn = (path: string) => Promise<number>\n\nlet readFileFn: ReadFn | null = null\nlet readChunkFn: ReadChunkFn | null = null\nlet getSizeFn: GetSizeFn | null = null\n\n// Threshold for using chunked reads (files larger than 1MB use streaming)\nconst CHUNKED_READ_THRESHOLD = 1024 * 1024\n\nexport const setReadStreamReadFn = (fn: ReadFn) => {\n    readFileFn = fn\n}\n\nexport const setReadStreamChunkFn = (fn: ReadChunkFn) => {\n    readChunkFn = fn\n}\n\nexport const setReadStreamSizeFn = (fn: GetSizeFn) => {\n    getSizeFn = fn\n}\n\nexport interface ReadStreamOptions {\n    flags?: string\n    encoding?: BufferEncoding | null\n    fd?: number | null\n    mode?: number\n    autoClose?: boolean\n    emitClose?: boolean\n    start?: number\n    end?: number\n    highWaterMark?: number\n}\n\nexport class ReadStream extends EventEmitter {\n    readonly path: string\n    readonly flags: string\n    readonly mode: number\n    readonly start?: number\n    readonly end?: number\n    readonly autoClose: boolean\n    readonly bytesRead: number = 0\n    readonly pending: boolean = true\n\n    #encoding: BufferEncoding | null\n    #highWaterMark: number\n    #destroyed: boolean = false\n    #reading: boolean = false\n    #position: number\n    #endPosition: number | undefined\n\n    constructor(path: string, options?: ReadStreamOptions) {\n        super()\n        this.path = path\n        this.flags = options?.flags ?? 'r'\n        this.mode = options?.mode ?? 0o666\n        this.start = options?.start\n        this.end = options?.end\n        this.autoClose = options?.autoClose ?? true\n        this.#encoding = options?.encoding ?? null\n        this.#highWaterMark = options?.highWaterMark ?? 64 * 1024\n        this.#position = this.start ?? 0\n        this.#endPosition = this.end\n\n        // Start reading on next tick\n        setImmediate(() => this.#startReading())\n    }\n\n    async #startReading(): Promise<void> {\n        if (this.#destroyed || this.#reading) return\n        this.#reading = true\n        ;(this as { pending: boolean }).pending = false\n\n        try {\n            if (!readFileFn) {\n                throw new Error('ReadStream read function not initialized')\n            }\n\n            // Determine file size and whether to use chunked reading\n            let fileSize: number | undefined\n            if (getSizeFn && readChunkFn) {\n                try {\n                    fileSize = await getSizeFn(this.path)\n                } catch {\n                    // Fall back to non-chunked read if size check fails\n                }\n            }\n\n            const effectiveEnd = this.end !== undefined ? this.end + 1 : fileSize\n            const effectiveStart = this.start ?? 0\n            const totalToRead = effectiveEnd !== undefined\n                ? effectiveEnd - effectiveStart\n                : undefined\n\n            // Use chunked reads for large files (more memory efficient)\n            if (\n                totalToRead !== undefined &&\n                totalToRead > CHUNKED_READ_THRESHOLD &&\n                readChunkFn &&\n                getSizeFn\n            ) {\n                await this.#readChunked(effectiveStart, effectiveEnd!)\n            } else {\n                // Small file or no chunk support - read all at once\n                await this.#readFull()\n            }\n        } catch (err) {\n            this.emit('error', err)\n            if (this.autoClose) {\n                this.destroy()\n            }\n        }\n\n        this.#reading = false\n    }\n\n    // Read file in chunks (memory efficient for large files)\n    async #readChunked(start: number, end: number): Promise<void> {\n        let position = start\n\n        while (position < end && !this.#destroyed) {\n            const chunkEnd = Math.min(position + this.#highWaterMark, end)\n            const chunk = await readChunkFn!(this.path, position, chunkEnd)\n\n            position = chunkEnd\n            ;(this as { bytesRead: number }).bytesRead += chunk.length\n\n            if (this.#encoding) {\n                this.emit('data', chunk.toString(this.#encoding))\n            } else {\n                this.emit('data', chunk)\n            }\n\n            // Allow event loop to process between chunks\n            await new Promise(resolve => setImmediate(resolve))\n        }\n\n        if (!this.#destroyed) {\n            this.emit('end')\n            if (this.autoClose) {\n                this.destroy()\n            }\n        }\n    }\n\n    // Read entire file at once (for small files)\n    async #readFull(): Promise<void> {\n        const content = await readFileFn!(this.path, {\n            start: this.start,\n            end: this.end,\n        })\n\n        let buffer = content\n        let offset = 0\n\n        while (offset < buffer.length && !this.#destroyed) {\n            const chunkSize = Math.min(this.#highWaterMark, buffer.length - offset)\n            const chunk = buffer.subarray(offset, offset + chunkSize)\n            offset += chunkSize\n            ;(this as { bytesRead: number }).bytesRead += chunkSize\n\n            if (this.#encoding) {\n                this.emit('data', chunk.toString(this.#encoding))\n            } else {\n                this.emit('data', chunk)\n            }\n\n            // Allow event loop to process between chunks\n            await new Promise(resolve => setImmediate(resolve))\n        }\n\n        if (!this.#destroyed) {\n            this.emit('end')\n            if (this.autoClose) {\n                this.destroy()\n            }\n        }\n    }\n\n    setEncoding(encoding: BufferEncoding): this {\n        this.#encoding = encoding\n        return this\n    }\n\n    pause(): this {\n        // In this simple implementation, we read all at once\n        // A full implementation would support pausing mid-read\n        return this\n    }\n\n    resume(): this {\n        return this\n    }\n\n    isPaused(): boolean {\n        return false\n    }\n\n    pipe<T extends NodeJS.WritableStream>(destination: T): T {\n        this.on('data', (chunk) => {\n            destination.write(chunk)\n        })\n        this.on('end', () => {\n            if ((destination as any).end) {\n                (destination as any).end()\n            }\n        })\n        return destination\n    }\n\n    unpipe(): this {\n        this.removeAllListeners('data')\n        return this\n    }\n\n    destroy(error?: Error): this {\n        if (this.#destroyed) return this\n        this.#destroyed = true\n\n        if (error) {\n            this.emit('error', error)\n        }\n        this.emit('close')\n\n        return this\n    }\n\n    // Readable stream interface\n    read(_size?: number): Buffer | string | null {\n        // This implementation uses push mode (events), not pull mode\n        return null\n    }\n\n    get destroyed(): boolean {\n        return this.#destroyed\n    }\n\n    // AsyncIterable support\n    async *[Symbol.asyncIterator](): AsyncIterableIterator<Buffer | string> {\n        const chunks: (Buffer | string)[] = []\n        let ended = false\n        let error: Error | null = null\n\n        this.on('data', (chunk) => chunks.push(chunk))\n        this.on('end', () => { ended = true })\n        this.on('error', (err) => { error = err })\n\n        while (!ended && !error) {\n            if (chunks.length > 0) {\n                yield chunks.shift()!\n            } else {\n                await new Promise(resolve => setImmediate(resolve))\n            }\n        }\n\n        // Yield remaining chunks\n        while (chunks.length > 0) {\n            yield chunks.shift()!\n        }\n\n        if (error) {\n            throw error\n        }\n    }\n}\n\nexport default ReadStream\n","// Node.js fs.WriteStream class implementation\n// https://nodejs.org/api/fs.html#class-fswritestream\n\nimport { EventEmitter } from 'events'\n\n// Type for async write function\ntype WriteFn = (path: string, data: Buffer, options?: { flag?: string; start?: number }) => Promise<void>\ntype AppendFn = (path: string, data: Buffer) => Promise<void>\n\nlet writeFileFn: WriteFn | null = null\nlet appendFileFn: AppendFn | null = null\n\nexport const setWriteStreamWriteFn = (fn: WriteFn) => {\n    writeFileFn = fn\n}\n\nexport const setWriteStreamAppendFn = (fn: AppendFn) => {\n    appendFileFn = fn\n}\n\nexport interface WriteStreamOptions {\n    flags?: string\n    encoding?: BufferEncoding\n    fd?: number | null\n    mode?: number\n    autoClose?: boolean\n    emitClose?: boolean\n    start?: number\n    highWaterMark?: number\n}\n\nexport class WriteStream extends EventEmitter {\n    readonly path: string\n    readonly flags: string\n    readonly mode: number\n    readonly start?: number\n    readonly autoClose: boolean\n    bytesWritten: number = 0\n    readonly pending: boolean = true\n\n    #encoding: BufferEncoding\n    #highWaterMark: number\n    #destroyed: boolean = false\n    #finished: boolean = false\n    #writeQueue: Buffer[] = []\n    #writing: boolean = false\n    #needsDrain: boolean = false\n    #isFirstWrite: boolean = true\n\n    constructor(path: string, options?: WriteStreamOptions) {\n        super()\n        this.path = path\n        this.flags = options?.flags ?? 'w'\n        this.mode = options?.mode ?? 0o666\n        this.start = options?.start\n        this.autoClose = options?.autoClose ?? true\n        this.#encoding = options?.encoding ?? 'utf8'\n        this.#highWaterMark = options?.highWaterMark ?? 64 * 1024\n\n        // Mark as ready on next tick\n        setImmediate(() => {\n            (this as { pending: boolean }).pending = false\n            this.emit('ready')\n            this.emit('open')\n        })\n    }\n\n    write(chunk: string | Buffer, callback?: (err?: Error | null) => void): boolean\n    write(chunk: string | Buffer, encoding?: BufferEncoding, callback?: (err?: Error | null) => void): boolean\n    write(\n        chunk: string | Buffer,\n        encodingOrCallback?: BufferEncoding | ((err?: Error | null) => void),\n        callback?: (err?: Error | null) => void\n    ): boolean {\n        if (this.#destroyed || this.#finished) {\n            const err = new Error('write after end')\n            if (callback) callback(err)\n            else if (typeof encodingOrCallback === 'function') encodingOrCallback(err)\n            return false\n        }\n\n        let encoding = this.#encoding\n        let cb = callback\n\n        if (typeof encodingOrCallback === 'function') {\n            cb = encodingOrCallback\n        } else if (encodingOrCallback) {\n            encoding = encodingOrCallback\n        }\n\n        const buffer = typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk\n        this.#writeQueue.push(buffer)\n\n        // Check if we need to signal drain\n        const totalQueued = this.#writeQueue.reduce((sum, b) => sum + b.length, 0)\n        this.#needsDrain = totalQueued >= this.#highWaterMark\n\n        // Process the write queue\n        this.#processQueue(cb)\n\n        return !this.#needsDrain\n    }\n\n    async #processQueue(callback?: (err?: Error | null) => void): Promise<void> {\n        if (this.#writing || this.#writeQueue.length === 0) {\n            if (callback) callback(null)\n            return\n        }\n\n        this.#writing = true\n\n        try {\n            while (this.#writeQueue.length > 0 && !this.#destroyed) {\n                const buffer = this.#writeQueue.shift()!\n\n                if (!writeFileFn || !appendFileFn) {\n                    throw new Error('WriteStream write function not initialized')\n                }\n\n                // First write truncates (if flags='w'), subsequent appends\n                if (this.#isFirstWrite && this.flags === 'w') {\n                    await writeFileFn(this.path, buffer, { flag: 'w', start: this.start })\n                    this.#isFirstWrite = false\n                } else {\n                    await appendFileFn(this.path, buffer)\n                }\n\n                this.bytesWritten += buffer.length\n            }\n\n            if (callback) callback(null)\n\n            // Emit drain if we were backed up\n            if (this.#needsDrain) {\n                this.#needsDrain = false\n                this.emit('drain')\n            }\n        } catch (err) {\n            if (callback) callback(err as Error)\n            this.emit('error', err)\n            if (this.autoClose) {\n                this.destroy()\n            }\n        }\n\n        this.#writing = false\n    }\n\n    end(callback?: () => void): this\n    end(chunk: string | Buffer, callback?: () => void): this\n    end(chunk: string | Buffer, encoding?: BufferEncoding, callback?: () => void): this\n    end(\n        chunkOrCallback?: string | Buffer | (() => void),\n        encodingOrCallback?: BufferEncoding | (() => void),\n        callback?: () => void\n    ): this {\n        if (this.#finished) return this\n\n        let chunk: string | Buffer | undefined\n        let cb: (() => void) | undefined\n\n        if (typeof chunkOrCallback === 'function') {\n            cb = chunkOrCallback\n        } else if (chunkOrCallback !== undefined) {\n            chunk = chunkOrCallback\n            if (typeof encodingOrCallback === 'function') {\n                cb = encodingOrCallback\n            } else {\n                cb = callback\n            }\n        }\n\n        const finish = () => {\n            this.#finished = true\n            this.emit('finish')\n            if (this.autoClose) {\n                this.destroy()\n            }\n            if (cb) cb()\n        }\n\n        if (chunk !== undefined) {\n            this.write(chunk, () => {\n                this.#processQueue().then(finish)\n            })\n        } else {\n            this.#processQueue().then(finish)\n        }\n\n        return this\n    }\n\n    setDefaultEncoding(encoding: BufferEncoding): this {\n        this.#encoding = encoding\n        return this\n    }\n\n    cork(): void {\n        // No-op in this implementation\n    }\n\n    uncork(): void {\n        // No-op in this implementation\n    }\n\n    destroy(error?: Error): this {\n        if (this.#destroyed) return this\n        this.#destroyed = true\n\n        if (error) {\n            this.emit('error', error)\n        }\n        this.emit('close')\n\n        return this\n    }\n\n    get destroyed(): boolean {\n        return this.#destroyed\n    }\n\n    get writable(): boolean {\n        return !this.#destroyed && !this.#finished\n    }\n\n    get writableEnded(): boolean {\n        return this.#finished\n    }\n\n    get writableFinished(): boolean {\n        return this.#finished && this.#writeQueue.length === 0\n    }\n\n    get writableHighWaterMark(): number {\n        return this.#highWaterMark\n    }\n\n    get writableLength(): number {\n        return this.#writeQueue.reduce((sum, b) => sum + b.length, 0)\n    }\n}\n\nexport default WriteStream\n","// Node.js fs error class implementation\n// https://nodejs.org/api/errors.html#class-systemerror\n\n// Error codes mapping\nexport const ERROR_CODES: Record<string, { code: string; errno: number; message: string }> = {\n    ENOENT: { code: 'ENOENT', errno: -2, message: 'no such file or directory' },\n    EEXIST: { code: 'EEXIST', errno: -17, message: 'file already exists' },\n    ENOTDIR: { code: 'ENOTDIR', errno: -20, message: 'not a directory' },\n    EISDIR: { code: 'EISDIR', errno: -21, message: 'illegal operation on a directory' },\n    ENOTEMPTY: { code: 'ENOTEMPTY', errno: -39, message: 'directory not empty' },\n    EACCES: { code: 'EACCES', errno: -13, message: 'permission denied' },\n    EPERM: { code: 'EPERM', errno: -1, message: 'operation not permitted' },\n    EBADF: { code: 'EBADF', errno: -9, message: 'bad file descriptor' },\n    EINVAL: { code: 'EINVAL', errno: -22, message: 'invalid argument' },\n    EMFILE: { code: 'EMFILE', errno: -24, message: 'too many open files' },\n    ENFILE: { code: 'ENFILE', errno: -23, message: 'file table overflow' },\n    ELOOP: { code: 'ELOOP', errno: -40, message: 'too many symbolic links encountered' },\n    ENAMETOOLONG: { code: 'ENAMETOOLONG', errno: -36, message: 'file name too long' },\n    ENOSPC: { code: 'ENOSPC', errno: -28, message: 'no space left on device' },\n    EROFS: { code: 'EROFS', errno: -30, message: 'read-only file system' },\n    EXDEV: { code: 'EXDEV', errno: -18, message: 'cross-device link not permitted' },\n    EAGAIN: { code: 'EAGAIN', errno: -11, message: 'resource temporarily unavailable' },\n    EBUSY: { code: 'EBUSY', errno: -16, message: 'resource busy or locked' },\n    ENOTCONN: { code: 'ENOTCONN', errno: -107, message: 'socket is not connected' },\n    ETIMEDOUT: { code: 'ETIMEDOUT', errno: -110, message: 'connection timed out' },\n    ECONNREFUSED: { code: 'ECONNREFUSED', errno: -111, message: 'connection refused' },\n    ECONNRESET: { code: 'ECONNRESET', errno: -104, message: 'connection reset by peer' },\n}\n\nexport class FSError extends Error {\n    code: string\n    errno: number\n    syscall: string\n    path?: string\n    dest?: string\n\n    constructor(\n        code: keyof typeof ERROR_CODES | string,\n        syscall: string,\n        path?: string,\n        dest?: string\n    ) {\n        const errorInfo = ERROR_CODES[code] ?? { code, errno: -1, message: code.toLowerCase() }\n\n        let message = `${errorInfo.code}: ${errorInfo.message}, ${syscall}`\n        if (path) {\n            message += ` '${path}'`\n        }\n        if (dest) {\n            message += ` -> '${dest}'`\n        }\n\n        super(message)\n\n        this.name = 'Error'\n        this.code = errorInfo.code\n        this.errno = errorInfo.errno\n        this.syscall = syscall\n        this.path = path\n        this.dest = dest\n\n        // Maintain proper stack trace in V8\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, FSError)\n        }\n    }\n\n    // Convert to JSON-serializable object\n    toJSON(): object {\n        return {\n            name: this.name,\n            message: this.message,\n            code: this.code,\n            errno: this.errno,\n            syscall: this.syscall,\n            path: this.path,\n            dest: this.dest,\n        }\n    }\n}\n\n// Helper functions to create common errors\nexport const createENOENT = (syscall: string, path: string): FSError =>\n    new FSError('ENOENT', syscall, path)\n\nexport const createEEXIST = (syscall: string, path: string): FSError =>\n    new FSError('EEXIST', syscall, path)\n\nexport const createENOTDIR = (syscall: string, path: string): FSError =>\n    new FSError('ENOTDIR', syscall, path)\n\nexport const createEISDIR = (syscall: string, path: string): FSError =>\n    new FSError('EISDIR', syscall, path)\n\nexport const createENOTEMPTY = (syscall: string, path: string): FSError =>\n    new FSError('ENOTEMPTY', syscall, path)\n\nexport const createEACCES = (syscall: string, path: string): FSError =>\n    new FSError('EACCES', syscall, path)\n\nexport const createEPERM = (syscall: string, path: string): FSError =>\n    new FSError('EPERM', syscall, path)\n\nexport const createEBADF = (syscall: string): FSError =>\n    new FSError('EBADF', syscall)\n\nexport const createEINVAL = (syscall: string, path?: string, message?: string): FSError => {\n    const error = new FSError('EINVAL', syscall, path)\n    if (message) {\n        error.message = `EINVAL: ${message}, ${syscall}${path ? ` '${path}'` : ''}`\n    }\n    return error\n}\n\nexport const createELOOP = (syscall: string, path: string): FSError =>\n    new FSError('ELOOP', syscall, path)\n\nexport default FSError\n","// writeFile implementation using OPFS\n\nimport { queueEvent, writeFileToVfs, existsInVfs } from '../fs.vfs'\n\n// Async - writes to OPFS; VFS update happens via fire-and-forget to sync worker\n// Note: For async OPFS mode, we queue 'update' since we can't easily check VFS existence\nexport const writeFile = async (\n  root: FileSystemDirectoryHandle,\n  path: string,\n  data: string | Buffer,\n  _options?: { encoding?: BufferEncoding } | BufferEncoding\n): Promise<void> => {\n  // Debug: log all writes to dist folder\n  if (path.includes('/dist/') || path.includes('/dist')) {\n    console.log(`[writeFile ASYNC] Writing dist file: ${path} (${typeof data === 'string' ? data.length + ' chars' : data.length + ' bytes'})`)\n  }\n  queueEvent('update', path)\n\n  // Navigate to parent directory, creating dirs as needed\n  const parts = path.split('/').filter(p => p.length > 0)\n  let currentDir = root\n  for (let i = 0; i < parts.length - 1; i++) {\n    currentDir = await currentDir.getDirectoryHandle(parts[i], { create: true })\n  }\n  const fileHandle = await currentDir.getFileHandle(parts[parts.length - 1], { create: true })\n  const writable = await fileHandle.createWritable()\n\n  const bytes = typeof data === 'string'\n    ? new TextEncoder().encode(data)\n    : new Uint8Array(data)\n\n  await writable.write(bytes)\n  await writable.close()\n}\n\n// Sync - writes to VFS binary\nexport const writeFileSync = (\n  path: string,\n  data: string | Buffer,\n  _options?: { encoding?: BufferEncoding } | BufferEncoding\n): void => {\n  // Debug: log all writes to dist folder\n  if (path.includes('/dist/') || path.includes('/dist')) {\n    const size = data == null ? 'null' : typeof data === 'string' ? data.length + ' chars' : data.length + ' bytes'\n    console.log(`[writeFileSync] Writing dist file: ${path} (${size})`)\n  }\n  // Queue 'create' for new files, 'update' for existing files\n  const eventType = existsInVfs(path) ? 'update' : 'create'\n  queueEvent(eventType, path)\n  writeFileToVfs(path, data)\n}\n","// exists implementation using OPFS\n\nimport { existsInVfs } from '../fs.vfs'\n\n// Async - uses getFileHandle/getDirectoryHandle\nexport const exists = async (\n  root: FileSystemDirectoryHandle,\n  path: string\n): Promise<boolean> => {\n  const parts = path.split('/').filter(p => p.length > 0)\n  if (parts.length === 0) return true // root always exists\n\n  try {\n    // Navigate to parent directory\n    let currentDir = root\n    for (let i = 0; i < parts.length - 1; i++) {\n      currentDir = await currentDir.getDirectoryHandle(parts[i])\n    }\n    const lastName = parts[parts.length - 1]\n\n    // Try as file first, then directory\n    try {\n      await currentDir.getFileHandle(lastName)\n      return true\n    } catch {\n      await currentDir.getDirectoryHandle(lastName)\n      return true\n    }\n  } catch {\n    return false\n  }\n}\n\n// Sync - checks VFS index\nexport const existsSync = (path: string): boolean => {\n  return existsInVfs(path)\n}\n","// unlink implementation using OPFS\n\nimport { queueEvent, deleteFromVfs, existsInVfs } from '../fs.vfs'\n\n// Async - removes file from OPFS\nexport const unlink = async (\n    root: FileSystemDirectoryHandle,\n    path: string\n): Promise<void> => {\n    queueEvent('delete', path)\n\n    // Handle nested paths\n    const parts = path.split('/')\n    let currentDir = root\n\n    for (let i = 0; i < parts.length - 1; i++) {\n        currentDir = await currentDir.getDirectoryHandle(parts[i])\n    }\n\n    const fileName = parts[parts.length - 1]\n    await currentDir.removeEntry(fileName)\n}\n\n// Sync - removes file from VFS\nexport const unlinkSync = (path: string): void => {\n    // Only queue delete if file exists\n    if (existsInVfs(path)) {\n        queueEvent('delete', path)\n    }\n    deleteFromVfs(path)\n}\n","// mkdir implementation using OPFS\n\nimport { queueEvent, createDirInVfs, isDirectoryInVfs, normalizePath, saveIndex } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Async - creates directory in OPFS\nexport const mkdir = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    options?: { recursive?: boolean }\n): Promise<void> => {\n    const normalizedPath = normalizePath(path)\n    const parts = normalizedPath.split('/').filter(p => p.length > 0)\n    let currentDir = root\n\n    if (options?.recursive) {\n        // Create all directories in path\n        let currentPath = ''\n        for (const part of parts) {\n            currentPath = currentPath ? `${currentPath}/${part}` : part\n            // Only queue create if directory doesn't already exist\n            if (!isDirectoryInVfs(currentPath)) {\n                queueEvent('create', currentPath)\n            }\n            currentDir = await currentDir.getDirectoryHandle(part, { create: true })\n        }\n    } else {\n        // Non-recursive: only queue if directory doesn't exist\n        if (!isDirectoryInVfs(normalizedPath)) {\n            queueEvent('create', normalizedPath)\n        }\n        // Create only the final directory (parent must exist)\n        for (let i = 0; i < parts.length - 1; i++) {\n            currentDir = await currentDir.getDirectoryHandle(parts[i])\n        }\n        await currentDir.getDirectoryHandle(parts[parts.length - 1], { create: true })\n    }\n}\n\n// Sync - creates directory entry in VFS\nexport const mkdirSync = (\n    path: string,\n    options?: { recursive?: boolean }\n): void => {\n    // Debug: log all dist directory creation\n    if (path.includes('/dist')) {\n        console.log(`[mkdirSync] Creating dist directory: ${path} (recursive: ${options?.recursive})`)\n    }\n    const normalizedPath = normalizePath(path)\n\n    if (options?.recursive) {\n        // Create all directories in path - batch saves for performance\n        const parts = normalizedPath.split('/').filter(p => p.length > 0)\n        let currentPath = ''\n        for (let i = 0; i < parts.length; i++) {\n            currentPath = currentPath ? `${currentPath}/${parts[i]}` : parts[i]\n            // Only queue create if directory doesn't already exist\n            // This prevents queueing creates for parent dirs in recursive mkdir\n            if (!isDirectoryInVfs(currentPath)) {\n                queueEvent('create', currentPath)\n            }\n            // Defer save until last directory\n            createDirInVfs(currentPath, i < parts.length - 1)\n        }\n        // Ensure index is saved after all directories created\n        if (parts.length > 0) {\n            saveIndex()\n        }\n    } else {\n        // Check parent exists\n        const parts = normalizedPath.split('/')\n        if (parts.length > 1) {\n            const parentPath = parts.slice(0, -1).join('/')\n            if (!isDirectoryInVfs(parentPath)) {\n                throw createENOENT('mkdir', path)\n            }\n        }\n        // Only queue create if directory doesn't already exist\n        if (!isDirectoryInVfs(normalizedPath)) {\n            queueEvent('create', normalizedPath)\n        }\n        createDirInVfs(normalizedPath)\n    }\n}\n","// rmdir implementation using OPFS\n\nimport { queueEvent, deleteDirFromVfs, deleteFromVfs, getVfsIndex, getVfsDirIndex, normalizePath, isDirectoryInVfs } from '../fs.vfs'\nimport { FSError } from '../classes'\n\n// Async - removes directory from OPFS\nexport const rmdir = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    options?: { recursive?: boolean }\n): Promise<void> => {\n    queueEvent('delete', path)\n    const parts = path.split('/').filter(p => p.length > 0)\n    let currentDir = root\n\n    // Navigate to parent directory\n    for (let i = 0; i < parts.length - 1; i++) {\n        currentDir = await currentDir.getDirectoryHandle(parts[i])\n    }\n\n    const dirName = parts[parts.length - 1]\n    await currentDir.removeEntry(dirName, { recursive: options?.recursive })\n}\n\n// Sync - removes directory from VFS\nexport const rmdirSync = (\n    path: string,\n    options?: { recursive?: boolean }\n): void => {\n    const normalizedPath = normalizePath(path)\n\n    // Only queue delete if directory exists\n    if (isDirectoryInVfs(normalizedPath)) {\n        queueEvent('delete', normalizedPath)\n    }\n    const vfsIndex = getVfsIndex()\n    const vfsDirIndex = getVfsDirIndex()\n    const prefix = `${normalizedPath}/`\n\n    // Check for files in directory\n    const filesInDir: string[] = []\n    for (const filePath of vfsIndex.keys()) {\n        if (filePath.startsWith(prefix)) {\n            filesInDir.push(filePath)\n        }\n    }\n\n    // Check for subdirectories\n    const subDirs: string[] = []\n    for (const dirPath of vfsDirIndex) {\n        if (dirPath.startsWith(prefix)) {\n            subDirs.push(dirPath)\n        }\n    }\n\n    if (!options?.recursive && (filesInDir.length > 0 || subDirs.length > 0)) {\n        throw new FSError('ENOTEMPTY', 'rmdir', path)\n    }\n\n    if (options?.recursive) {\n        // Delete all files in directory\n        for (const filePath of filesInDir) {\n            queueEvent('delete', filePath)\n            deleteFromVfs(filePath)\n        }\n        // Delete all subdirectories\n        for (const dirPath of subDirs) {\n            queueEvent('delete', dirPath)\n            deleteDirFromVfs(dirPath)\n        }\n    }\n\n    // Delete the directory itself\n    deleteDirFromVfs(normalizedPath)\n}\n","// readdir implementation using OPFS\n\nimport { getVfsIndex, getVfsDirIndex, isSymlinkInVfs, normalizePath, getVfsSymlinkIndex } from '../fs.vfs'\nimport { Dirent, createDirent } from '../classes'\n\nexport interface ReaddirOptions {\n    withFileTypes?: boolean\n    encoding?: BufferEncoding | 'buffer'\n    recursive?: boolean\n}\n\n// Async - reads directory entries from OPFS\nexport const readdir = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    options?: ReaddirOptions\n): Promise<string[] | Dirent[]> => {\n    const parts = path.split('/').filter(p => p.length > 0)\n    let currentDir = root\n\n    // Navigate to target directory\n    for (const part of parts) {\n        currentDir = await currentDir.getDirectoryHandle(part)\n    }\n\n    const entries: Array<{ name: string; kind: 'file' | 'directory' }> = []\n\n    for await (const [name, handle] of (currentDir as any).entries()) {\n        entries.push({ name, kind: handle.kind })\n    }\n\n    // Handle recursive option\n    if (options?.recursive) {\n        const allEntries = [...entries]\n        for (const entry of entries) {\n            if (entry.kind === 'directory') {\n                const subPath = path ? `${path}/${entry.name}` : entry.name\n                const subEntries = await readdir(root, subPath, { ...options, withFileTypes: false }) as string[]\n                for (const subEntry of subEntries) {\n                    allEntries.push({\n                        name: `${entry.name}/${subEntry}`,\n                        kind: 'file' // Will be determined properly if withFileTypes\n                    })\n                }\n            }\n        }\n        if (options?.withFileTypes) {\n            return allEntries.map(({ name, kind }) =>\n                createDirent(name, kind === 'directory', false, path)\n            )\n        }\n        return allEntries.map(e => e.name)\n    }\n\n    if (options?.withFileTypes) {\n        return entries.map(({ name, kind }) =>\n            createDirent(name, kind === 'directory', false, path)\n        )\n    }\n\n    return entries.map(e => e.name)\n}\n\n// Sync - reads directory entries from VFS index\nexport const readdirSync = (\n    path: string,\n    options?: ReaddirOptions\n): string[] | Dirent[] => {\n    const vfsIndex = getVfsIndex()\n    const vfsDirIndex = getVfsDirIndex()\n    const normalizedPath = normalizePath(path)\n    const prefix = normalizedPath ? `${normalizedPath}/` : ''\n\n    const entriesSet = new Set<string>()\n    const entryTypes = new Map<string, { isDir: boolean; isSymlink: boolean }>()\n\n    // Add entries from files\n    for (const filePath of vfsIndex.keys()) {\n        if (prefix && !filePath.startsWith(prefix)) continue\n        if (!prefix && filePath.includes('/')) {\n            // Root level - get first directory component\n            const firstPart = filePath.split('/')[0]\n            entriesSet.add(firstPart)\n            entryTypes.set(firstPart, { isDir: true, isSymlink: false })\n        } else if (prefix) {\n            // Get next path component after prefix\n            const remainder = filePath.slice(prefix.length)\n            const nextPart = remainder.split('/')[0]\n            if (nextPart) {\n                entriesSet.add(nextPart)\n                // It's a directory if there's more path after it\n                const isDir = remainder.includes('/')\n                const fullPath = prefix + nextPart\n                const isSymlink = isSymlinkInVfs(fullPath)\n                entryTypes.set(nextPart, { isDir, isSymlink })\n            }\n        } else {\n            // Root level file\n            const isSymlink = isSymlinkInVfs(filePath)\n            entriesSet.add(filePath)\n            entryTypes.set(filePath, { isDir: false, isSymlink })\n        }\n    }\n\n    // Add entries from explicit empty directories\n    for (const dirPath of vfsDirIndex) {\n        if (prefix && !dirPath.startsWith(prefix)) continue\n        if (!prefix && dirPath.includes('/')) {\n            // Root level - get first directory component\n            const firstPart = dirPath.split('/')[0]\n            entriesSet.add(firstPart)\n            entryTypes.set(firstPart, { isDir: true, isSymlink: false })\n        } else if (prefix) {\n            // Get next path component after prefix\n            const remainder = dirPath.slice(prefix.length)\n            const nextPart = remainder.split('/')[0]\n            if (nextPart) {\n                entriesSet.add(nextPart)\n                entryTypes.set(nextPart, { isDir: true, isSymlink: false })\n            }\n        } else if (!prefix && !dirPath.includes('/')) {\n            // Root level empty directory\n            entriesSet.add(dirPath)\n            entryTypes.set(dirPath, { isDir: true, isSymlink: false })\n        }\n    }\n\n    // Add entries from symlinks (stored separately from files)\n    const vfsSymlinkIndex = getVfsSymlinkIndex()\n    for (const symlinkPath of vfsSymlinkIndex.keys()) {\n        if (prefix && !symlinkPath.startsWith(prefix)) continue\n        if (!prefix && symlinkPath.includes('/')) {\n            // Root level - get first directory component (parent dir of symlink)\n            const firstPart = symlinkPath.split('/')[0]\n            if (!entriesSet.has(firstPart)) {\n                entriesSet.add(firstPart)\n                entryTypes.set(firstPart, { isDir: true, isSymlink: false })\n            }\n        } else if (prefix) {\n            // Get next path component after prefix\n            const remainder = symlinkPath.slice(prefix.length)\n            const nextPart = remainder.split('/')[0]\n            if (nextPart && !remainder.includes('/')) {\n                // This is a direct child symlink\n                entriesSet.add(nextPart)\n                entryTypes.set(nextPart, { isDir: false, isSymlink: true })\n            } else if (nextPart) {\n                // This is a parent directory containing symlinks\n                if (!entriesSet.has(nextPart)) {\n                    entriesSet.add(nextPart)\n                    entryTypes.set(nextPart, { isDir: true, isSymlink: false })\n                }\n            }\n        } else {\n            // Root level symlink\n            entriesSet.add(symlinkPath)\n            entryTypes.set(symlinkPath, { isDir: false, isSymlink: true })\n        }\n    }\n\n    let entries = Array.from(entriesSet)\n\n    // Handle recursive option\n    if (options?.recursive) {\n        const allEntries: string[] = []\n        const allTypes = new Map<string, { isDir: boolean; isSymlink: boolean }>()\n\n        for (const name of entries) {\n            const type = entryTypes.get(name)!\n            allEntries.push(name)\n            allTypes.set(name, type)\n\n            if (type.isDir) {\n                const subPath = normalizedPath ? `${normalizedPath}/${name}` : name\n                const subEntries = readdirSync(subPath, { recursive: true }) as string[]\n                for (const subEntry of subEntries) {\n                    const fullName = `${name}/${subEntry}`\n                    allEntries.push(fullName)\n                    // Determine type for sub entry\n                    const subFullPath = subPath + '/' + subEntry\n                    const subIsSymlink = isSymlinkInVfs(subFullPath)\n                    const subIsDir = vfsDirIndex.has(subFullPath) ||\n                        Array.from(vfsIndex.keys()).some(p => p.startsWith(subFullPath + '/'))\n                    allTypes.set(fullName, { isDir: subIsDir, isSymlink: subIsSymlink })\n                }\n            }\n        }\n\n        if (options?.withFileTypes) {\n            return allEntries.map(name => {\n                const type = allTypes.get(name) ?? { isDir: false, isSymlink: false }\n                return createDirent(name, type.isDir, type.isSymlink, normalizedPath)\n            })\n        }\n\n        return allEntries\n    }\n\n    if (options?.withFileTypes) {\n        return entries.map(name => {\n            const type = entryTypes.get(name) ?? { isDir: false, isSymlink: false }\n            return createDirent(name, type.isDir, type.isSymlink, normalizedPath)\n        })\n    }\n\n    return entries\n}\n","// stat implementation using OPFS\n\nimport { getVfsIndex, getVfsDirIndex, getMetadataFromVfs, isSymlinkInVfs, resolveSymlinkInVfs, normalizePath } from '../fs.vfs'\nimport { Stats, BigIntStats, createStats as createStatsClass, createENOENT } from '../classes'\nimport { S_IFREG, S_IFDIR, S_IFLNK } from '../constants'\n\nexport interface StatOptions {\n    bigint?: boolean\n}\n\n// Common file extensions that indicate a path is likely a file, not a directory\n// Used as a defensive check to prevent false positive directory detection\nconst FILE_EXTENSIONS = /\\.(ts|tsx|js|jsx|mjs|cjs|mts|cts|vue|svelte|json|css|scss|sass|less|html|htm|md|txt|xml|yaml|yml|toml|wasm|map|d\\.ts)$/i\n\nconst createStats = (\n    size: number,\n    isDir: boolean,\n    isSymlink: boolean = false,\n    metadata?: { mode?: number; uid?: number; gid?: number; atimeMs?: number; mtimeMs?: number },\n    bigint: boolean = false\n): Stats | BigIntStats => {\n    const now = Date.now()\n\n    // Determine file type bits\n    let typeBits: number\n    if (isSymlink) {\n        typeBits = S_IFLNK\n    } else if (isDir) {\n        typeBits = S_IFDIR\n    } else {\n        typeBits = S_IFREG\n    }\n\n    // Get permission bits (default 755 for dirs, 644 for files)\n    const permBits = metadata?.mode !== undefined\n        ? (metadata.mode & 0o7777)\n        : (isDir ? 0o755 : 0o644)\n\n    const mode = typeBits | permBits\n\n    return createStatsClass(\n        size,\n        mode,\n        metadata?.uid ?? 0,\n        metadata?.gid ?? 0,\n        metadata?.atimeMs ?? now,\n        metadata?.mtimeMs ?? now,\n        metadata?.mtimeMs ?? now,\n        bigint\n    )\n}\n\n// Async - gets file/directory stats from OPFS\nexport const stat = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    options?: StatOptions\n): Promise<Stats | BigIntStats> => {\n    const parts = path.split('/').filter(p => p.length > 0)\n    const bigint = options?.bigint ?? false\n\n    if (parts.length === 0) {\n        // Root directory\n        return createStats(0, true, false, undefined, bigint)\n    }\n\n    let currentDir = root\n\n    // Try to navigate as directories first\n    for (let i = 0; i < parts.length - 1; i++) {\n        currentDir = await currentDir.getDirectoryHandle(parts[i])\n    }\n\n    const lastName = parts[parts.length - 1]\n\n    // Try as file first\n    try {\n        const fileHandle = await currentDir.getFileHandle(lastName)\n        const file = await fileHandle.getFile()\n        return createStats(file.size, false, false, {\n            mtimeMs: file.lastModified,\n            atimeMs: file.lastModified,\n        }, bigint)\n    } catch {\n        // Try as directory\n        try {\n            await currentDir.getDirectoryHandle(lastName)\n            return createStats(0, true, false, undefined, bigint)\n        } catch {\n            throw createENOENT('stat', path)\n        }\n    }\n}\n\n// Sync - gets file stats from VFS index\nexport const statSync = (path: string, options?: StatOptions): Stats | BigIntStats => {\n    const vfsIndex = getVfsIndex()\n    const vfsDirIndex = getVfsDirIndex()\n    let normalizedPath = normalizePath(path)\n    const bigint = options?.bigint ?? false\n\n    // Root directory (empty string, or \".\" which represents current dir)\n    if (normalizedPath === '' || normalizedPath === '.') {\n        return createStats(0, true, false, undefined, bigint)\n    }\n\n    // For stat, follow symlinks to get target's stats\n    if (isSymlinkInVfs(normalizedPath)) {\n        normalizedPath = resolveSymlinkInVfs(normalizedPath)\n    }\n\n    // Get metadata if available\n    const metadata = getMetadataFromVfs(normalizedPath)\n\n    // Check if it's a file\n    const entry = vfsIndex.get(normalizedPath)\n    if (entry) {\n        return createStats(entry.size, false, false, metadata ?? undefined, bigint)\n    }\n\n    // Check if it's an explicit empty directory\n    if (vfsDirIndex.has(normalizedPath)) {\n        return createStats(0, true, false, metadata ?? undefined, bigint)\n    }\n\n    // Check if it's an implicit directory (any file starts with this path)\n    // Skip this check for paths that look like files (have common file extensions)\n    // This prevents false positives from VFS state inconsistencies\n    const looksLikeFile = FILE_EXTENSIONS.test(normalizedPath)\n\n    if (!looksLikeFile) {\n        const prefix = `${normalizedPath}/`\n        for (const filePath of vfsIndex.keys()) {\n            if (filePath.startsWith(prefix)) {\n                return createStats(0, true, false, metadata ?? undefined, bigint)\n            }\n        }\n\n        // Check if any explicit dir starts with this path\n        for (const dirPath of vfsDirIndex) {\n            if (dirPath.startsWith(prefix)) {\n                return createStats(0, true, false, metadata ?? undefined, bigint)\n            }\n        }\n    }\n\n    throw createENOENT('stat', path)\n}\n\n// lstat returns symlink info instead of following the symlink\nexport const lstat = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    options?: StatOptions\n): Promise<Stats | BigIntStats> => {\n    // For OPFS, lstat is same as stat since OPFS doesn't have real symlinks\n    // But we check VFS for emulated symlinks\n    return stat(root, path, options)\n}\n\nexport const lstatSync = (path: string, options?: StatOptions): Stats | BigIntStats => {\n    const vfsIndex = getVfsIndex()\n    const vfsDirIndex = getVfsDirIndex()\n    const normalizedPath = normalizePath(path)\n    const bigint = options?.bigint ?? false\n\n    // Check if it's a symlink - for lstat we don't follow it\n    const isSymlink = isSymlinkInVfs(normalizedPath)\n    const metadata = getMetadataFromVfs(normalizedPath)\n\n    if (isSymlink) {\n        // Return symlink stats\n        return createStats(0, false, true, metadata ?? undefined, bigint)\n    }\n\n    // Otherwise same as stat\n    return statSync(path, options)\n}\n","// rename implementation using OPFS\n\nimport {\n    queueEvent,\n    readFileFromVfs,\n    writeFileToVfs,\n    deleteFromVfs,\n    getVfsIndex,\n    getVfsDirIndex,\n    isDirectoryInVfs,\n    normalizePath,\n    createDirInVfs,\n    deleteDirFromVfs,\n} from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Async - renames/moves file in OPFS\nexport const rename = async (\n    root: FileSystemDirectoryHandle,\n    oldPath: string,\n    newPath: string\n): Promise<void> => {\n    queueEvent('delete', oldPath)\n    queueEvent('create', newPath)\n\n    // Read from old location\n    const oldParts = oldPath.split('/').filter(p => p.length > 0)\n    let oldDir = root\n    for (let i = 0; i < oldParts.length - 1; i++) {\n        oldDir = await oldDir.getDirectoryHandle(oldParts[i])\n    }\n    const oldFileHandle = await oldDir.getFileHandle(oldParts[oldParts.length - 1])\n    const file = await oldFileHandle.getFile()\n    const data = await file.arrayBuffer()\n\n    // Write to new location\n    const newParts = newPath.split('/').filter(p => p.length > 0)\n    let newDir = root\n    for (let i = 0; i < newParts.length - 1; i++) {\n        newDir = await newDir.getDirectoryHandle(newParts[i], { create: true })\n    }\n    const newFileHandle = await newDir.getFileHandle(newParts[newParts.length - 1], { create: true })\n    const writable = await newFileHandle.createWritable()\n    await writable.write(data)\n    await writable.close()\n\n    // Remove old file\n    await oldDir.removeEntry(oldParts[oldParts.length - 1])\n}\n\n// Sync - renames/moves file or directory in VFS\nexport const renameSync = (oldPath: string, newPath: string): void => {\n    const normalizedOldPath = normalizePath(oldPath)\n    const normalizedNewPath = normalizePath(newPath)\n    const vfsIndex = getVfsIndex()\n    const vfsDirIndex = getVfsDirIndex()\n\n    // Case 1: It's a file\n    const data = readFileFromVfs(normalizedOldPath)\n    if (data !== null) {\n        queueEvent('delete', normalizedOldPath)\n        queueEvent('create', normalizedNewPath)\n\n        // Write to new location first, then delete old\n        const content = data instanceof Buffer ? data : Buffer.from(data)\n        writeFileToVfs(normalizedNewPath, content)\n        deleteFromVfs(normalizedOldPath)\n        return\n    }\n\n    // Case 2: It's a directory\n    if (isDirectoryInVfs(normalizedOldPath)) {\n        const oldPrefix = normalizedOldPath + '/'\n        const filesToRename: Array<{ oldPath: string; newPath: string }> = []\n\n        // Find all files under this directory\n        for (const filePath of vfsIndex.keys()) {\n            if (filePath.startsWith(oldPrefix) || filePath === normalizedOldPath) {\n                const relativePath = filePath.slice(oldPrefix.length)\n                const newFilePath = normalizedNewPath + '/' + relativePath\n                filesToRename.push({ oldPath: filePath, newPath: newFilePath })\n            }\n        }\n\n        // Find all subdirectories\n        const dirsToRename: Array<{ oldPath: string; newPath: string }> = []\n        for (const dirPath of vfsDirIndex) {\n            if (dirPath.startsWith(oldPrefix) || dirPath === normalizedOldPath) {\n                if (dirPath === normalizedOldPath) {\n                    dirsToRename.push({ oldPath: dirPath, newPath: normalizedNewPath })\n                } else {\n                    const relativePath = dirPath.slice(oldPrefix.length)\n                    const newDirPath = normalizedNewPath + '/' + relativePath\n                    dirsToRename.push({ oldPath: dirPath, newPath: newDirPath })\n                }\n            }\n        }\n\n        // Rename all files\n        for (const { oldPath: op, newPath: np } of filesToRename) {\n            const fileData = readFileFromVfs(op)\n            if (fileData !== null) {\n                queueEvent('delete', op)\n                queueEvent('create', np)\n                const content = fileData instanceof Buffer ? fileData : Buffer.from(fileData)\n                writeFileToVfs(np, content)\n                deleteFromVfs(op)\n            }\n        }\n\n        // Rename all directories\n        for (const { oldPath: op, newPath: np } of dirsToRename) {\n            queueEvent('delete', op)\n            queueEvent('create', np)\n            deleteDirFromVfs(op)\n            createDirInVfs(np)\n        }\n\n        return\n    }\n\n    // Neither file nor directory exists\n    throw createENOENT('rename', oldPath)\n}\n","// copyFile implementation using OPFS with streaming for memory efficiency\n\nimport { queueEvent, readFileFromVfs, writeFileToVfs, existsInVfs } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Chunk size for streaming copies (1MB)\nconst STREAM_CHUNK_SIZE = 1024 * 1024\n\n// Async - copies file in OPFS using streaming for memory efficiency\nexport const copyFile = async (\n    root: FileSystemDirectoryHandle,\n    src: string,\n    dest: string\n): Promise<void> => {\n    queueEvent('create', dest)\n\n    // Get source file handle\n    const srcParts = src.split('/').filter(p => p.length > 0)\n    let srcDir = root\n    for (let i = 0; i < srcParts.length - 1; i++) {\n        srcDir = await srcDir.getDirectoryHandle(srcParts[i])\n    }\n    const srcFileHandle = await srcDir.getFileHandle(srcParts[srcParts.length - 1])\n    const file = await srcFileHandle.getFile()\n\n    // Get destination file handle\n    const destParts = dest.split('/').filter(p => p.length > 0)\n    let destDir = root\n    for (let i = 0; i < destParts.length - 1; i++) {\n        destDir = await destDir.getDirectoryHandle(destParts[i], { create: true })\n    }\n    const destFileHandle = await destDir.getFileHandle(destParts[destParts.length - 1], { create: true })\n\n    // Use streaming for memory-efficient copy\n    // For small files (< 1MB), use direct copy for simplicity\n    if (file.size < STREAM_CHUNK_SIZE) {\n        const data = await file.arrayBuffer()\n        const writable = await destFileHandle.createWritable()\n        await writable.write(data)\n        await writable.close()\n        return\n    }\n\n    // For large files, use stream piping\n    const readable = file.stream()\n    const writable = await destFileHandle.createWritable()\n\n    try {\n        await readable.pipeTo(writable)\n    } catch (error) {\n        // If pipeTo fails (e.g., browser doesn't support it), fall back to chunked copy\n        await copyFileChunked(file, destFileHandle)\n    }\n}\n\n// Fallback chunked copy for browsers that don't support pipeTo\nasync function copyFileChunked(\n    file: File,\n    destFileHandle: FileSystemFileHandle\n): Promise<void> {\n    const writable = await destFileHandle.createWritable()\n    const size = file.size\n    let offset = 0\n\n    try {\n        while (offset < size) {\n            const end = Math.min(offset + STREAM_CHUNK_SIZE, size)\n            const chunk = file.slice(offset, end)\n            const buffer = await chunk.arrayBuffer()\n            await writable.write({ type: 'write', position: offset, data: buffer })\n            offset = end\n        }\n    } finally {\n        await writable.close()\n    }\n}\n\n// Sync - copies file in VFS\nexport const copyFileSync = (src: string, dest: string): void => {\n    const data = readFileFromVfs(src)\n    if (data === null) {\n        throw createENOENT('copyfile', src)\n    }\n\n    // Queue 'create' for new files, 'update' if dest already exists\n    const eventType = existsInVfs(dest) ? 'update' : 'create'\n    queueEvent(eventType, dest)\n\n    const content = data instanceof Buffer ? data : Buffer.from(data)\n    writeFileToVfs(dest, content)\n}\n","// appendFile implementation using OPFS\n\nimport { queueEvent, readFileFromVfs, writeFileToVfs, existsInVfs } from '../fs.vfs'\n\n// Async - appends to file in OPFS\nexport const appendFile = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    data: string | Buffer\n): Promise<void> => {\n    queueEvent('update', path)\n\n    const parts = path.split('/').filter(p => p.length > 0)\n    let currentDir = root\n\n    for (let i = 0; i < parts.length - 1; i++) {\n        currentDir = await currentDir.getDirectoryHandle(parts[i], { create: true })\n    }\n\n    const fileName = parts[parts.length - 1]\n    const fileHandle = await currentDir.getFileHandle(fileName, { create: true })\n\n    // Read existing content\n    const file = await fileHandle.getFile()\n    const existingData = await file.arrayBuffer()\n\n    // Append new data\n    const newData = typeof data === 'string' ? new TextEncoder().encode(data) : new Uint8Array(data)\n    const combined = new Uint8Array(existingData.byteLength + newData.length)\n    combined.set(new Uint8Array(existingData), 0)\n    combined.set(newData, existingData.byteLength)\n\n    // Write combined data\n    const writable = await fileHandle.createWritable()\n    await writable.write(combined)\n    await writable.close()\n}\n\n// Sync - appends to file in VFS\nexport const appendFileSync = (\n    path: string,\n    data: string | Buffer\n): void => {\n    // Queue 'create' for new files, 'update' for existing files\n    const eventType = existsInVfs(path) ? 'update' : 'create'\n    queueEvent(eventType, path)\n\n    const existing = readFileFromVfs(path)\n    const existingBuffer = existing ? (existing instanceof Buffer ? existing : Buffer.from(existing)) : Buffer.alloc(0)\n    const newBuffer = typeof data === 'string' ? Buffer.from(data) : data\n\n    const combined = Buffer.concat([existingBuffer, newBuffer])\n    writeFileToVfs(path, combined)\n}\n","// rm implementation using OPFS (recursive delete)\n\nimport { queueEvent, deleteFromVfs, getVfsIndex, getVfsDirIndex, deleteDirFromVfs, normalizePath, getVfsSymlinkIndex, deleteSymlinkFromVfs } from '../fs.vfs'\nimport { createENOENT, FSError } from '../classes'\n\n// Async - removes file or directory recursively from OPFS\nexport const rm = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    options?: { recursive?: boolean; force?: boolean }\n): Promise<void> => {\n    const parts = path.split('/').filter(p => p.length > 0)\n\n    if (parts.length === 0) {\n        throw new Error('EPERM: operation not permitted, rm')\n    }\n\n    let currentDir = root\n\n    // Navigate to parent directory\n    for (let i = 0; i < parts.length - 1; i++) {\n        try {\n            currentDir = await currentDir.getDirectoryHandle(parts[i])\n        } catch (err) {\n            if (options?.force) return\n            throw err\n        }\n    }\n\n    const name = parts[parts.length - 1]\n\n    try {\n        queueEvent('delete', path)\n        await currentDir.removeEntry(name, { recursive: options?.recursive })\n    } catch (err) {\n        if (options?.force) return\n        throw err\n    }\n}\n\n// Sync - removes file or directory recursively from VFS\nexport const rmSync = (\n    path: string,\n    options?: { recursive?: boolean; force?: boolean }\n): void => {\n    const vfsIndex = getVfsIndex()\n    const vfsDirIndex = getVfsDirIndex()\n    const normalizedPath = normalizePath(path)\n\n    // Check if it's a direct file\n    if (vfsIndex.has(normalizedPath)) {\n        queueEvent('delete', normalizedPath)\n        deleteFromVfs(normalizedPath)\n        return\n    }\n\n    // Check for directory (files with this prefix or explicit dir entry)\n    const prefix = `${normalizedPath}/`\n    const filesToDelete: string[] = []\n    const dirsToDelete: string[] = []\n    const symlinksToDelete: string[] = []\n\n    // Find files to delete\n    for (const filePath of vfsIndex.keys()) {\n        if (filePath.startsWith(prefix)) {\n            filesToDelete.push(filePath)\n        }\n    }\n\n    // Find explicit directories to delete (including the target dir and subdirs)\n    if (vfsDirIndex.has(normalizedPath)) {\n        dirsToDelete.push(normalizedPath)\n    }\n    for (const dirPath of vfsDirIndex) {\n        if (dirPath.startsWith(prefix)) {\n            dirsToDelete.push(dirPath)\n        }\n    }\n\n    // Find symlinks to delete\n    const vfsSymlinkIndex = getVfsSymlinkIndex()\n    for (const symlinkPath of vfsSymlinkIndex.keys()) {\n        if (symlinkPath === normalizedPath || symlinkPath.startsWith(prefix)) {\n            symlinksToDelete.push(symlinkPath)\n        }\n    }\n\n    // Check if anything exists to delete\n    if (filesToDelete.length === 0 && dirsToDelete.length === 0 && symlinksToDelete.length === 0) {\n        if (options?.force) return\n        throw createENOENT('rm', path)\n    }\n\n    // If there are files/subdirs, require recursive option\n    if (!options?.recursive && (filesToDelete.length > 0 || dirsToDelete.length > 1 || symlinksToDelete.length > 0)) {\n        throw new FSError('EISDIR', 'rm', path)\n    }\n\n    // Delete all files with this prefix\n    for (const filePath of filesToDelete) {\n        queueEvent('delete', filePath)\n        deleteFromVfs(filePath)\n    }\n\n    // Delete all symlinks with this prefix\n    for (const symlinkPath of symlinksToDelete) {\n        queueEvent('delete', symlinkPath)\n        deleteSymlinkFromVfs(symlinkPath)\n    }\n\n    // Delete all explicit directory entries\n    for (const dirPath of dirsToDelete) {\n        queueEvent('delete', dirPath)\n        deleteDirFromVfs(dirPath)\n    }\n}\n","// access implementation using OPFS\n\nimport { existsInVfs, isDirectoryInVfs, normalizePath } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Access constants (matching Node.js fs.constants)\nexport const constants = {\n    F_OK: 0,  // File exists\n    R_OK: 4,  // File is readable\n    W_OK: 2,  // File is writable\n    X_OK: 1,  // File is executable\n}\n\n// Async - checks if file/directory is accessible in OPFS\nexport const access = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    mode: number = constants.F_OK\n): Promise<void> => {\n    const parts = path.split('/').filter(p => p.length > 0)\n\n    if (parts.length === 0) {\n        // Root always exists\n        return\n    }\n\n    let currentDir = root\n    for (let i = 0; i < parts.length - 1; i++) {\n        try {\n            currentDir = await currentDir.getDirectoryHandle(parts[i])\n        } catch {\n            throw createENOENT('access', path)\n        }\n    }\n\n    const name = parts[parts.length - 1]\n\n    // Try as file first, then as directory\n    try {\n        await currentDir.getFileHandle(name)\n        return\n    } catch {\n        try {\n            await currentDir.getDirectoryHandle(name)\n            return\n        } catch {\n            throw createENOENT('access', path)\n        }\n    }\n}\n\n// Sync - checks if file/directory exists in VFS\nexport const accessSync = (\n    path: string,\n    mode: number = constants.F_OK\n): void => {\n    const normalizedPath = normalizePath(path)\n\n    if (normalizedPath === '') return\n\n    if (!existsInVfs(normalizedPath) && !isDirectoryInVfs(normalizedPath)) {\n        throw createENOENT('access', path)\n    }\n}\n","// chmod implementation using VFS metadata\n\nimport { queueEvent, chmodInVfs, existsInVfs, isDirectoryInVfs, normalizePath } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Async - sets file mode in VFS metadata\nexport const chmod = async (\n    _root: FileSystemDirectoryHandle,\n    path: string,\n    mode: number\n): Promise<void> => {\n    queueEvent('update', path)\n    const normalizedPath = normalizePath(path)\n    if (!existsInVfs(normalizedPath) && !isDirectoryInVfs(normalizedPath)) {\n        throw createENOENT('chmod', path)\n    }\n    chmodInVfs(normalizedPath, mode)\n}\n\n// Sync - sets file mode in VFS metadata\nexport const chmodSync = (\n    path: string,\n    mode: number\n): void => {\n    queueEvent('update', path)\n    const normalizedPath = normalizePath(path)\n    if (!existsInVfs(normalizedPath) && !isDirectoryInVfs(normalizedPath)) {\n        throw createENOENT('chmod', path)\n    }\n    chmodInVfs(normalizedPath, mode)\n}\n","// chown implementation using VFS metadata\n\nimport { queueEvent, chownInVfs, existsInVfs, isDirectoryInVfs, normalizePath } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Async - sets file owner in VFS metadata\nexport const chown = async (\n    _root: FileSystemDirectoryHandle,\n    path: string,\n    uid: number,\n    gid: number\n): Promise<void> => {\n    queueEvent('update', path)\n    const normalizedPath = normalizePath(path)\n    if (!existsInVfs(normalizedPath) && !isDirectoryInVfs(normalizedPath)) {\n        throw createENOENT('chown', path)\n    }\n    chownInVfs(normalizedPath, uid, gid)\n}\n\n// Sync - sets file owner in VFS metadata\nexport const chownSync = (\n    path: string,\n    uid: number,\n    gid: number\n): void => {\n    queueEvent('update', path)\n    const normalizedPath = normalizePath(path)\n    if (!existsInVfs(normalizedPath) && !isDirectoryInVfs(normalizedPath)) {\n        throw createENOENT('chown', path)\n    }\n    chownInVfs(normalizedPath, uid, gid)\n}\n","// lchmod implementation - no-op in OPFS (no permissions/symlinks)\n\n// Async - no-op\nexport const lchmod = async (\n    _root: FileSystemDirectoryHandle,\n    _path: string,\n    _mode: number\n): Promise<void> => {\n    // No-op: OPFS doesn't have permissions or symlinks\n}\n\n// Sync - no-op\nexport const lchmodSync = (\n    _path: string,\n    _mode: number\n): void => {\n    // No-op: OPFS doesn't have permissions or symlinks\n}\n","// lchown implementation - no-op in OPFS (no ownership/symlinks)\n\n// Async - no-op\nexport const lchown = async (\n    _root: FileSystemDirectoryHandle,\n    _path: string,\n    _uid: number,\n    _gid: number\n): Promise<void> => {\n    // No-op: OPFS doesn't have ownership or symlinks\n}\n\n// Sync - no-op\nexport const lchownSync = (\n    _path: string,\n    _uid: number,\n    _gid: number\n): void => {\n    // No-op: OPFS doesn't have ownership or symlinks\n}\n","// link (hard link) implementation\n// Hard links are emulated by copying the file content reference\n\nimport { queueEvent, readFromVfs, writeToVfs, getVfsIndex, normalizePath } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Async - creates hard link in OPFS (emulated by copying file)\nexport const link = async (\n    root: FileSystemDirectoryHandle,\n    existingPath: string,\n    newPath: string\n): Promise<void> => {\n    queueEvent('create', newPath)\n    const srcParts = existingPath.split('/').filter(p => p.length > 0)\n    const destParts = newPath.split('/').filter(p => p.length > 0)\n    \n    // Navigate to source\n    let srcDir = root\n    for (let i = 0; i < srcParts.length - 1; i++) {\n        srcDir = await srcDir.getDirectoryHandle(srcParts[i])\n    }\n    \n    const srcName = srcParts[srcParts.length - 1]\n    const srcHandle = await srcDir.getFileHandle(srcName)\n    const file = await srcHandle.getFile()\n    const content = new Uint8Array(await file.arrayBuffer())\n    \n    // Navigate/create destination\n    let destDir = root\n    for (let i = 0; i < destParts.length - 1; i++) {\n        destDir = await destDir.getDirectoryHandle(destParts[i], { create: true })\n    }\n    \n    const destName = destParts[destParts.length - 1]\n    const destHandle = await destDir.getFileHandle(destName, { create: true })\n    const writable = await destHandle.createWritable()\n    await writable.write(content)\n    await writable.close()\n}\n\n// Sync - creates hard link in VFS (emulated by sharing same offset/size)\nexport const linkSync = (\n    existingPath: string,\n    newPath: string\n): void => {\n    queueEvent('create', newPath)\n    const normalizedSrc = normalizePath(existingPath)\n    const normalizedDest = normalizePath(newPath)\n    \n    const vfsIndex = getVfsIndex()\n    const srcEntry = vfsIndex.get(normalizedSrc)\n    \n    if (!srcEntry) {\n        throw createENOENT('link', existingPath)\n    }\n    \n    // For VFS, we can truly share the same data by pointing to same offset\n    // This is a real hard link in the VFS sense\n    vfsIndex.set(normalizedDest, { ...srcEntry })\n}\n","// symlink implementation using VFS symlink support\n// Note: Symlinks are VFS-only (emulated), so we don't queue events - observer will never report them\n\nimport { createSymlinkInVfs, normalizePath } from '../fs.vfs'\n\n// Async - creates symlink in OPFS (emulated via metadata, target stored in VFS)\nexport const symlink = async (\n    _root: FileSystemDirectoryHandle,\n    target: string,\n    path: string,\n    _type?: string\n): Promise<void> => {\n    // No queueEvent - symlinks are VFS-only, observer will never report them\n    const normalizedPath = normalizePath(path)\n    createSymlinkInVfs(normalizedPath, target)\n}\n\n// Sync - creates symlink in VFS\nexport const symlinkSync = (\n    target: string,\n    path: string,\n    _type?: string\n): void => {\n    // No queueEvent - symlinks are VFS-only, observer will never report them\n    const normalizedPath = normalizePath(path)\n    createSymlinkInVfs(normalizedPath, target)\n}\n","// readlink implementation using VFS symlink support\n\nimport { readSymlinkFromVfs, isSymlinkInVfs, normalizePath } from '../fs.vfs'\n\n// Async - reads symlink target\nexport const readlink = async (\n    _root: FileSystemDirectoryHandle,\n    path: string\n): Promise<string> => {\n    const normalizedPath = normalizePath(path)\n    const target = readSymlinkFromVfs(normalizedPath)\n\n    if (target === null) {\n        throw new Error(`EINVAL: invalid argument, readlink '${path}'`)\n    }\n\n    return target\n}\n\n// Sync - reads symlink target from VFS\nexport const readlinkSync = (\n    path: string\n): string => {\n    const normalizedPath = normalizePath(path)\n    const target = readSymlinkFromVfs(normalizedPath)\n\n    if (target === null) {\n        throw new Error(`EINVAL: invalid argument, readlink '${path}'`)\n    }\n\n    return target\n}\n","// truncate implementation using OPFS\n\nimport { queueEvent, readFromVfs, writeToVfs, normalizePath } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Async - truncates file in OPFS\nexport const truncate = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    len: number = 0\n): Promise<void> => {\n    queueEvent('update', path)\n    const parts = path.split('/').filter(p => p.length > 0)\n    let currentDir = root\n    \n    for (let i = 0; i < parts.length - 1; i++) {\n        currentDir = await currentDir.getDirectoryHandle(parts[i])\n    }\n    \n    const fileName = parts[parts.length - 1]\n    const fileHandle = await currentDir.getFileHandle(fileName)\n    const file = await fileHandle.getFile()\n    \n    let newContent: Uint8Array\n    if (len === 0) {\n        newContent = new Uint8Array(0)\n    } else if (len < file.size) {\n        const buffer = await file.arrayBuffer()\n        newContent = new Uint8Array(buffer.slice(0, len))\n    } else {\n        // Pad with zeros if len > file.size\n        const buffer = await file.arrayBuffer()\n        newContent = new Uint8Array(len)\n        newContent.set(new Uint8Array(buffer))\n    }\n    \n    const writable = await fileHandle.createWritable()\n    // Create a copy backed by ArrayBuffer (not SharedArrayBuffer) for FileSystemWritableFileStream\n    await writable.write(new Uint8Array(newContent).buffer as ArrayBuffer)\n    await writable.close()\n}\n\n// Sync - truncates file in VFS\nexport const truncateSync = (\n    path: string,\n    len: number = 0\n): void => {\n    queueEvent('update', path)\n    const normalizedPath = normalizePath(path)\n    const content = readFromVfs(normalizedPath)\n    \n    if (content === null) {\n        throw createENOENT('truncate', path)\n    }\n    \n    let newContent: Uint8Array\n    if (len === 0) {\n        newContent = new Uint8Array(0)\n    } else if (len < content.length) {\n        newContent = content.slice(0, len)\n    } else {\n        // Pad with zeros if len > content.length\n        newContent = new Uint8Array(len)\n        newContent.set(content)\n    }\n    \n    writeToVfs(normalizedPath, newContent)\n}\n","// mkdtemp implementation using OPFS\n\nimport { queueEvent, createDirInVfs, normalizePath } from '../fs.vfs'\n\nconst generateRandomString = (length: number): string => {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n    let result = ''\n    for (let i = 0; i < length; i++) {\n        result += chars.charAt(Math.floor(Math.random() * chars.length))\n    }\n    return result\n}\n\n// Async - creates temporary directory in OPFS\nexport const mkdtemp = async (\n    root: FileSystemDirectoryHandle,\n    prefix: string\n): Promise<string> => {\n    const suffix = generateRandomString(6)\n    const dirName = prefix + suffix\n    queueEvent('create', '/' + dirName)\n    const parts = dirName.split('/').filter(p => p.length > 0)\n\n    let currentDir = root\n    for (let i = 0; i < parts.length - 1; i++) {\n        currentDir = await currentDir.getDirectoryHandle(parts[i], { create: true })\n    }\n\n    await currentDir.getDirectoryHandle(parts[parts.length - 1], { create: true })\n    return '/' + dirName\n}\n\n// Sync - creates temporary directory in VFS\nexport const mkdtempSync = (\n    prefix: string\n): string => {\n    const normalizedPrefix = normalizePath(prefix)\n    const suffix = generateRandomString(6)\n    const dirPath = normalizedPrefix + suffix\n    queueEvent('create', '/' + dirPath)\n\n    // Create parent directories if needed\n    const parts = dirPath.split('/').filter(p => p.length > 0)\n    let currentPath = ''\n    for (const part of parts) {\n        currentPath = currentPath ? `${currentPath}/${part}` : part\n        createDirInVfs(currentPath)\n    }\n    \n    return '/' + dirPath\n}\n","// realpath implementation using OPFS\n\nimport { existsInVfs, isDirectoryInVfs, normalizePath } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// Resolve path components (resolve . and ..)\nconst resolvePath = (path: string): string => {\n    const parts = path.split('/').filter(p => p.length > 0)\n    const result: string[] = []\n    \n    for (const part of parts) {\n        if (part === '.') continue\n        if (part === '..') {\n            result.pop()\n        } else {\n            result.push(part)\n        }\n    }\n    \n    return '/' + result.join('/')\n}\n\n// Async - resolves path in OPFS\nexport const realpath = async (\n    root: FileSystemDirectoryHandle,\n    path: string\n): Promise<string> => {\n    const resolved = resolvePath(path)\n    const parts = resolved.split('/').filter(p => p.length > 0)\n\n    if (parts.length === 0) return '/'\n\n    let currentDir = root\n    for (let i = 0; i < parts.length - 1; i++) {\n        try {\n            currentDir = await currentDir.getDirectoryHandle(parts[i])\n        } catch {\n            throw createENOENT('realpath', path)\n        }\n    }\n\n    const name = parts[parts.length - 1]\n    try {\n        await currentDir.getFileHandle(name)\n        return resolved\n    } catch {\n        try {\n            await currentDir.getDirectoryHandle(name)\n            return resolved\n        } catch {\n            throw createENOENT('realpath', path)\n        }\n    }\n}\n\n// Sync - resolves path in VFS\nexport const realpathSync = (\n    path: string\n): string => {\n    const resolved = resolvePath(path)\n    const cleanPath = normalizePath(resolved)\n\n    if (cleanPath === '') return '/'\n\n    if (!existsInVfs(cleanPath) && !isDirectoryInVfs(cleanPath)) {\n        throw createENOENT('realpath', path)\n    }\n\n    return resolved\n}\n","// utimes implementation using VFS metadata\n\nimport { queueEvent, utimesInVfs, existsInVfs, isDirectoryInVfs, normalizePath } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\nconst toTimestamp = (time: number | string | Date): number => {\n    if (typeof time === 'number') return time\n    if (typeof time === 'string') return new Date(time).getTime()\n    return time.getTime()\n}\n\n// Async - sets file access/modification times in VFS metadata\nexport const utimes = async (\n    _root: FileSystemDirectoryHandle,\n    path: string,\n    atime: number | string | Date,\n    mtime: number | string | Date\n): Promise<void> => {\n    queueEvent('update', path)\n    const normalizedPath = normalizePath(path)\n    if (!existsInVfs(normalizedPath) && !isDirectoryInVfs(normalizedPath)) {\n        throw createENOENT('utimes', path)\n    }\n    utimesInVfs(normalizedPath, toTimestamp(atime), toTimestamp(mtime))\n}\n\n// Sync - sets file access/modification times in VFS metadata\nexport const utimesSync = (\n    path: string,\n    atime: number | string | Date,\n    mtime: number | string | Date\n): void => {\n    queueEvent('update', path)\n    const normalizedPath = normalizePath(path)\n    if (!existsInVfs(normalizedPath) && !isDirectoryInVfs(normalizedPath)) {\n        throw createENOENT('utimes', path)\n    }\n    utimesInVfs(normalizedPath, toTimestamp(atime), toTimestamp(mtime))\n}\n","// lutimes implementation - no-op in OPFS (no symlinks/timestamps)\n\n// Async - no-op\nexport const lutimes = async (\n    _root: FileSystemDirectoryHandle,\n    _path: string,\n    _atime: number | string | Date,\n    _mtime: number | string | Date\n): Promise<void> => {\n    // No-op: OPFS doesn't support setting timestamps or symlinks\n}\n\n// Sync - no-op\nexport const lutimesSync = (\n    _path: string,\n    _atime: number | string | Date,\n    _mtime: number | string | Date\n): void => {\n    // No-op: OPFS doesn't support setting timestamps or symlinks\n}\n","// cp implementation - recursive copy\n\nimport { queueEvent, readFromVfs, writeToVfs, getVfsIndex, getVfsDirIndex, createDirInVfs, normalizePath } from '../fs.vfs'\nimport { createENOENT, FSError } from '../classes'\n\ninterface CpOptions {\n    recursive?: boolean\n    force?: boolean\n}\n\n// Async - copies file or directory recursively in OPFS\nexport const cp = async (\n    root: FileSystemDirectoryHandle,\n    src: string,\n    dest: string,\n    options?: CpOptions\n): Promise<void> => {\n    queueEvent('create', dest)\n    const srcParts = src.split('/').filter(p => p.length > 0)\n    const destParts = dest.split('/').filter(p => p.length > 0)\n    \n    // Navigate to source parent\n    let srcDir = root\n    for (let i = 0; i < srcParts.length - 1; i++) {\n        srcDir = await srcDir.getDirectoryHandle(srcParts[i])\n    }\n    \n    const srcName = srcParts[srcParts.length - 1]\n    \n    // Check if source is a file or directory\n    let isDir = false\n    try {\n        await srcDir.getDirectoryHandle(srcName)\n        isDir = true\n    } catch {\n        // It's a file\n    }\n    \n    if (isDir && !options?.recursive) {\n        throw new FSError('EISDIR', 'cp', src)\n    }\n    \n    // Navigate/create destination parent\n    let destDir = root\n    for (let i = 0; i < destParts.length - 1; i++) {\n        destDir = await destDir.getDirectoryHandle(destParts[i], { create: true })\n    }\n    \n    const destName = destParts[destParts.length - 1]\n    \n    if (isDir) {\n        await copyDirRecursive(srcDir, srcName, destDir, destName)\n    } else {\n        await copyFile(srcDir, srcName, destDir, destName)\n    }\n}\n\nasync function copyFile(\n    srcDir: FileSystemDirectoryHandle,\n    srcName: string,\n    destDir: FileSystemDirectoryHandle,\n    destName: string\n): Promise<void> {\n    const srcHandle = await srcDir.getFileHandle(srcName)\n    const file = await srcHandle.getFile()\n    const content = new Uint8Array(await file.arrayBuffer())\n    \n    const destHandle = await destDir.getFileHandle(destName, { create: true })\n    const writable = await destHandle.createWritable()\n    await writable.write(content)\n    await writable.close()\n}\n\nasync function copyDirRecursive(\n    srcParent: FileSystemDirectoryHandle,\n    srcName: string,\n    destParent: FileSystemDirectoryHandle,\n    destName: string\n): Promise<void> {\n    const srcDir = await srcParent.getDirectoryHandle(srcName)\n    const destDir = await destParent.getDirectoryHandle(destName, { create: true })\n    \n    for await (const [name, handle] of (srcDir as any).entries()) {\n        if (handle.kind === 'file') {\n            await copyFile(srcDir, name, destDir, name)\n        } else {\n            await copyDirRecursive(srcDir, name, destDir, name)\n        }\n    }\n}\n\n// Sync - copies file or directory in VFS\nexport const cpSync = (\n    src: string,\n    dest: string,\n    options?: CpOptions\n): void => {\n    queueEvent('create', dest)\n    const normalizedSrc = normalizePath(src)\n    const normalizedDest = normalizePath(dest)\n    \n    const vfsIndex = getVfsIndex()\n    const vfsDirIndex = getVfsDirIndex()\n    \n    // Check if src is a file\n    const srcContent = readFromVfs(normalizedSrc)\n    if (srcContent !== null) {\n        // It's a file - just copy it\n        writeToVfs(normalizedDest, srcContent)\n        return\n    }\n    \n    // Check if src is a directory\n    const srcPrefix = normalizedSrc + '/'\n    const isDir = vfsDirIndex.has(normalizedSrc) ||\n        Array.from(vfsIndex.keys()).some(p => p.startsWith(srcPrefix))\n    \n    if (!isDir) {\n        throw createENOENT('cp', src)\n    }\n    \n    if (!options?.recursive) {\n        throw new FSError('EISDIR', 'cp', src)\n    }\n    \n    // Copy directory recursively\n    createDirInVfs(normalizedDest)\n    \n    // Copy all files under src to dest\n    for (const [path, _] of vfsIndex) {\n        if (path.startsWith(srcPrefix)) {\n            const relativePath = path.substring(srcPrefix.length)\n            const destPath = normalizedDest + '/' + relativePath\n            queueEvent('create', destPath)\n            const content = readFromVfs(path)\n            if (content) {\n                writeToVfs(destPath, content)\n            }\n        }\n    }\n\n    // Copy all subdirectories\n    for (const dirPath of vfsDirIndex) {\n        if (dirPath.startsWith(srcPrefix)) {\n            const relativePath = dirPath.substring(srcPrefix.length)\n            const newDirPath = normalizedDest + '/' + relativePath\n            queueEvent('create', newDirPath)\n            createDirInVfs(newDirPath)\n        }\n    }\n}\n","// opendir implementation using OPFS\n\nimport { getVfsIndex, getVfsDirIndex, normalizePath } from '../fs.vfs'\nimport type { Dirent } from '../types'\n\ninterface Dir {\n    path: string\n    read(): Promise<Dirent | null>\n    readSync(): Dirent | null\n    close(): Promise<void>\n    closeSync(): void\n    [Symbol.asyncIterator](): AsyncIterableIterator<Dirent>\n}\n\n// Async - opens directory for iteration in OPFS\nexport const opendir = async (\n    root: FileSystemDirectoryHandle,\n    path: string\n): Promise<Dir> => {\n    const parts = path.split('/').filter(p => p.length > 0)\n    \n    let currentDir = root\n    for (const part of parts) {\n        currentDir = await currentDir.getDirectoryHandle(part)\n    }\n    \n    const entries: Dirent[] = []\n    for await (const [name, handle] of (currentDir as any).entries()) {\n        const isDir = handle.kind === 'directory'\n        entries.push({\n            name,\n            isFile: () => !isDir,\n            isDirectory: () => isDir,\n            isSymbolicLink: () => false,\n            isBlockDevice: () => false,\n            isCharacterDevice: () => false,\n            isFIFO: () => false,\n            isSocket: () => false,\n        })\n    }\n    \n    let index = 0\n    \n    return {\n        path,\n        async read(): Promise<Dirent | null> {\n            if (index >= entries.length) return null\n            return entries[index++]\n        },\n        readSync(): Dirent | null {\n            if (index >= entries.length) return null\n            return entries[index++]\n        },\n        async close(): Promise<void> {\n            index = entries.length\n        },\n        closeSync(): void {\n            index = entries.length\n        },\n        async *[Symbol.asyncIterator](): AsyncIterableIterator<Dirent> {\n            for (const entry of entries) {\n                yield entry\n            }\n        },\n    }\n}\n\n// Sync - opens directory for iteration in VFS\nexport const opendirSync = (\n    path: string\n): Dir => {\n    const normalizedPath = normalizePath(path)\n    const vfsIndex = getVfsIndex()\n    const vfsDirIndex = getVfsDirIndex()\n    \n    const prefix = normalizedPath ? normalizedPath + '/' : ''\n    const seen = new Set<string>()\n    const entries: Dirent[] = []\n    \n    // Scan for files\n    for (const filePath of vfsIndex.keys()) {\n        if (normalizedPath === '' || filePath.startsWith(prefix)) {\n            const relativePath = normalizedPath === '' ? filePath : filePath.substring(prefix.length)\n            const firstPart = relativePath.split('/')[0]\n            if (!seen.has(firstPart)) {\n                seen.add(firstPart)\n                const isDir = relativePath.includes('/')\n                entries.push({\n                    name: firstPart,\n                    isFile: () => !isDir,\n                    isDirectory: () => isDir,\n                    isSymbolicLink: () => false,\n                    isBlockDevice: () => false,\n                    isCharacterDevice: () => false,\n                    isFIFO: () => false,\n                    isSocket: () => false,\n                })\n            }\n        }\n    }\n    \n    // Scan for directories\n    for (const dirPath of vfsDirIndex) {\n        if (normalizedPath === '' || dirPath.startsWith(prefix)) {\n            const relativePath = normalizedPath === '' ? dirPath : dirPath.substring(prefix.length)\n            const firstPart = relativePath.split('/')[0]\n            if (!seen.has(firstPart)) {\n                seen.add(firstPart)\n                entries.push({\n                    name: firstPart,\n                    isFile: () => false,\n                    isDirectory: () => true,\n                    isSymbolicLink: () => false,\n                    isBlockDevice: () => false,\n                    isCharacterDevice: () => false,\n                    isFIFO: () => false,\n                    isSocket: () => false,\n                })\n            }\n        }\n    }\n    \n    let index = 0\n    \n    return {\n        path,\n        async read(): Promise<Dirent | null> {\n            if (index >= entries.length) return null\n            return entries[index++]\n        },\n        readSync(): Dirent | null {\n            if (index >= entries.length) return null\n            return entries[index++]\n        },\n        async close(): Promise<void> {\n            index = entries.length\n        },\n        closeSync(): void {\n            index = entries.length\n        },\n        async *[Symbol.asyncIterator](): AsyncIterableIterator<Dirent> {\n            for (const entry of entries) {\n                yield entry\n            }\n        },\n    }\n}\n","// statfs implementation - returns filesystem stats\n\ninterface StatFs {\n    type: number\n    bsize: number\n    blocks: number\n    bfree: number\n    bavail: number\n    files: number\n    ffree: number\n}\n\n// Async - returns approximate OPFS stats\nexport const statfs = async (\n    _root: FileSystemDirectoryHandle,\n    _path: string\n): Promise<StatFs> => {\n    // Try to get storage estimate if available\n    let total = 1024 * 1024 * 1024 // Default 1GB\n    let used = 0\n    \n    if (navigator.storage && navigator.storage.estimate) {\n        try {\n            const estimate = await navigator.storage.estimate()\n            total = estimate.quota || total\n            used = estimate.usage || 0\n        } catch {\n            // Ignore errors\n        }\n    }\n    \n    const blockSize = 4096\n    const totalBlocks = Math.floor(total / blockSize)\n    const usedBlocks = Math.floor(used / blockSize)\n    const freeBlocks = totalBlocks - usedBlocks\n    \n    return {\n        type: 0x4F504653, // \"OPFS\" in hex\n        bsize: blockSize,\n        blocks: totalBlocks,\n        bfree: freeBlocks,\n        bavail: freeBlocks,\n        files: 1000000,\n        ffree: 999999,\n    }\n}\n\n// Sync - returns placeholder stats (can't async estimate in sync)\nexport const statfsSync = (\n    _path: string\n): StatFs => {\n    const blockSize = 4096\n    const total = 1024 * 1024 * 1024 // 1GB placeholder\n    const totalBlocks = Math.floor(total / blockSize)\n    \n    return {\n        type: 0x4F504653, // \"OPFS\" in hex\n        bsize: blockSize,\n        blocks: totalBlocks,\n        bfree: totalBlocks,\n        bavail: totalBlocks,\n        files: 1000000,\n        ffree: 999999,\n    }\n}\n","// open implementation using OPFS with file descriptor emulation\n\nimport { readFromVfs, writeToVfs, existsInVfs, normalizePath, queueEvent } from '../fs.vfs'\nimport { createENOENT } from '../classes'\n\n// File descriptor table (shared across sync/async)\ninterface FdEntry {\n    path: string\n    flags: string\n    position: number\n    // For async: store the handle\n    handle?: FileSystemFileHandle\n    // For sync: store cached content\n    content?: Uint8Array\n}\n\nconst fdTable = new Map<number, FdEntry>()\nlet nextFd = 3 // 0, 1, 2 are stdin/stdout/stderr\n\n// Exported for other fd-based methods\nexport const getFdEntry = (fd: number): FdEntry | undefined => fdTable.get(fd)\nexport const setFdPosition = (fd: number, position: number) => {\n    const entry = fdTable.get(fd)\n    if (entry) entry.position = position\n}\nexport const closeFd = (fd: number) => fdTable.delete(fd)\n\n// Parse flags string to determine access mode\nconst parseFlags = (flags: string): { read: boolean; write: boolean; append: boolean; create: boolean; truncate: boolean } => {\n    return {\n        read: flags.includes('r') || flags === 'a+' || flags === 'w+',\n        write: flags.includes('w') || flags.includes('a') || flags.includes('+'),\n        append: flags.includes('a'),\n        create: flags.includes('w') || flags.includes('a') || flags.includes('x'),\n        truncate: flags.includes('w'),\n    }\n}\n\n// Async - opens file in OPFS\nexport const open = async (\n    root: FileSystemDirectoryHandle,\n    path: string,\n    flags: string = 'r',\n    _mode?: number\n): Promise<number> => {\n    const parts = path.split('/').filter(p => p.length > 0)\n    const parsedFlags = parseFlags(flags)\n    \n    let currentDir = root\n    for (let i = 0; i < parts.length - 1; i++) {\n        try {\n            currentDir = await currentDir.getDirectoryHandle(parts[i])\n        } catch {\n            if (parsedFlags.create) {\n                currentDir = await currentDir.getDirectoryHandle(parts[i], { create: true })\n            } else {\n                throw createENOENT('open', path)\n            }\n        }\n    }\n    \n    const fileName = parts[parts.length - 1]\n    let handle: FileSystemFileHandle\n    \n    try {\n        handle = await currentDir.getFileHandle(fileName, { create: parsedFlags.create })\n    } catch {\n        throw createENOENT('open', path)\n    }\n    \n    // Truncate if needed\n    if (parsedFlags.truncate) {\n        const writable = await handle.createWritable()\n        await writable.truncate(0)\n        await writable.close()\n    }\n    \n    const fd = nextFd++\n    const file = await handle.getFile()\n    \n    fdTable.set(fd, {\n        path,\n        flags,\n        position: parsedFlags.append ? file.size : 0,\n        handle,\n    })\n    \n    return fd\n}\n\n// Sync - opens file in VFS\nexport const openSync = (\n    path: string,\n    flags: string = 'r',\n    _mode?: number\n): number => {\n    const normalizedPath = normalizePath(path)\n    const parsedFlags = parseFlags(flags)\n    \n    let content = readFromVfs(normalizedPath)\n    \n    if (content === null && !parsedFlags.create) {\n        throw createENOENT('open', path)\n    }\n    \n    if (content === null || parsedFlags.truncate) {\n        const isNewFile = content === null\n        content = new Uint8Array(0)\n        if (parsedFlags.create || parsedFlags.truncate) {\n            // Queue create for new files, update for truncate of existing files\n            queueEvent(isNewFile ? 'create' : 'update', normalizedPath)\n            writeToVfs(normalizedPath, content)\n        }\n    }\n    \n    const fd = nextFd++\n    fdTable.set(fd, {\n        path: normalizedPath,\n        flags,\n        position: parsedFlags.append ? content.length : 0,\n        content,\n    })\n    \n    return fd\n}\n","// close implementation\n\nimport { closeFd, getFdEntry } from './open'\n\n// Async - closes file descriptor\nexport const close = async (\n    fd: number\n): Promise<void> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, close`)\n    }\n    closeFd(fd)\n}\n\n// Sync - closes file descriptor\nexport const closeSync = (\n    fd: number\n): void => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, close`)\n    }\n    closeFd(fd)\n}\n","// read implementation using file descriptors\n\nimport { getFdEntry, setFdPosition } from './open'\nimport { readFromVfs } from '../fs.vfs'\n\n// Async - reads from file descriptor\nexport const read = async (\n    fd: number,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number | null\n): Promise<number> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, read`)\n    }\n    \n    if (!entry.handle) {\n        throw new Error(`EBADF: file descriptor not opened for async operations`)\n    }\n    \n    const file = await entry.handle.getFile()\n    const fileContent = new Uint8Array(await file.arrayBuffer())\n    \n    const readPosition = position !== null ? position : entry.position\n    const bytesToRead = Math.min(length, fileContent.length - readPosition)\n    \n    if (bytesToRead <= 0) return 0\n    \n    buffer.set(fileContent.subarray(readPosition, readPosition + bytesToRead), offset)\n    \n    if (position === null) {\n        setFdPosition(fd, entry.position + bytesToRead)\n    }\n    \n    return bytesToRead\n}\n\n// Sync - reads from file descriptor in VFS\n// Supports multiple signatures:\n//   readSync(fd, buffer, offset, length, position)\n//   readSync(fd, buffer, options?)  where options = { offset?, length?, position? }\n//   readSync(fd, buffer)\nexport const readSync = (\n    fd: number,\n    buffer: Uint8Array,\n    offsetOrOptions?: number | { offset?: number; length?: number; position?: number | null },\n    length?: number,\n    position?: number | null\n): number => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, read`)\n    }\n\n    // Parse arguments based on signature\n    let actualOffset: number\n    let actualLength: number\n    let actualPosition: number | null\n\n    if (typeof offsetOrOptions === 'object' && offsetOrOptions !== null) {\n        // Options object signature\n        actualOffset = offsetOrOptions.offset ?? 0\n        actualLength = offsetOrOptions.length ?? buffer.length - actualOffset\n        actualPosition = offsetOrOptions.position ?? null\n    } else {\n        // Positional arguments signature\n        actualOffset = offsetOrOptions ?? 0\n        actualLength = length ?? buffer.length - actualOffset\n        actualPosition = position ?? null\n    }\n\n    // Re-read content for sync (may have changed)\n    const content = entry.content || readFromVfs(entry.path)\n    if (!content) {\n        throw new Error(`EBADF: file content not available`)\n    }\n\n    const readPosition = actualPosition !== null ? actualPosition : entry.position\n    const bytesToRead = Math.min(actualLength, content.length - readPosition)\n\n    if (bytesToRead <= 0) return 0\n\n    buffer.set(content.subarray(readPosition, readPosition + bytesToRead), actualOffset)\n\n    if (actualPosition === null) {\n        setFdPosition(fd, entry.position + bytesToRead)\n    }\n\n    return bytesToRead\n}\n","// write implementation using file descriptors\n\nimport { getFdEntry, setFdPosition } from './open'\nimport { queueEvent, readFromVfs, writeToVfs } from '../fs.vfs'\n\n// Async - writes to file descriptor\nexport const write = async (\n    fd: number,\n    buffer: Uint8Array,\n    offset: number,\n    length: number,\n    position: number | null\n): Promise<number> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, write`)\n    }\n\n    queueEvent('update', entry.path)\n\n    if (!entry.handle) {\n        throw new Error(`EBADF: file descriptor not opened for async operations`)\n    }\n\n    const file = await entry.handle.getFile()\n    const fileContent = new Uint8Array(await file.arrayBuffer())\n    \n    const writePosition = position !== null ? position : entry.position\n    const dataToWrite = buffer.subarray(offset, offset + length)\n    \n    // Calculate new file size\n    const newSize = Math.max(fileContent.length, writePosition + length)\n    const newContent = new Uint8Array(newSize)\n    newContent.set(fileContent)\n    newContent.set(dataToWrite, writePosition)\n    \n    const writable = await entry.handle.createWritable()\n    await writable.write(newContent)\n    await writable.close()\n    \n    if (position === null) {\n        setFdPosition(fd, entry.position + length)\n    }\n    \n    return length\n}\n\n// Sync - writes to file descriptor in VFS\n// Supports multiple signatures:\n//   writeSync(fd, buffer)\n//   writeSync(fd, buffer, offset)\n//   writeSync(fd, buffer, offset, length)\n//   writeSync(fd, buffer, offset, length, position)\n//   writeSync(fd, buffer, options) where options = { offset?, length?, position? }\n//   writeSync(fd, string)\n//   writeSync(fd, string, position)\n//   writeSync(fd, string, position, encoding)\nexport const writeSync = (\n    fd: number,\n    bufferOrString: Uint8Array | string,\n    offsetOrPositionOrOptions?: number | { offset?: number; length?: number; position?: number | null },\n    lengthOrEncoding?: number | string,\n    position?: number | null\n): number => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, write`)\n    }\n\n    queueEvent('update', entry.path)\n\n    let dataToWrite: Uint8Array\n    let writePosition: number\n\n    if (typeof bufferOrString === 'string') {\n        // String signature: writeSync(fd, string, position?, encoding?)\n        // Note: TextEncoder only supports UTF-8, other encodings are ignored\n        dataToWrite = new TextEncoder().encode(bufferOrString)\n        writePosition = typeof offsetOrPositionOrOptions === 'number' ? offsetOrPositionOrOptions : entry.position\n    } else if (typeof offsetOrPositionOrOptions === 'object' && offsetOrPositionOrOptions !== null) {\n        // Options object signature: writeSync(fd, buffer, options)\n        const opts = offsetOrPositionOrOptions\n        const offset = opts.offset ?? 0\n        const length = opts.length ?? bufferOrString.length - offset\n        dataToWrite = bufferOrString.subarray(offset, offset + length)\n        writePosition = opts.position ?? entry.position\n    } else {\n        // Positional arguments signature: writeSync(fd, buffer, offset?, length?, position?)\n        const offset = offsetOrPositionOrOptions ?? 0\n        const length = typeof lengthOrEncoding === 'number' ? lengthOrEncoding : bufferOrString.length - offset\n        dataToWrite = bufferOrString.subarray(offset, offset + length)\n        writePosition = position ?? entry.position\n    }\n\n    const content = entry.content || readFromVfs(entry.path) || new Uint8Array(0)\n\n    // Calculate new file size\n    const newSize = Math.max(content.length, writePosition + dataToWrite.length)\n    const newContent = new Uint8Array(newSize)\n    newContent.set(content)\n    newContent.set(dataToWrite, writePosition)\n\n    writeToVfs(entry.path, newContent)\n    entry.content = newContent\n\n    setFdPosition(fd, writePosition + dataToWrite.length)\n\n    return dataToWrite.length\n}\n","// fstat implementation using file descriptors\n\nimport { getFdEntry } from './open'\nimport { readFromVfs, isDirectoryInVfs } from '../fs.vfs'\nimport type { Stats } from '../types'\nimport { createENOENT, createEBADF } from '../classes'\n\nconst createStats = (size: number, isDir: boolean): Stats => {\n    const now = new Date()\n    return {\n        isFile: () => !isDir,\n        isDirectory: () => isDir,\n        isSymbolicLink: () => false,\n        isBlockDevice: () => false,\n        isCharacterDevice: () => false,\n        isFIFO: () => false,\n        isSocket: () => false,\n        dev: 0,\n        ino: 0,\n        mode: isDir ? 16877 : 33188,\n        nlink: 1,\n        uid: 0,\n        gid: 0,\n        rdev: 0,\n        size,\n        blksize: 4096,\n        blocks: Math.ceil(size / 512),\n        atimeMs: now.getTime(),\n        mtimeMs: now.getTime(),\n        ctimeMs: now.getTime(),\n        birthtimeMs: now.getTime(),\n        atime: now,\n        mtime: now,\n        ctime: now,\n        birthtime: now,\n    }\n}\n\n// Async - gets file stats from file descriptor\nexport const fstat = async (\n    fd: number\n): Promise<Stats> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw createEBADF('fstat')\n    }\n    \n    if (!entry.handle) {\n        throw new Error(`EBADF: file descriptor not opened for async operations`)\n    }\n    \n    const file = await entry.handle.getFile()\n    return createStats(file.size, false)\n}\n\n// Sync - gets file stats from file descriptor in VFS\nexport const fstatSync = (\n    fd: number\n): Stats => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw createEBADF('fstat')\n    }\n    \n    const content = entry.content || readFromVfs(entry.path)\n    if (!content && !isDirectoryInVfs(entry.path)) {\n        throw createENOENT('fstat', entry.path)\n    }\n    \n    return createStats(content?.length || 0, isDirectoryInVfs(entry.path))\n}\n","// fsync implementation - flushes file data to storage\n\nimport { getFdEntry } from './open'\n\n// Async - no-op for OPFS (writes are already sync to storage)\nexport const fsync = async (\n    fd: number\n): Promise<void> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, fsync`)\n    }\n    // OPFS writes are already persisted\n}\n\n// Sync - no-op\nexport const fsyncSync = (\n    fd: number\n): void => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, fsync`)\n    }\n    // VFS writes are immediately persisted\n}\n","// fdatasync implementation - same as fsync for OPFS\n\nimport { getFdEntry } from './open'\n\n// Async - no-op for OPFS\nexport const fdatasync = async (\n    fd: number\n): Promise<void> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, fdatasync`)\n    }\n}\n\n// Sync - no-op\nexport const fdatasyncSync = (\n    fd: number\n): void => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, fdatasync`)\n    }\n}\n","// ftruncate implementation using file descriptors\n\nimport { getFdEntry } from './open'\nimport { queueEvent, readFromVfs, writeToVfs } from '../fs.vfs'\n\n// Async - truncates file via file descriptor\nexport const ftruncate = async (\n    fd: number,\n    len: number = 0\n): Promise<void> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, ftruncate`)\n    }\n\n    queueEvent('update', entry.path)\n\n    if (!entry.handle) {\n        throw new Error(`EBADF: file descriptor not opened for async operations`)\n    }\n\n    const file = await entry.handle.getFile()\n    const content = new Uint8Array(await file.arrayBuffer())\n    \n    let newContent: Uint8Array\n    if (len === 0) {\n        newContent = new Uint8Array(0)\n    } else if (len < content.length) {\n        newContent = content.slice(0, len)\n    } else {\n        newContent = new Uint8Array(len)\n        newContent.set(content)\n    }\n    \n    const writable = await entry.handle.createWritable()\n    // Create a copy backed by ArrayBuffer (not SharedArrayBuffer) for FileSystemWritableFileStream\n    await writable.write(new Uint8Array(newContent).buffer as ArrayBuffer)\n    await writable.close()\n}\n\n// Sync - truncates file in VFS via file descriptor\nexport const ftruncateSync = (\n    fd: number,\n    len: number = 0\n): void => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, ftruncate`)\n    }\n\n    queueEvent('update', entry.path)\n\n    const content = entry.content || readFromVfs(entry.path) || new Uint8Array(0)\n    \n    let newContent: Uint8Array\n    if (len === 0) {\n        newContent = new Uint8Array(0)\n    } else if (len < content.length) {\n        newContent = content.slice(0, len)\n    } else {\n        newContent = new Uint8Array(len)\n        newContent.set(content)\n    }\n    \n    writeToVfs(entry.path, newContent)\n    entry.content = newContent\n}\n","// fchmod implementation - no-op in OPFS (no permissions)\n\n// Async - no-op\nexport const fchmod = async (\n    _fd: number,\n    _mode: number\n): Promise<void> => {\n    // No-op: OPFS doesn't have a permission system\n}\n\n// Sync - no-op\nexport const fchmodSync = (\n    _fd: number,\n    _mode: number\n): void => {\n    // No-op: OPFS doesn't have a permission system\n}\n","// fchown implementation - no-op in OPFS (no ownership)\n\n// Async - no-op\nexport const fchown = async (\n    _fd: number,\n    _uid: number,\n    _gid: number\n): Promise<void> => {\n    // No-op: OPFS doesn't have an ownership system\n}\n\n// Sync - no-op\nexport const fchownSync = (\n    _fd: number,\n    _uid: number,\n    _gid: number\n): void => {\n    // No-op: OPFS doesn't have an ownership system\n}\n","// futimes implementation - no-op in OPFS (timestamps not controllable)\n\n// Async - no-op\nexport const futimes = async (\n    _fd: number,\n    _atime: number | string | Date,\n    _mtime: number | string | Date\n): Promise<void> => {\n    // No-op: OPFS doesn't support setting timestamps\n}\n\n// Sync - no-op\nexport const futimesSync = (\n    _fd: number,\n    _atime: number | string | Date,\n    _mtime: number | string | Date\n): void => {\n    // No-op: OPFS doesn't support setting timestamps\n}\n","// readv implementation - scatter read using file descriptors\n\nimport { getFdEntry, setFdPosition } from './open'\nimport { readFromVfs } from '../fs.vfs'\n\n// Async - reads into multiple buffers\nexport const readv = async (\n    fd: number,\n    buffers: Uint8Array[],\n    position?: number | null\n): Promise<number> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, readv`)\n    }\n    \n    if (!entry.handle) {\n        throw new Error(`EBADF: file descriptor not opened for async operations`)\n    }\n    \n    const file = await entry.handle.getFile()\n    const fileContent = new Uint8Array(await file.arrayBuffer())\n    \n    let readPosition = position !== null && position !== undefined ? position : entry.position\n    let totalRead = 0\n    \n    for (const buffer of buffers) {\n        const bytesToRead = Math.min(buffer.length, fileContent.length - readPosition)\n        if (bytesToRead <= 0) break\n        \n        buffer.set(fileContent.subarray(readPosition, readPosition + bytesToRead))\n        readPosition += bytesToRead\n        totalRead += bytesToRead\n    }\n    \n    if (position === null || position === undefined) {\n        setFdPosition(fd, entry.position + totalRead)\n    }\n    \n    return totalRead\n}\n\n// Sync - reads into multiple buffers from VFS\nexport const readvSync = (\n    fd: number,\n    buffers: Uint8Array[],\n    position?: number | null\n): number => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, readv`)\n    }\n    \n    const content = entry.content || readFromVfs(entry.path)\n    if (!content) {\n        throw new Error(`EBADF: file content not available`)\n    }\n    \n    let readPosition = position !== null && position !== undefined ? position : entry.position\n    let totalRead = 0\n    \n    for (const buffer of buffers) {\n        const bytesToRead = Math.min(buffer.length, content.length - readPosition)\n        if (bytesToRead <= 0) break\n        \n        buffer.set(content.subarray(readPosition, readPosition + bytesToRead))\n        readPosition += bytesToRead\n        totalRead += bytesToRead\n    }\n    \n    if (position === null || position === undefined) {\n        setFdPosition(fd, entry.position + totalRead)\n    }\n    \n    return totalRead\n}\n","// writev implementation - gather write using file descriptors\n\nimport { getFdEntry, setFdPosition } from './open'\nimport { queueEvent, readFromVfs, writeToVfs } from '../fs.vfs'\n\n// Async - writes from multiple buffers\nexport const writev = async (\n    fd: number,\n    buffers: Uint8Array[],\n    position?: number | null\n): Promise<number> => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, writev`)\n    }\n\n    queueEvent('update', entry.path)\n\n    if (!entry.handle) {\n        throw new Error(`EBADF: file descriptor not opened for async operations`)\n    }\n\n    const file = await entry.handle.getFile()\n    const fileContent = new Uint8Array(await file.arrayBuffer())\n    \n    // Calculate total bytes to write\n    let totalLength = 0\n    for (const buffer of buffers) {\n        totalLength += buffer.length\n    }\n    \n    const writePosition = position !== null && position !== undefined ? position : entry.position\n    const newSize = Math.max(fileContent.length, writePosition + totalLength)\n    const newContent = new Uint8Array(newSize)\n    newContent.set(fileContent)\n    \n    let currentPosition = writePosition\n    for (const buffer of buffers) {\n        newContent.set(buffer, currentPosition)\n        currentPosition += buffer.length\n    }\n    \n    const writable = await entry.handle.createWritable()\n    await writable.write(newContent)\n    await writable.close()\n    \n    if (position === null || position === undefined) {\n        setFdPosition(fd, entry.position + totalLength)\n    }\n    \n    return totalLength\n}\n\n// Sync - writes from multiple buffers to VFS\nexport const writevSync = (\n    fd: number,\n    buffers: Uint8Array[],\n    position?: number | null\n): number => {\n    const entry = getFdEntry(fd)\n    if (!entry) {\n        throw new Error(`EBADF: bad file descriptor, writev`)\n    }\n\n    queueEvent('update', entry.path)\n\n    const content = entry.content || readFromVfs(entry.path) || new Uint8Array(0)\n    \n    let totalLength = 0\n    for (const buffer of buffers) {\n        totalLength += buffer.length\n    }\n    \n    const writePosition = position !== null && position !== undefined ? position : entry.position\n    const newSize = Math.max(content.length, writePosition + totalLength)\n    const newContent = new Uint8Array(newSize)\n    newContent.set(content)\n    \n    let currentPosition = writePosition\n    for (const buffer of buffers) {\n        newContent.set(buffer, currentPosition)\n        currentPosition += buffer.length\n    }\n    \n    writeToVfs(entry.path, newContent)\n    entry.content = newContent\n    \n    if (position === null || position === undefined) {\n        setFdPosition(fd, entry.position + totalLength)\n    }\n    \n    return totalLength\n}\n","/**\n * FS Sync Worker - Fire-and-Forget Queue\n * Handles queued async operations that don't need responses\n */\n\nimport { enterFireAndForgetMode, exitFireAndForgetMode } from './fs.vfs'\nimport { syncMethods } from './fs.sync.methods'\n\n// Fire-and-forget queue configuration\nexport const MAX_ASYNC_QUEUE_SIZE = 1000 // Maximum pending fire-and-forget operations\n\n// Fire-and-forget queue metrics\nexport const asyncQueueMetrics = {\n  totalQueued: 0,\n  totalProcessed: 0,\n  totalDropped: 0,\n  peakQueueSize: 0,\n}\n\n// Queue for fire-and-forget requests (via postMessage)\nexport const asyncQueue: Array<{ method: string; args: unknown[] }> = []\n\n// Process queued fire-and-forget requests\nexport const processAsyncQueue = () => {\n  while (asyncQueue.length > 0) {\n    const { method, args } = asyncQueue.shift()!\n    try {\n      const fn = syncMethods[method]\n      if (fn) {\n        // Enter fire-and-forget mode so VFS writes don't trigger OPFS sync\n        // (OPFS already has the data from the async method that triggered this)\n        // Using counter-based enter/exit handles nested operations correctly\n        enterFireAndForgetMode()\n        try {\n          fn(...args)\n        } finally {\n          exitFireAndForgetMode()\n        }\n      }\n      asyncQueueMetrics.totalProcessed++\n    } catch (err) {\n      console.error('[SyncWorker] Fire-and-forget error:', err)\n      asyncQueueMetrics.totalProcessed++ // Still count as processed even on error\n    }\n  }\n}\n\n// Add item to the queue with overflow protection\nexport const enqueueFireAndForget = (method: string, args: unknown[]) => {\n  // Enforce queue size limit - drop oldest if over limit\n  if (asyncQueue.length >= MAX_ASYNC_QUEUE_SIZE) {\n    const dropped = asyncQueue.shift()\n    asyncQueueMetrics.totalDropped++\n    console.warn(`[SyncWorker] Fire-and-forget queue overflow, dropped oldest: ${dropped?.method}`)\n  }\n  asyncQueue.push({ method, args })\n  asyncQueueMetrics.totalQueued++\n  if (asyncQueue.length > asyncQueueMetrics.peakQueueSize) {\n    asyncQueueMetrics.peakQueueSize = asyncQueue.length\n  }\n}\n","/**\n * FS SAB Utilities - SharedArrayBuffer encoding/decoding\n */\n\nimport {\n    SAB_SIZES,\n    SAB_OFFSETS,\n    SAB_STATUS,\n    SAB_TYPE,\n    LOCKS,\n} from './app-constants'\n\n// Re-export from centralized constants for backwards compatibility\n// Cast to number to avoid literal type issues with `as const`\nexport const SYNC_STATUS_OFFSET: number = SAB_OFFSETS.STATUS\nexport const SYNC_LENGTH_OFFSET: number = SAB_OFFSETS.LENGTH\nexport const SYNC_TYPE_OFFSET: number = SAB_OFFSETS.TYPE\nexport const SYNC_DATA_OFFSET: number = SAB_OFFSETS.DATA_FS\n\nexport const STATUS_IDLE: number = SAB_STATUS.IDLE\nexport const STATUS_REQUEST: number = SAB_STATUS.REQUEST\nexport const STATUS_RESPONSE: number = SAB_STATUS.RESPONSE\nexport const STATUS_ERROR: number = SAB_STATUS.ERROR\n\nexport const REQUEST_TYPE_JSON: number = SAB_TYPE.REQUEST_JSON\nexport const REQUEST_TYPE_BINARY_ARG: number = SAB_TYPE.REQUEST_BINARY_ARG\nexport const RESPONSE_TYPE_JSON: number = SAB_TYPE.RESPONSE_JSON\nexport const RESPONSE_TYPE_BINARY: number = SAB_TYPE.RESPONSE_BINARY\n\nexport const SYNC_SAB_SIZE: number = SAB_SIZES.FS_SYNC\nexport const EVENTS_SAB_SIZE: number = SAB_SIZES.FS_EVENTS\nexport const FS_LOCK_OFFSET: number = SAB_OFFSETS.FS_LOCK\n\nexport const FS_PRIMARY_LOCK: string = LOCKS.FS_PRIMARY\n\nconst syncEncoder = new TextEncoder()\n\n/**\n * Acquire exclusive lock on the FS SAB.\n * Uses compare-and-swap (CAS) spinlock at FS_LOCK_OFFSET.\n * This prevents race conditions when both the exec worker and\n * primary tab use the same SAB for sync FS operations.\n *\n * @param isWorkerThread - true if running in a Worker (can use Atomics.wait),\n *                         false for main thread (must busy-wait)\n */\nexport function acquireSabLock(sab: SharedArrayBuffer, isWorkerThread: boolean): void {\n    const lockArray = new Int32Array(sab, FS_LOCK_OFFSET, 1)\n    while (true) {\n        // Try to set lock from 0 (unlocked) to 1 (locked)\n        if (Atomics.compareExchange(lockArray, 0, 0, 1) === 0) {\n            return // Lock acquired\n        }\n        // Lock is held by another thread - wait\n        if (isWorkerThread) {\n            Atomics.wait(lockArray, 0, 1, 5) // sleep up to 5ms\n        }\n        // Main thread: just spin (can't use Atomics.wait)\n    }\n}\n\n/**\n * Release the FS SAB lock.\n */\nexport function releaseSabLock(sab: SharedArrayBuffer): void {\n    const lockArray = new Int32Array(sab, FS_LOCK_OFFSET, 1)\n    Atomics.store(lockArray, 0, 0) // Unlock\n    Atomics.notify(lockArray, 0, 1) // Wake one waiting thread\n}\n\n/**\n * Write a sync request to the SAB with binary encoding for Buffer args\n */\nexport function writeSyncRequest(sab: SharedArrayBuffer, method: string, args: unknown[]): void {\n    const typeView = new Uint8Array(sab, SYNC_TYPE_OFFSET, 1)\n    const lengthView = new DataView(sab, SYNC_LENGTH_OFFSET, 4)\n\n    // Check if any arg is a Buffer/Uint8Array\n    let bufferArgIndex = -1\n    let bufferData: Uint8Array | null = null\n    for (let i = 0; i < args.length; i++) {\n        const arg = args[i]\n        if (Buffer.isBuffer(arg)) {\n            bufferArgIndex = i\n            bufferData = new Uint8Array(arg)\n            break\n        }\n        if (arg instanceof Uint8Array) {\n            bufferArgIndex = i\n            bufferData = arg\n            break\n        }\n    }\n\n    if (bufferArgIndex >= 0 && bufferData!) {\n        const processedArgs = args.slice()\n        processedArgs[bufferArgIndex] = null\n        const jsonBytes = syncEncoder.encode(JSON.stringify({ method, args: processedArgs }))\n\n        typeView[0] = REQUEST_TYPE_BINARY_ARG\n        const headerView = new DataView(sab, SYNC_DATA_OFFSET, 5)\n        headerView.setUint32(0, jsonBytes.length)\n        headerView.setUint8(4, bufferArgIndex)\n        new Uint8Array(sab, SYNC_DATA_OFFSET + 5, jsonBytes.length).set(jsonBytes)\n        new Uint8Array(sab, SYNC_DATA_OFFSET + 5 + jsonBytes.length, bufferData.length).set(bufferData)\n        lengthView.setUint32(0, 5 + jsonBytes.length + bufferData.length)\n    } else {\n        const jsonBytes = syncEncoder.encode(JSON.stringify({ method, args }))\n        typeView[0] = REQUEST_TYPE_JSON\n        new Uint8Array(sab, SYNC_DATA_OFFSET, jsonBytes.length).set(jsonBytes)\n        lengthView.setUint32(0, jsonBytes.length)\n    }\n}\n\n/**\n * Read sync response from SAB\n */\nexport function readSyncResponse(sab: SharedArrayBuffer): unknown {\n    const lengthView = new DataView(sab, SYNC_LENGTH_OFFSET, 4)\n    const decoder = new TextDecoder()\n\n    const status = Atomics.load(new Int32Array(sab, SYNC_STATUS_OFFSET, 1), 0)\n    const responseType = new Uint8Array(sab, SYNC_TYPE_OFFSET, 1)[0]\n    const responseLength = lengthView.getUint32(0)\n\n    Atomics.store(new Int32Array(sab, SYNC_STATUS_OFFSET, 1), 0, STATUS_IDLE)\n\n    if (responseType === RESPONSE_TYPE_BINARY) {\n        if (status === STATUS_ERROR) throw new Error('Unexpected binary error response')\n        const binaryData = new Uint8Array(sab, SYNC_DATA_OFFSET, responseLength)\n        return Buffer.from(binaryData.slice())\n    }\n\n    const responseData = new Uint8Array(sab, SYNC_DATA_OFFSET, responseLength).slice()\n    const response = JSON.parse(decoder.decode(responseData))\n\n    if (status === STATUS_ERROR) {\n        const err = new Error(response.error) as any\n        err.code = response.code\n        err.errno = response.errno\n        err.syscall = response.syscall\n        err.path = response.path\n        throw err\n    }\n\n    return response.result\n}\n\n/**\n * Extract transferable objects from a value (ArrayBuffers)\n */\nexport function extractTransferables(value: unknown): Transferable[] {\n    const transferables: Transferable[] = []\n\n    if (value instanceof ArrayBuffer) {\n        transferables.push(value)\n    } else if (value instanceof Uint8Array || value instanceof Int8Array ||\n               value instanceof Uint16Array || value instanceof Int16Array ||\n               value instanceof Uint32Array || value instanceof Int32Array ||\n               value instanceof Float32Array || value instanceof Float64Array) {\n        transferables.push(value.buffer)\n    } else if (Array.isArray(value)) {\n        for (const item of value) {\n            transferables.push(...extractTransferables(item))\n        }\n    } else if (value && typeof value === 'object') {\n        for (const key of Object.keys(value)) {\n            transferables.push(...extractTransferables((value as Record<string, unknown>)[key]))\n        }\n    }\n\n    return transferables\n}\n"],"mappings":"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","names":["__create","__defProp","__getOwnPropDesc","__getOwnPropNames","__getProtoOf","__hasOwnProp","__commonJS","__copyProps","__toESM","ReflectApply","ReflectOwnKeys","NumberIsNaN","EventEmitter","once","pathQueue","vfsFileHandle","vfsSyncHandle","init","init","import_events","import_events","root","root","root","root","root","root","vfsIndex","vfsDirIndex","root","vfsIndex","vfsDirIndex","vfsSymlinkIndex","FILE_EXTENSIONS","createStats","root","vfsIndex","vfsDirIndex","root","vfsIndex","vfsDirIndex","root","writable","root","root","vfsIndex","vfsDirIndex","vfsSymlinkIndex","root","root","vfsIndex","root","root","root","root","copyFile","vfsIndex","vfsDirIndex","root","vfsIndex","vfsDirIndex","createStats","createStats","syncSAB","storageMode","root"]}