<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OPFS Benchmark Suite</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }
    h2 { color: #555; margin-top: 30px; }
    .status { padding: 10px; border-radius: 4px; margin: 10px 0; }
    .status.running { background: #fff3cd; color: #856404; }
    .status.complete { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    th, td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    th { background: #007bff; color: white; font-weight: 600; }
    tr:hover { background: #f8f9fa; }
    .winner { background: #d4edda !important; font-weight: bold; }
    .loser { background: #fff3cd; }

    .bar-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .bar {
      height: 24px;
      background: linear-gradient(90deg, #007bff, #00d4ff);
      border-radius: 4px;
      min-width: 4px;
      transition: width 0.3s ease;
    }
    .bar.lightning { background: linear-gradient(90deg, #ffc107, #ff9800); }
    .bar.tier1 { background: linear-gradient(90deg, #28a745, #20c997); }
    .bar.tier2 { background: linear-gradient(90deg, #007bff, #00d4ff); }

    .legend {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      margin: 10px 5px 10px 0;
    }
    button:hover { background: #0056b3; }
    button:disabled { background: #ccc; cursor: not-allowed; }

    .summary {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .metric {
      display: inline-block;
      margin: 10px 20px 10px 0;
      padding: 10px 15px;
      background: #e9ecef;
      border-radius: 4px;
    }
    .metric-value { font-size: 24px; font-weight: bold; color: #007bff; }
    .metric-label { font-size: 12px; color: #666; }

    #log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 13px;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .log-success { color: #4ec9b0; }
    .log-error { color: #f14c4c; }
    .log-info { color: #569cd6; }
  </style>
</head>
<body>
  <h1>OPFS-FS Benchmark Suite</h1>

  <div class="summary">
    <h3>Environment</h3>
    <div class="metric">
      <div class="metric-value" id="env-isolated">-</div>
      <div class="metric-label">Cross-Origin Isolated</div>
    </div>
    <div class="metric">
      <div class="metric-value" id="env-sab">-</div>
      <div class="metric-label">SharedArrayBuffer</div>
    </div>
    <div class="metric">
      <div class="metric-value" id="env-atomics">-</div>
      <div class="metric-label">Atomics</div>
    </div>
    <div class="metric">
      <div class="metric-value" id="env-opfs">-</div>
      <div class="metric-label">OPFS Available</div>
    </div>
  </div>

  <div>
    <button id="btn-run-all" onclick="runAllBenchmarks()">Run All Benchmarks</button>
    <button id="btn-run-write" onclick="runBenchmark('write')">Write Test</button>
    <button id="btn-run-read" onclick="runBenchmark('read')">Read Test</button>
    <button id="btn-run-large" onclick="runBenchmark('large')">Large File Test</button>
    <button id="btn-run-batch-write" onclick="runBenchmark('batch-write')">Batch Write</button>
    <button id="btn-run-batch-read" onclick="runBenchmark('batch-read')">Batch Read</button>
    <button id="btn-run-git-clone" onclick="runBenchmark('git-clone')" style="background:#6f42c1">Git Clone</button>
    <button id="btn-run-git-status" onclick="runBenchmark('git-status')" style="background:#6f42c1">Git Status</button>
  </div>

  <div id="status" class="status" style="display:none;"></div>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #ffc107, #ff9800);"></div> LightningFS (IndexedDB)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #28a745, #20c997);"></div> OPFS Tier 1 Sync (Worker + Atomics)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #17a2b8, #20c997);"></div> OPFS Tier 1 Promises (Worker + fastCall)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #007bff, #00d4ff);"></div> OPFS Tier 2 (Main Thread Promises)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #6f42c1, #a855f7);"></div> VFS Sync (SAB + Atomics.wait)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #d63384, #e879a8);"></div> VFS Promises (async relay)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #ff4757, #ff6b81);"></div> Future Sync (nodecontainer FS)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #ffa502, #ffbe76);"></div> Future Promises (nodecontainer FS)</div>
  </div>

  <h2>Results</h2>
  <div id="results"></div>

  <h2>Log</h2>
  <div id="log"></div>

  <script type="module">
    // Check environment
    document.getElementById('env-isolated').textContent = crossOriginIsolated ? 'Yes' : 'No';
    document.getElementById('env-sab').textContent = typeof SharedArrayBuffer !== 'undefined' ? 'Yes' : 'No';
    document.getElementById('env-atomics').textContent = typeof Atomics !== 'undefined' ? 'Yes' : 'No';
    document.getElementById('env-opfs').textContent = 'storage' in navigator ? 'Yes' : 'No';

    const log = (msg, type = '') => {
      const el = document.getElementById('log');
      const span = document.createElement('span');
      span.className = type ? `log-${type}` : '';
      span.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      el.appendChild(span);
      el.scrollTop = el.scrollHeight;
    };

    const setStatus = (msg, type) => {
      const el = document.getElementById('status');
      el.style.display = 'block';
      el.className = `status ${type}`;
      el.textContent = msg;
    };

    // Import libraries
    let fs, fsTier2, LightningFS, git, http;
    let tier1WorkerReady = false;
    let tier1Worker = null;
    let vfs = null;
    let vfsReady = false;
    let futureFs = null;
    let futureReady = false;

    // Small test repo URL - using GitHub's official example repository
    // This is tiny (just a README) and guaranteed to be public
    const TEST_REPO_URL = 'https://github.com/octocat/Hello-World';
    const CORS_PROXY = 'https://cors.isomorphic-git.org';
    // Note: CORS proxy is required for browser-based git operations

    async function initTier1Worker() {
      if (tier1Worker) return tier1WorkerReady;

      return new Promise((resolve) => {
        try {
          // Use a real worker file (not blob) so dynamic imports work correctly
          tier1Worker = new Worker('/tier1-worker.js', { type: 'module' });

          tier1Worker.onmessage = (event) => {
            if (event.data.type === 'ready') {
              tier1WorkerReady = true;
              log('Tier 1 worker ready', 'success');
              resolve(true);
            } else if (event.data.type === 'error') {
              log('Tier 1 worker init error: ' + event.data.error, 'error');
              tier1WorkerReady = false;
              resolve(false);
            } else if (event.data.type === 'log') {
              log('[T1Worker] ' + event.data.message, 'info');
            }
          };

          tier1Worker.onerror = (e) => {
            log('Tier 1 worker error: ' + e.message, 'error');
            tier1WorkerReady = false;
            resolve(false);
          };

          tier1Worker.postMessage({ type: 'init' });

          // Timeout after 5 seconds
          setTimeout(() => {
            if (!tier1WorkerReady) {
              log('Tier 1 worker timeout', 'error');
              resolve(false);
            }
          }, 5000);
        } catch (e) {
          log('Failed to create Tier 1 worker: ' + e.message, 'error');
          resolve(false);
        }
      });
    }

    async function runTier1Benchmark(type, iterations, fileSize) {
      if (!tier1WorkerReady || !tier1Worker) {
        return null;
      }

      return new Promise((resolve) => {
        const data = new Uint8Array(fileSize).fill(65);
        let resolved = false;
        let timeoutId = null;

        const cleanup = () => {
          if (timeoutId) clearTimeout(timeoutId);
          tier1Worker.removeEventListener('message', handler);
        };

        const handler = (event) => {
          // Log messages are handled by the init onmessage handler - ignore here
          if (event.data.type === 'log') {
            return;
          }

          // Only process result/error once
          if (resolved) return;
          resolved = true;
          cleanup();

          if (event.data.type === 'result') {
            resolve(event.data.elapsed);
          } else if (event.data.type === 'error') {
            log('Tier 1 benchmark error: ' + event.data.error, 'error');
            resolve(null);
          } else {
            log('Tier 1 unexpected message: ' + JSON.stringify(event.data), 'error');
            resolve(null);
          }
        };

        tier1Worker.addEventListener('message', handler);
        tier1Worker.postMessage({
          type: 'benchmark-' + type,
          iterations,
          fileSize,
          data
        });

        // Timeout after 60 seconds
        timeoutId = setTimeout(() => {
          if (!resolved) {
            resolved = true;
            cleanup();
            log('Tier 1 benchmark timed out', 'error');
            resolve(null);
          }
        }, 60000);
      });
    }

    async function init() {
      log('Loading OPFS-FS...', 'info');
      const opfsModule = await import('/index.js');
      fs = opfsModule.fs;

      // Create a second instance for Tier 2 testing (no sync kernel)
      const OPFSFileSystem = opfsModule.OPFSFileSystem;
      fsTier2 = new OPFSFileSystem();
      log('OPFS-FS loaded (fs + fsTier2 for async-only testing)', 'success');

      log('Loading LightningFS...', 'info');
      const lfsModule = await import('https://esm.sh/@isomorphic-git/lightning-fs@4.6.0');
      LightningFS = lfsModule.default;
      log('LightningFS loaded', 'success');

      log('Loading isomorphic-git...', 'info');
      const gitModule = await import('https://esm.sh/isomorphic-git@1.27.1');
      git = gitModule.default;
      http = (await import('https://esm.sh/isomorphic-git@1.27.1/http/web')).default;
      log('isomorphic-git loaded', 'success');

      // Initialize Tier 1 (sync kernel with SharedArrayBuffer)
      if (crossOriginIsolated) {
        log('Initializing Tier 1 worker (Atomics)...', 'info');
        await initTier1Worker();

        // Also init sync kernel for main thread (uses Atomics.waitAsync)
        // Only for the primary fs instance - fsTier2 stays without sync kernel
        log('Initializing sync kernel for main thread...', 'info');
        try {
          await fs.initSync('/kernel.js');
          log('Sync kernel ready (main thread can use Atomics.waitAsync)', 'success');
          log('fsTier2 will use async worker path (Tier 2)', 'info');
        } catch (e) {
          log('Sync kernel init failed: ' + e.message, 'error');
        }
      } else {
        log('Tier 1 unavailable (not crossOriginIsolated)', 'info');
      }

      // Clean corrupted VFS binaries from OPFS before init
      // VFS next/ stores .vfs.bin inside the root subdir (e.g. opfs/vfs-bench/.vfs.bin)
      try {
        const opfsRoot = await navigator.storage.getDirectory();
        // Clean root-level VFS files (used by future/)
        for await (const [name] of opfsRoot.entries()) {
          if (name.startsWith('.vfs')) {
            await opfsRoot.removeEntry(name);
            log(`Removed stale OPFS file: ${name}`, 'info');
          }
        }
        // Clean VFS binary inside vfs-bench subdir (used by next/)
        try {
          const vfsBenchDir = await opfsRoot.getDirectoryHandle('vfs-bench');
          await vfsBenchDir.removeEntry('.vfs.bin');
          log('Removed stale OPFS file: vfs-bench/.vfs.bin', 'info');
        } catch (e) {} // dir or file doesn't exist â€” fine
      } catch (e) {}

      // Initialize VFS (next/ implementation)
      if (crossOriginIsolated) {
        log('Initializing VFS...', 'info');
        try {
          const vfsModule = await import('/next/index.js');
          vfs = new vfsModule.VFSFileSystem({ root: '/vfs-bench' });
          await Promise.race([
            vfs.init(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('VFS init timeout (10s) - check browser console for [VFS] Sync-relay init failed')), 10000))
          ]);
          // Clean up stale state from previous benchmark runs
          const vfsDirs = ['/bench-vfs', '/bench-vfs-p', '/bench-vfs-read', '/bench-vfs-read-p',
            '/bench-vfs-large', '/bench-vfs-large-p', '/bench-vfs-batch', '/bench-vfs-batch-p',
            '/bench-vfs-batch-read', '/bench-vfs-batch-read-p', '/git-bench-vfs', '/git-status-vfs'];
          for (const d of vfsDirs) {
            try { await vfs.promises.rm(d, { recursive: true, force: true }); } catch {}
          }
          vfsReady = true;
          log('VFS ready', 'success');
        } catch (e) {
          log('VFS init failed: ' + e.message, 'error');
        }
      }

      // Initialize Future FS (nodecontainer FS)
      if (crossOriginIsolated) {
        log('Initializing Future FS...', 'info');
        try {
          const futureModule = await import('/future/fs.polyfill.js');
          futureFs = futureModule.default;
          await futureFs.init();
          // Clean up stale state from previous runs
          const futureDirs = ['/bench-future', '/bench-future-p', '/bench-future-read', '/bench-future-read-p',
            '/bench-future-large', '/bench-future-large-p', '/bench-future-batch', '/bench-future-batch-p',
            '/bench-future-batch-read', '/bench-future-batch-read-p', '/git-bench-future', '/git-status-future'];
          for (const d of futureDirs) {
            try { futureFs.rmSync(d, { recursive: true, force: true }); } catch {}
          }
          futureReady = true;
          log('Future FS ready', 'success');
        } catch (e) {
          log('Future FS init failed: ' + e.message, 'error');
          console.error('Future FS init error:', e);
        }
      }
    }

    // Create fs wrapper for OPFS (isomorphic-git expects specific format)
    // Converts OPFS errors to Node.js-style errors that isomorphic-git expects
    // @param fsInstance - optional fs instance (defaults to main fs with sync kernel)
    function createOpfsGitFs(fsInstance = fs) {
      // Helper to convert errors to Node.js format
      const wrapError = (err, method, args) => {
        // Only log unexpected errors (ENOENT and ENOTDIR are expected during git operations)
        // isomorphic-git probes paths with readdir to detect files vs directories
        if (err.code !== 'ENOENT' && err.name !== 'NotFoundError' &&
            err.code !== 'ENOTDIR' && err.name !== 'TypeMismatchError') {
          console.log(`[opfs-git] ${method} error:`, err, 'args:', args);
        }
        if (err.name === 'NotFoundError' || err.code === 'ENOENT') {
          const e = new Error(err.message || 'ENOENT: no such file or directory');
          e.code = 'ENOENT';
          return e;
        }
        if (err.name === 'NotAllowedError' || err.code === 'EACCES') {
          const e = new Error(err.message || 'EACCES: permission denied');
          e.code = 'EACCES';
          return e;
        }
        if (err.name === 'TypeMismatchError' || err.code === 'ENOTDIR') {
          const e = new Error(err.message || 'ENOTDIR: not a directory');
          e.code = 'ENOTDIR';
          return e;
        }
        // Preserve error code if it exists
        if (err.code) {
          const e = new Error(err.message);
          e.code = err.code;
          return e;
        }
        return err;
      };

      // Helper to wrap async functions with error conversion
      const wrap = (fn, name) => async (...args) => {
        try {
          const result = await fn(...args);
          return result;
        } catch (err) {
          throw wrapError(err, name, args);
        }
      };

      return {
        promises: {
          readFile: wrap(async (filepath, options) => {
            const result = await fsInstance.promises.readFile(filepath, options);
            return result;
          }, 'readFile'),
          writeFile: wrap((filepath, data, options) => fsInstance.promises.writeFile(filepath, data, options), 'writeFile'),
          unlink: wrap((filepath) => fsInstance.promises.unlink(filepath), 'unlink'),
          readdir: wrap((filepath, options) => fsInstance.promises.readdir(filepath, options), 'readdir'),
          mkdir: wrap((filepath, options) => fsInstance.promises.mkdir(filepath, options), 'mkdir'),
          rmdir: wrap((filepath, options) => fsInstance.promises.rmdir(filepath, options), 'rmdir'),
          stat: wrap(async (filepath) => {
            const stat = await fsInstance.promises.stat(filepath);
            // Ensure stat has the methods isomorphic-git expects
            return {
              ...stat,
              isFile: () => stat.isFile ? stat.isFile() : stat.type === 'file',
              isDirectory: () => stat.isDirectory ? stat.isDirectory() : stat.type === 'directory',
              isSymbolicLink: () => false,
              mode: stat.mode || 0o100644,
              size: stat.size || 0,
              mtimeMs: stat.mtimeMs || Date.now(),
            };
          }, 'stat'),
          lstat: wrap(async (filepath) => {
            const stat = await fsInstance.promises.stat(filepath);
            return {
              ...stat,
              isFile: () => stat.isFile ? stat.isFile() : stat.type === 'file',
              isDirectory: () => stat.isDirectory ? stat.isDirectory() : stat.type === 'directory',
              isSymbolicLink: () => false,
              mode: stat.mode || 0o100644,
              size: stat.size || 0,
              mtimeMs: stat.mtimeMs || Date.now(),
            };
          }, 'lstat'),
          readlink: async () => {
            const e = new Error('ENOENT: readlink not supported');
            e.code = 'ENOENT';
            throw e;
          },
          symlink: async () => {
            const e = new Error('ENOENT: symlink not supported');
            e.code = 'ENOENT';
            throw e;
          },
          chmod: async () => { /* no-op */ },
        },
      };
    }

    // Benchmark functions
    async function benchmarkWrite(iterations = 100, fileSize = 1024) {
      const data = new Uint8Array(fileSize).fill(65);
      const results = {};

      // LightningFS
      const lfs = new LightningFS(`bench-write-${Date.now()}`);
      log(`Testing LightningFS write (${iterations} x ${fileSize} bytes)...`, 'info');
      const startL = performance.now();
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.writeFile(`/write-${i}.bin`, data);
      }
      results.lightning = performance.now() - startL;
      log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');

      // OPFS Tier 2 (Main Thread Promises)
      log(`Testing OPFS Tier 2 (Main Thread Promises)...`, 'info');
      await fs.promises.mkdir('/bench-t2', { recursive: true });
      const startT2 = performance.now();
      for (let i = 0; i < iterations; i++) {
        await fs.promises.writeFile(`/bench-t2/write-${i}.bin`, data);
      }
      results.tier2 = performance.now() - startT2;
      await fs.promises.rm('/bench-t2', { recursive: true, force: true });
      log(`OPFS Tier 2: ${results.tier2.toFixed(2)}ms`, 'success');

      // OPFS Tier 1 Sync (Worker + Atomics)
      log(`Testing OPFS Tier 1 Sync (Atomics)...`, 'info');
      results.tier1 = await runTier1Benchmark('write', iterations, fileSize);
      if (results.tier1 !== null) {
        log(`OPFS Tier 1 Sync: ${results.tier1.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Sync: N/A`, 'info');
      }

      // OPFS Tier 1 Promises (Worker + fastCall)
      log(`Testing OPFS Tier 1 Promises (Worker)...`, 'info');
      results.tier1Promises = await runTier1Benchmark('promises-write', iterations, fileSize);
      if (results.tier1Promises !== null) {
        log(`OPFS Tier 1 Promises: ${results.tier1Promises.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Promises: N/A`, 'info');
      }

      // VFS Sync (SAB + Atomics.wait)
      if (vfsReady) {
        log(`Testing VFS Sync write (${iterations} x ${fileSize} bytes)...`, 'info');
        vfs.mkdirSync('/bench-vfs', { recursive: true });
        const startVS = performance.now();
        for (let i = 0; i < iterations; i++) {
          vfs.writeFileSync(`/bench-vfs/write-${i}.bin`, data);
        }
        results.vfsSync = performance.now() - startVS;
        vfs.rmSync('/bench-vfs', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises (async relay)
      if (vfsReady) {
        log(`Testing VFS Promises write (${iterations} x ${fileSize} bytes)...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-p', { recursive: true });
        const startVP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.writeFile(`/bench-vfs-p/write-${i}.bin`, data);
        }
        results.vfsPromises = performance.now() - startVP;
        await vfs.promises.rm('/bench-vfs-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
      } else {
        results.vfsPromises = null;
      }

      // Future Sync (nodecontainer FS)
      if (futureReady) {
        log(`Testing Future Sync write (${iterations} x ${fileSize} bytes)...`, 'info');
        futureFs.mkdirSync('/bench-future', { recursive: true });
        const startFS = performance.now();
        for (let i = 0; i < iterations; i++) {
          futureFs.writeFileSync(`/bench-future/write-${i}.bin`, data);
        }
        results.futureSync = performance.now() - startFS;
        futureFs.rmSync('/bench-future', { recursive: true, force: true });
        log(`Future Sync: ${results.futureSync.toFixed(2)}ms`, 'success');
      } else {
        results.futureSync = null;
      }

      // Future Promises (nodecontainer FS)
      if (futureReady) {
        log(`Testing Future Promises write (${iterations} x ${fileSize} bytes)...`, 'info');
        await futureFs.promises.mkdir('/bench-future-p', { recursive: true });
        const startFP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await futureFs.promises.writeFile(`/bench-future-p/write-${i}.bin`, data);
        }
        results.futurePromises = performance.now() - startFP;
        await futureFs.promises.rm('/bench-future-p', { recursive: true, force: true });
        log(`Future Promises: ${results.futurePromises.toFixed(2)}ms`, 'success');
      } else {
        results.futurePromises = null;
      }

      return { ...results, iterations, fileSize, operation: 'write' };
    }

    async function benchmarkRead(iterations = 100, fileSize = 1024) {
      const data = new Uint8Array(fileSize).fill(65);
      const results = {};

      // Setup files for LightningFS
      const lfs = new LightningFS(`bench-read-${Date.now()}`);
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.writeFile(`/read-${i}.bin`, data);
      }

      // Setup files for OPFS Tier 2
      await fs.promises.mkdir('/bench-read', { recursive: true });
      for (let i = 0; i < iterations; i++) {
        await fs.promises.writeFile(`/bench-read/read-${i}.bin`, data);
      }

      // LightningFS
      log(`Testing LightningFS read (${iterations} x ${fileSize} bytes)...`, 'info');
      const startL = performance.now();
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.readFile(`/read-${i}.bin`);
      }
      results.lightning = performance.now() - startL;
      log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');

      // OPFS Tier 2
      log(`Testing OPFS Tier 2 (Promises)...`, 'info');
      const startT2 = performance.now();
      for (let i = 0; i < iterations; i++) {
        await fs.promises.readFile(`/bench-read/read-${i}.bin`);
      }
      results.tier2 = performance.now() - startT2;
      log(`OPFS Tier 2: ${results.tier2.toFixed(2)}ms`, 'success');

      // Cleanup OPFS
      await fs.promises.rm('/bench-read', { recursive: true, force: true });

      // OPFS Tier 1 Sync (Worker + Atomics)
      log(`Testing OPFS Tier 1 Sync (Atomics)...`, 'info');
      results.tier1 = await runTier1Benchmark('read', iterations, fileSize);
      if (results.tier1 !== null) {
        log(`OPFS Tier 1 Sync: ${results.tier1.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Sync: N/A`, 'info');
      }

      // OPFS Tier 1 Promises (Worker + fastCall)
      log(`Testing OPFS Tier 1 Promises (Worker)...`, 'info');
      results.tier1Promises = await runTier1Benchmark('promises-read', iterations, fileSize);
      if (results.tier1Promises !== null) {
        log(`OPFS Tier 1 Promises: ${results.tier1Promises.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Promises: N/A`, 'info');
      }

      // VFS Sync (SAB + Atomics.wait)
      if (vfsReady) {
        log(`Testing VFS Sync read (${iterations} x ${fileSize} bytes)...`, 'info');
        vfs.mkdirSync('/bench-vfs-read', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          vfs.writeFileSync(`/bench-vfs-read/read-${i}.bin`, data);
        }
        const startVS = performance.now();
        for (let i = 0; i < iterations; i++) {
          vfs.readFileSync(`/bench-vfs-read/read-${i}.bin`);
        }
        results.vfsSync = performance.now() - startVS;
        vfs.rmSync('/bench-vfs-read', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises (async relay)
      if (vfsReady) {
        log(`Testing VFS Promises read (${iterations} x ${fileSize} bytes)...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-read-p', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.writeFile(`/bench-vfs-read-p/read-${i}.bin`, data);
        }
        const startVP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.readFile(`/bench-vfs-read-p/read-${i}.bin`);
        }
        results.vfsPromises = performance.now() - startVP;
        await vfs.promises.rm('/bench-vfs-read-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
      } else {
        results.vfsPromises = null;
      }

      // Future Sync read
      if (futureReady) {
        log(`Testing Future Sync read (${iterations} x ${fileSize} bytes)...`, 'info');
        futureFs.mkdirSync('/bench-future-read', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          futureFs.writeFileSync(`/bench-future-read/read-${i}.bin`, data);
        }
        const startFS = performance.now();
        for (let i = 0; i < iterations; i++) {
          futureFs.readFileSync(`/bench-future-read/read-${i}.bin`);
        }
        results.futureSync = performance.now() - startFS;
        futureFs.rmSync('/bench-future-read', { recursive: true, force: true });
        log(`Future Sync: ${results.futureSync.toFixed(2)}ms`, 'success');
      } else {
        results.futureSync = null;
      }

      // Future Promises read
      if (futureReady) {
        log(`Testing Future Promises read (${iterations} x ${fileSize} bytes)...`, 'info');
        await futureFs.promises.mkdir('/bench-future-read-p', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          await futureFs.promises.writeFile(`/bench-future-read-p/read-${i}.bin`, data);
        }
        const startFP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await futureFs.promises.readFile(`/bench-future-read-p/read-${i}.bin`);
        }
        results.futurePromises = performance.now() - startFP;
        await futureFs.promises.rm('/bench-future-read-p', { recursive: true, force: true });
        log(`Future Promises: ${results.futurePromises.toFixed(2)}ms`, 'success');
      } else {
        results.futurePromises = null;
      }

      return { ...results, iterations, fileSize, operation: 'read' };
    }

    async function benchmarkLargeFile(iterations = 10, fileSizeMB = 1) {
      const fileSize = fileSizeMB * 1024 * 1024;
      const data = new Uint8Array(fileSize).fill(65);
      const results = {};

      // LightningFS
      const lfs = new LightningFS(`bench-large-${Date.now()}`);
      log(`Testing LightningFS large write (${iterations} x ${fileSizeMB}MB)...`, 'info');
      const startL = performance.now();
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.writeFile(`/large-${i}.bin`, data);
      }
      results.lightning = performance.now() - startL;
      log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');

      // OPFS Tier 2
      log(`Testing OPFS Tier 2 (Promises)...`, 'info');
      await fs.promises.mkdir('/bench-large', { recursive: true });
      const startT2 = performance.now();
      for (let i = 0; i < iterations; i++) {
        await fs.promises.writeFile(`/bench-large/large-${i}.bin`, data);
      }
      results.tier2 = performance.now() - startT2;
      await fs.promises.rm('/bench-large', { recursive: true, force: true });
      log(`OPFS Tier 2: ${results.tier2.toFixed(2)}ms`, 'success');

      // OPFS Tier 1 Sync (Worker + Atomics) - uses SharedArrayBuffer, no JSON overhead
      log(`Testing OPFS Tier 1 Sync (Atomics) for large files...`, 'info');
      results.tier1 = await runTier1Benchmark('write', iterations, fileSize);
      if (results.tier1 !== null) {
        log(`OPFS Tier 1 Sync: ${results.tier1.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Sync: N/A`, 'info');
      }

      // OPFS Tier 1 Promises (Worker + fastCall) for large files
      log(`Testing OPFS Tier 1 Promises for large files...`, 'info');
      results.tier1Promises = await runTier1Benchmark('promises-write', iterations, fileSize);
      if (results.tier1Promises !== null) {
        log(`OPFS Tier 1 Promises: ${results.tier1Promises.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Promises: N/A`, 'info');
      }

      // VFS Sync (SAB + Atomics.wait) for large files
      if (vfsReady) {
        log(`Testing VFS Sync large write (${iterations} x ${fileSizeMB}MB)...`, 'info');
        vfs.mkdirSync('/bench-vfs-large', { recursive: true });
        const startVS = performance.now();
        for (let i = 0; i < iterations; i++) {
          vfs.writeFileSync(`/bench-vfs-large/large-${i}.bin`, data);
        }
        results.vfsSync = performance.now() - startVS;
        vfs.rmSync('/bench-vfs-large', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises for large files
      if (vfsReady) {
        log(`Testing VFS Promises large write (${iterations} x ${fileSizeMB}MB)...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-large-p', { recursive: true });
        const startVP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.writeFile(`/bench-vfs-large-p/large-${i}.bin`, data);
        }
        results.vfsPromises = performance.now() - startVP;
        await vfs.promises.rm('/bench-vfs-large-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
      } else {
        results.vfsPromises = null;
      }

      // Future Sync large write
      if (futureReady) {
        log(`Testing Future Sync large write (${iterations} x ${fileSizeMB}MB)...`, 'info');
        futureFs.mkdirSync('/bench-future-large', { recursive: true });
        const startFS = performance.now();
        for (let i = 0; i < iterations; i++) {
          futureFs.writeFileSync(`/bench-future-large/large-${i}.bin`, data);
        }
        results.futureSync = performance.now() - startFS;
        futureFs.rmSync('/bench-future-large', { recursive: true, force: true });
        log(`Future Sync: ${results.futureSync.toFixed(2)}ms`, 'success');
      } else {
        results.futureSync = null;
      }

      // Future Promises large write
      if (futureReady) {
        log(`Testing Future Promises large write (${iterations} x ${fileSizeMB}MB)...`, 'info');
        await futureFs.promises.mkdir('/bench-future-large-p', { recursive: true });
        const startFP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await futureFs.promises.writeFile(`/bench-future-large-p/large-${i}.bin`, data);
        }
        results.futurePromises = performance.now() - startFP;
        await futureFs.promises.rm('/bench-future-large-p', { recursive: true, force: true });
        log(`Future Promises: ${results.futurePromises.toFixed(2)}ms`, 'success');
      } else {
        results.futurePromises = null;
      }

      return { ...results, iterations, fileSize, fileSizeMB, operation: 'large-write' };
    }

    // Batch write - many small files, measuring batch throughput
    async function benchmarkBatchWrite(iterations = 500, fileSize = 256) {
      const data = new Uint8Array(fileSize).fill(65);
      const results = {};

      // LightningFS
      const lfs = new LightningFS(`bench-batch-write-${Date.now()}`);
      log(`Testing LightningFS batch write (${iterations} x ${fileSize} bytes)...`, 'info');
      const startL = performance.now();
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.writeFile(`/batch-${i}.bin`, data);
      }
      results.lightning = performance.now() - startL;
      log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');

      // OPFS Tier 2 (Promises - always available)
      log(`Testing OPFS Tier 2 (Promises) batch write...`, 'info');
      await fs.promises.mkdir('/bench-batch-t2', { recursive: true });
      const startT2 = performance.now();
      for (let i = 0; i < iterations; i++) {
        await fs.promises.writeFile(`/bench-batch-t2/batch-${i}.bin`, data);
      }
      results.tier2 = performance.now() - startT2;
      await fs.promises.rm('/bench-batch-t2', { recursive: true, force: true });
      log(`OPFS Tier 2: ${results.tier2.toFixed(2)}ms`, 'success');

      // OPFS Tier 1 Sync (Worker + Atomics with flush: false)
      log(`Testing OPFS Tier 1 Sync (Atomics) batch write...`, 'info');
      results.tier1 = await runTier1Benchmark('batch-write', iterations, fileSize);
      if (results.tier1 !== null) {
        log(`OPFS Tier 1 Sync: ${results.tier1.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Sync: N/A`, 'info');
      }

      // OPFS Tier 1 Promises (Worker + fastCall)
      log(`Testing OPFS Tier 1 Promises batch write...`, 'info');
      results.tier1Promises = await runTier1Benchmark('promises-batch-write', iterations, fileSize);
      if (results.tier1Promises !== null) {
        log(`OPFS Tier 1 Promises: ${results.tier1Promises.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Promises: N/A`, 'info');
      }

      // VFS Sync batch write
      if (vfsReady) {
        log(`Testing VFS Sync batch write (${iterations} x ${fileSize} bytes)...`, 'info');
        vfs.mkdirSync('/bench-vfs-batch', { recursive: true });
        const startVS = performance.now();
        for (let i = 0; i < iterations; i++) {
          vfs.writeFileSync(`/bench-vfs-batch/batch-${i}.bin`, data);
        }
        results.vfsSync = performance.now() - startVS;
        vfs.rmSync('/bench-vfs-batch', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises batch write
      if (vfsReady) {
        log(`Testing VFS Promises batch write (${iterations} x ${fileSize} bytes)...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-batch-p', { recursive: true });
        const startVP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.writeFile(`/bench-vfs-batch-p/batch-${i}.bin`, data);
        }
        results.vfsPromises = performance.now() - startVP;
        await vfs.promises.rm('/bench-vfs-batch-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
      } else {
        results.vfsPromises = null;
      }

      // Future Sync batch write
      if (futureReady) {
        log(`Testing Future Sync batch write (${iterations} x ${fileSize} bytes)...`, 'info');
        futureFs.mkdirSync('/bench-future-batch', { recursive: true });
        const startFS = performance.now();
        for (let i = 0; i < iterations; i++) {
          futureFs.writeFileSync(`/bench-future-batch/batch-${i}.bin`, data);
        }
        results.futureSync = performance.now() - startFS;
        futureFs.rmSync('/bench-future-batch', { recursive: true, force: true });
        log(`Future Sync: ${results.futureSync.toFixed(2)}ms`, 'success');
      } else {
        results.futureSync = null;
      }

      // Future Promises batch write
      if (futureReady) {
        log(`Testing Future Promises batch write (${iterations} x ${fileSize} bytes)...`, 'info');
        await futureFs.promises.mkdir('/bench-future-batch-p', { recursive: true });
        const startFP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await futureFs.promises.writeFile(`/bench-future-batch-p/batch-${i}.bin`, data);
        }
        results.futurePromises = performance.now() - startFP;
        await futureFs.promises.rm('/bench-future-batch-p', { recursive: true, force: true });
        log(`Future Promises: ${results.futurePromises.toFixed(2)}ms`, 'success');
      } else {
        results.futurePromises = null;
      }

      return { ...results, iterations, fileSize, operation: 'batch-write' };
    }

    // Batch read - many small files, measuring batch throughput
    async function benchmarkBatchRead(iterations = 500, fileSize = 256) {
      const data = new Uint8Array(fileSize).fill(65);
      const results = {};

      // Setup files for LightningFS
      const lfs = new LightningFS(`bench-batch-read-${Date.now()}`);
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.writeFile(`/batch-${i}.bin`, data);
      }

      // Setup files for OPFS Tier 2
      await fs.promises.mkdir('/bench-batch-read', { recursive: true });
      for (let i = 0; i < iterations; i++) {
        await fs.promises.writeFile(`/bench-batch-read/batch-${i}.bin`, data);
      }

      // LightningFS
      log(`Testing LightningFS batch read (${iterations} x ${fileSize} bytes)...`, 'info');
      const startL = performance.now();
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.readFile(`/batch-${i}.bin`);
      }
      results.lightning = performance.now() - startL;
      log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');

      // OPFS Tier 2
      log(`Testing OPFS Tier 2 (Promises) batch read...`, 'info');
      const startT2 = performance.now();
      for (let i = 0; i < iterations; i++) {
        await fs.promises.readFile(`/bench-batch-read/batch-${i}.bin`);
      }
      results.tier2 = performance.now() - startT2;
      log(`OPFS Tier 2: ${results.tier2.toFixed(2)}ms`, 'success');

      // Cleanup OPFS
      await fs.promises.rm('/bench-batch-read', { recursive: true, force: true });

      // OPFS Tier 1 Sync (Worker + Atomics)
      log(`Testing OPFS Tier 1 Sync (Atomics) batch read...`, 'info');
      results.tier1 = await runTier1Benchmark('batch-read', iterations, fileSize);
      if (results.tier1 !== null) {
        log(`OPFS Tier 1 Sync: ${results.tier1.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Sync: N/A`, 'info');
      }

      // OPFS Tier 1 Promises (Worker + fastCall)
      log(`Testing OPFS Tier 1 Promises batch read...`, 'info');
      results.tier1Promises = await runTier1Benchmark('promises-batch-read', iterations, fileSize);
      if (results.tier1Promises !== null) {
        log(`OPFS Tier 1 Promises: ${results.tier1Promises.toFixed(2)}ms`, 'success');
      } else {
        log(`OPFS Tier 1 Promises: N/A`, 'info');
      }

      // VFS Sync batch read
      if (vfsReady) {
        log(`Testing VFS Sync batch read (${iterations} x ${fileSize} bytes)...`, 'info');
        vfs.mkdirSync('/bench-vfs-batch-read', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          vfs.writeFileSync(`/bench-vfs-batch-read/batch-${i}.bin`, data);
        }
        const startVS = performance.now();
        for (let i = 0; i < iterations; i++) {
          vfs.readFileSync(`/bench-vfs-batch-read/batch-${i}.bin`);
        }
        results.vfsSync = performance.now() - startVS;
        vfs.rmSync('/bench-vfs-batch-read', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises batch read
      if (vfsReady) {
        log(`Testing VFS Promises batch read (${iterations} x ${fileSize} bytes)...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-batch-read-p', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.writeFile(`/bench-vfs-batch-read-p/batch-${i}.bin`, data);
        }
        const startVP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.readFile(`/bench-vfs-batch-read-p/batch-${i}.bin`);
        }
        results.vfsPromises = performance.now() - startVP;
        await vfs.promises.rm('/bench-vfs-batch-read-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
      } else {
        results.vfsPromises = null;
      }

      // Future Sync batch read
      if (futureReady) {
        log(`Testing Future Sync batch read (${iterations} x ${fileSize} bytes)...`, 'info');
        futureFs.mkdirSync('/bench-future-batch-read', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          futureFs.writeFileSync(`/bench-future-batch-read/batch-${i}.bin`, data);
        }
        const startFS = performance.now();
        for (let i = 0; i < iterations; i++) {
          futureFs.readFileSync(`/bench-future-batch-read/batch-${i}.bin`);
        }
        results.futureSync = performance.now() - startFS;
        futureFs.rmSync('/bench-future-batch-read', { recursive: true, force: true });
        log(`Future Sync: ${results.futureSync.toFixed(2)}ms`, 'success');
      } else {
        results.futureSync = null;
      }

      // Future Promises batch read
      if (futureReady) {
        log(`Testing Future Promises batch read (${iterations} x ${fileSize} bytes)...`, 'info');
        await futureFs.promises.mkdir('/bench-future-batch-read-p', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          await futureFs.promises.writeFile(`/bench-future-batch-read-p/batch-${i}.bin`, data);
        }
        const startFP = performance.now();
        for (let i = 0; i < iterations; i++) {
          await futureFs.promises.readFile(`/bench-future-batch-read-p/batch-${i}.bin`);
        }
        results.futurePromises = performance.now() - startFP;
        await futureFs.promises.rm('/bench-future-batch-read-p', { recursive: true, force: true });
        log(`Future Promises: ${results.futurePromises.toFixed(2)}ms`, 'success');
      } else {
        results.futurePromises = null;
      }

      return { ...results, iterations, fileSize, operation: 'batch-read' };
    }

    // Git Clone benchmark - clones a small repo
    async function benchmarkGitClone() {
      const results = {};
      const repoUrl = TEST_REPO_URL;
      const corsProxy = CORS_PROXY;

      // Cleanup any existing repos
      try { await fs.promises.rm('/git-bench-opfs', { recursive: true, force: true }); } catch {}
      try { await fsTier2.promises.rm('/git-bench-opfs-t2', { recursive: true, force: true }); } catch {}

      // LightningFS
      log(`Testing LightningFS git clone (${repoUrl})...`, 'info');
      const lfs = new LightningFS(`git-clone-${Date.now()}`);
      const startL = performance.now();
      try {
        await git.clone({
          fs: lfs,
          http,
          dir: '/repo',
          url: repoUrl,
          corsProxy,
          singleBranch: true,
          depth: 1,
        });
        results.lightning = performance.now() - startL;
        log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');
      } catch (e) {
        log(`LightningFS git clone failed: ${e.message} (code: ${e.code})`, 'error');
        console.error('LightningFS clone error:', e);
        results.lightning = null;
      }

      // OPFS Tier 1 Promises (Main thread with Atomics.waitAsync)
      // With initSync() called, fs.promises uses sync kernel via Atomics.waitAsync
      log(`Testing OPFS Tier 1 Promises git clone (Atomics.waitAsync)...`, 'info');
      // Clean up any leftover from previous runs and purge caches for clean state
      try { await fs.promises.rm('/git-bench-opfs', { recursive: true, force: true }); } catch {}
      try { await fs.promises.purge(); } catch {}
      const opfsGitFs = createOpfsGitFs(fs);
      await fs.promises.mkdir('/git-bench-opfs', { recursive: true });
      const startT1P = performance.now();
      try {
        await git.clone({
          fs: opfsGitFs,
          http,
          dir: '/git-bench-opfs',
          url: repoUrl,
          corsProxy,
          singleBranch: true,
          depth: 1,
          onMessage: (msg) => log(`[git T1P] ${msg}`, 'info'),
        });
        results.tier1Promises = performance.now() - startT1P;
        log(`OPFS Tier 1 Promises: ${results.tier1Promises.toFixed(2)}ms`, 'success');
      } catch (e) {
        log(`OPFS Tier 1 Promises git clone failed: ${e.message} (code: ${e.code}, name: ${e.name})`, 'error');
        console.error('OPFS Tier 1 Promises clone error:', e);
        results.tier1Promises = null;
      }

      // Cleanup Tier 1 Promises repo and purge caches
      try { await fs.promises.rm('/git-bench-opfs', { recursive: true, force: true }); } catch {}
      try { await fs.promises.purge(); } catch {}

      // OPFS Tier 2 (Async worker without sync kernel)
      // fsTier2 doesn't have initSync() called, so it uses the async worker path
      log(`Testing OPFS Tier 2 git clone (async worker)...`, 'info');
      // Clean up any leftover from previous runs and purge caches for clean state
      try { await fsTier2.promises.rm('/git-bench-opfs-t2', { recursive: true, force: true }); } catch {}
      try { await fsTier2.promises.purge(); } catch {}
      const opfsGitFsTier2 = createOpfsGitFs(fsTier2);
      await fsTier2.promises.mkdir('/git-bench-opfs-t2', { recursive: true });
      const startT2 = performance.now();
      try {
        await git.clone({
          fs: opfsGitFsTier2,
          http,
          dir: '/git-bench-opfs-t2',
          url: repoUrl,
          corsProxy,
          singleBranch: true,
          depth: 1,
          onMessage: (msg) => log(`[git T2] ${msg}`, 'info'),
        });
        results.tier2 = performance.now() - startT2;
        log(`OPFS Tier 2: ${results.tier2.toFixed(2)}ms`, 'success');
      } catch (e) {
        log(`OPFS Tier 2 git clone failed: ${e.message} (code: ${e.code}, name: ${e.name})`, 'error');
        console.error('OPFS Tier 2 clone error:', e);
        results.tier2 = null;
      }

      // Cleanup Tier 2 repo and purge caches
      try { await fsTier2.promises.rm('/git-bench-opfs-t2', { recursive: true, force: true }); } catch {}
      try { await fsTier2.promises.purge(); } catch {}

      // Tier 1 Sync not applicable (git requires async)
      results.tier1 = null;

      // VFS Sync not applicable (git requires async)
      results.vfsSync = null;

      // VFS Promises git clone
      if (vfsReady) {
        log(`Testing VFS Promises git clone...`, 'info');
        const vfsGitFs = createOpfsGitFs(vfs);
        try { await vfs.promises.rm('/git-bench-vfs', { recursive: true, force: true }); } catch {}
        await vfs.promises.mkdir('/git-bench-vfs', { recursive: true });
        const startVP = performance.now();
        try {
          await git.clone({
            fs: vfsGitFs,
            http,
            dir: '/git-bench-vfs',
            url: repoUrl,
            corsProxy,
            singleBranch: true,
            depth: 1,
            onMessage: (msg) => log(`[git VFS] ${msg}`, 'info'),
          });
          results.vfsPromises = performance.now() - startVP;
          log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
        } catch (e) {
          log(`VFS Promises git clone failed: ${e.message}`, 'error');
          results.vfsPromises = null;
        }
        try { await vfs.promises.rm('/git-bench-vfs', { recursive: true, force: true }); } catch {}
      } else {
        results.vfsPromises = null;
      }

      // Future Sync not applicable (git requires async)
      results.futureSync = null;

      // Future Promises git clone
      if (futureReady) {
        log(`Testing Future Promises git clone...`, 'info');
        const futureGitFs = createOpfsGitFs({ promises: futureFs.promises });
        try { futureFs.rmSync('/git-bench-future', { recursive: true, force: true }); } catch {}
        futureFs.mkdirSync('/git-bench-future', { recursive: true });
        const startFP = performance.now();
        try {
          await git.clone({
            fs: futureGitFs,
            http,
            dir: '/git-bench-future',
            url: repoUrl,
            corsProxy,
            singleBranch: true,
            depth: 1,
            onMessage: (msg) => log(`[git Future] ${msg}`, 'info'),
          });
          results.futurePromises = performance.now() - startFP;
          log(`Future Promises: ${results.futurePromises.toFixed(2)}ms`, 'success');
        } catch (e) {
          log(`Future Promises git clone failed: ${e.message}`, 'error');
          results.futurePromises = null;
        }
        try { futureFs.rmSync('/git-bench-future', { recursive: true, force: true }); } catch {}
      } else {
        results.futurePromises = null;
      }

      return { ...results, iterations: 1, fileSize: 0, operation: 'git-clone' };
    }

    // Git Status benchmark - runs git status on a cloned repo multiple times
    async function benchmarkGitStatus(iterations = 10) {
      const results = {};
      const repoUrl = TEST_REPO_URL;
      const corsProxy = CORS_PROXY;

      // Setup: Clone repo for each fs
      log('Setting up repos for git status benchmark...', 'info');

      // LightningFS setup
      const lfs = new LightningFS(`git-status-${Date.now()}`);
      try {
        await git.clone({
          fs: lfs,
          http,
          dir: '/repo',
          url: repoUrl,
          corsProxy,
          singleBranch: true,
          depth: 1,
        });
      } catch (e) {
        log(`LightningFS clone for status failed: ${e.message}`, 'error');
        return { lightning: null, tier1: null, tier1Promises: null, tier2: null, vfsSync: null, vfsPromises: null, iterations, fileSize: 0, operation: 'git-status' };
      }

      // OPFS Tier 1 Promises setup
      const opfsGitFs = createOpfsGitFs(fs);
      try { await fs.promises.rm('/git-status-opfs', { recursive: true, force: true }); } catch {}
      await fs.promises.mkdir('/git-status-opfs', { recursive: true });
      try {
        await git.clone({
          fs: opfsGitFs,
          http,
          dir: '/git-status-opfs',
          url: repoUrl,
          corsProxy,
          singleBranch: true,
          depth: 1,
        });
      } catch (e) {
        log(`OPFS Tier 1 Promises clone for status failed: ${e.message}`, 'error');
        return { lightning: null, tier1: null, tier1Promises: null, tier2: null, vfsSync: null, vfsPromises: null, iterations, fileSize: 0, operation: 'git-status' };
      }

      // OPFS Tier 2 setup
      const opfsGitFsTier2 = createOpfsGitFs(fsTier2);
      try { await fsTier2.promises.rm('/git-status-opfs-t2', { recursive: true, force: true }); } catch {}
      await fsTier2.promises.mkdir('/git-status-opfs-t2', { recursive: true });
      try {
        await git.clone({
          fs: opfsGitFsTier2,
          http,
          dir: '/git-status-opfs-t2',
          url: repoUrl,
          corsProxy,
          singleBranch: true,
          depth: 1,
        });
      } catch (e) {
        log(`OPFS Tier 2 clone for status failed: ${e.message}`, 'error');
        // Continue with other tests even if this fails
      }

      // LightningFS status benchmark
      log(`Testing LightningFS git status (${iterations}x)...`, 'info');
      const startL = performance.now();
      for (let i = 0; i < iterations; i++) {
        await git.statusMatrix({ fs: lfs, dir: '/repo' });
      }
      results.lightning = performance.now() - startL;
      log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');

      // OPFS Tier 1 Promises status benchmark (Main thread with Atomics.waitAsync)
      log(`Testing OPFS Tier 1 Promises git status (${iterations}x)...`, 'info');
      const startT1P = performance.now();
      for (let i = 0; i < iterations; i++) {
        await git.statusMatrix({ fs: opfsGitFs, dir: '/git-status-opfs' });
      }
      results.tier1Promises = performance.now() - startT1P;
      log(`OPFS Tier 1 Promises: ${results.tier1Promises.toFixed(2)}ms`, 'success');

      // OPFS Tier 2 status benchmark (async worker without sync kernel)
      log(`Testing OPFS Tier 2 git status (${iterations}x)...`, 'info');
      try {
        const startT2 = performance.now();
        for (let i = 0; i < iterations; i++) {
          await git.statusMatrix({ fs: opfsGitFsTier2, dir: '/git-status-opfs-t2' });
        }
        results.tier2 = performance.now() - startT2;
        log(`OPFS Tier 2: ${results.tier2.toFixed(2)}ms`, 'success');
      } catch (e) {
        log(`OPFS Tier 2 git status failed: ${e.message}`, 'error');
        results.tier2 = null;
      }

      // Cleanup
      try { await fs.promises.rm('/git-status-opfs', { recursive: true, force: true }); } catch {}
      try { await fsTier2.promises.rm('/git-status-opfs-t2', { recursive: true, force: true }); } catch {}

      // Tier 1 Sync not applicable (git requires async)
      results.tier1 = null;

      // VFS Sync not applicable (git requires async)
      results.vfsSync = null;

      // VFS Promises git status
      if (vfsReady) {
        const vfsGitFs = createOpfsGitFs(vfs);
        try { await vfs.promises.rm('/git-status-vfs', { recursive: true, force: true }); } catch {}
        await vfs.promises.mkdir('/git-status-vfs', { recursive: true });
        try {
          await git.clone({
            fs: vfsGitFs,
            http,
            dir: '/git-status-vfs',
            url: repoUrl,
            corsProxy,
            singleBranch: true,
            depth: 1,
          });
          log(`Testing VFS Promises git status (${iterations}x)...`, 'info');
          const startVP = performance.now();
          for (let i = 0; i < iterations; i++) {
            await git.statusMatrix({ fs: vfsGitFs, dir: '/git-status-vfs' });
          }
          results.vfsPromises = performance.now() - startVP;
          log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
        } catch (e) {
          log(`VFS Promises git status failed: ${e.message}`, 'error');
          results.vfsPromises = null;
        }
        try { await vfs.promises.rm('/git-status-vfs', { recursive: true, force: true }); } catch {}
      } else {
        results.vfsPromises = null;
      }

      // Future Sync not applicable (git requires async)
      results.futureSync = null;

      // Future Promises git status
      if (futureReady) {
        const futureGitFs = createOpfsGitFs({ promises: futureFs.promises });
        try { futureFs.rmSync('/git-status-future', { recursive: true, force: true }); } catch {}
        futureFs.mkdirSync('/git-status-future', { recursive: true });
        try {
          await git.clone({
            fs: futureGitFs,
            http,
            dir: '/git-status-future',
            url: repoUrl,
            corsProxy,
            singleBranch: true,
            depth: 1,
          });
          log(`Testing Future Promises git status (${iterations}x)...`, 'info');
          const startFP = performance.now();
          for (let i = 0; i < iterations; i++) {
            await git.statusMatrix({ fs: futureGitFs, dir: '/git-status-future' });
          }
          results.futurePromises = performance.now() - startFP;
          log(`Future Promises: ${results.futurePromises.toFixed(2)}ms`, 'success');
        } catch (e) {
          log(`Future Promises git status failed: ${e.message}`, 'error');
          results.futurePromises = null;
        }
        try { futureFs.rmSync('/git-status-future', { recursive: true, force: true }); } catch {}
      } else {
        results.futurePromises = null;
      }

      return { ...results, iterations, fileSize: 0, operation: 'git-status' };
    }

    function renderResults(allResults) {
      const container = document.getElementById('results');

      let html = '<table><thead><tr>';
      html += '<th>Test</th><th>LightningFS</th><th>Tier 1 Sync</th><th>Tier 1 Promises</th><th>Tier 2</th><th>VFS Sync</th><th>VFS Promises</th><th>Future Sync</th><th>Future Promises</th><th>Best</th>';
      html += '</tr></thead><tbody>';

      for (const result of allResults) {
        const values = [
          { name: 'LightningFS', ms: result.lightning, class: 'lightning' },
          { name: 'Tier 1 Sync', ms: result.tier1, class: 'tier1' },
          { name: 'Tier 1 Promises', ms: result.tier1Promises, class: 'tier1' },
          { name: 'Tier 2', ms: result.tier2, class: 'tier2' },
          { name: 'VFS Sync', ms: result.vfsSync, class: 'vfs' },
          { name: 'VFS Promises', ms: result.vfsPromises, class: 'vfs' },
          { name: 'Future Sync', ms: result.futureSync, class: 'future' },
          { name: 'Future Promises', ms: result.futurePromises, class: 'future' },
        ].filter(v => v.ms !== null && v.ms !== undefined);

        const minMs = Math.min(...values.map(v => v.ms));
        const maxMs = Math.max(...values.map(v => v.ms));
        const winner = values.find(v => v.ms === minMs);

        const testName = result.operation === 'write'
          ? `Write ${result.iterations} x ${result.fileSize}B`
          : result.operation === 'read'
          ? `Read ${result.iterations} x ${result.fileSize}B`
          : result.operation === 'large-write'
          ? `Large ${result.iterations} x ${result.fileSizeMB}MB`
          : result.operation === 'batch-write'
          ? `Batch Write ${result.iterations} x ${result.fileSize}B`
          : result.operation === 'batch-read'
          ? `Batch Read ${result.iterations} x ${result.fileSize}B`
          : result.operation === 'git-clone'
          ? `Git Clone (shallow)`
          : result.operation === 'git-status'
          ? `Git Status ${result.iterations}x`
          : `Unknown`;

        html += '<tr>';
        html += `<td><strong>${testName}</strong></td>`;

        // LightningFS
        if (result.lightning !== null && result.lightning !== undefined) {
          const lPct = (result.lightning / maxMs * 100).toFixed(0);
          const lOps = result.iterations > 0 ? (result.iterations / result.lightning * 1000).toFixed(0) : '-';
          html += `<td class="${result.lightning === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar lightning" style="width: ${lPct}%"></div></div>`;
          html += `${result.lightning.toFixed(1)}ms${lOps !== '-' ? ` (${lOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // Tier 1 Sync
        if (result.tier1 !== null && result.tier1 !== undefined) {
          const t1Pct = (result.tier1 / maxMs * 100).toFixed(0);
          const t1Ops = result.iterations > 0 ? (result.iterations / result.tier1 * 1000).toFixed(0) : '-';
          html += `<td class="${result.tier1 === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar tier1" style="width: ${t1Pct}%"></div></div>`;
          html += `${result.tier1.toFixed(1)}ms${t1Ops !== '-' ? ` (${t1Ops} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // Tier 1 Promises
        if (result.tier1Promises !== null && result.tier1Promises !== undefined) {
          const t1pPct = (result.tier1Promises / maxMs * 100).toFixed(0);
          const t1pOps = result.iterations > 0 ? (result.iterations / result.tier1Promises * 1000).toFixed(0) : '-';
          html += `<td class="${result.tier1Promises === minMs ? 'winner' : ''}" style="background: ${result.tier1Promises === minMs ? '#d4edda' : ''}">`;
          html += `<div class="bar-container"><div class="bar" style="width: ${t1pPct}%; background: linear-gradient(90deg, #17a2b8, #20c997);"></div></div>`;
          html += `${result.tier1Promises.toFixed(1)}ms${t1pOps !== '-' ? ` (${t1pOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // Tier 2
        if (result.tier2 !== null && result.tier2 !== undefined) {
          const t2Pct = (result.tier2 / maxMs * 100).toFixed(0);
          const t2Ops = result.iterations > 0 ? (result.iterations / result.tier2 * 1000).toFixed(0) : '-';
          html += `<td class="${result.tier2 === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar tier2" style="width: ${t2Pct}%"></div></div>`;
          html += `${result.tier2.toFixed(1)}ms${t2Ops !== '-' ? ` (${t2Ops} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // VFS Sync
        if (result.vfsSync !== null && result.vfsSync !== undefined) {
          const vsPct = (result.vfsSync / maxMs * 100).toFixed(0);
          const vsOps = result.iterations > 0 ? (result.iterations / result.vfsSync * 1000).toFixed(0) : '-';
          html += `<td class="${result.vfsSync === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar" style="width: ${vsPct}%; background: linear-gradient(90deg, #6f42c1, #a855f7);"></div></div>`;
          html += `${result.vfsSync.toFixed(1)}ms${vsOps !== '-' ? ` (${vsOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // VFS Promises
        if (result.vfsPromises !== null && result.vfsPromises !== undefined) {
          const vpPct = (result.vfsPromises / maxMs * 100).toFixed(0);
          const vpOps = result.iterations > 0 ? (result.iterations / result.vfsPromises * 1000).toFixed(0) : '-';
          html += `<td class="${result.vfsPromises === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar" style="width: ${vpPct}%; background: linear-gradient(90deg, #d63384, #e879a8);"></div></div>`;
          html += `${result.vfsPromises.toFixed(1)}ms${vpOps !== '-' ? ` (${vpOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // Future Sync
        if (result.futureSync !== null && result.futureSync !== undefined) {
          const fsPct = (result.futureSync / maxMs * 100).toFixed(0);
          const fsOps = result.iterations > 0 ? (result.iterations / result.futureSync * 1000).toFixed(0) : '-';
          html += `<td class="${result.futureSync === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar" style="width: ${fsPct}%; background: linear-gradient(90deg, #ff4757, #ff6b81);"></div></div>`;
          html += `${result.futureSync.toFixed(1)}ms${fsOps !== '-' ? ` (${fsOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // Future Promises
        if (result.futurePromises !== null && result.futurePromises !== undefined) {
          const fpPct = (result.futurePromises / maxMs * 100).toFixed(0);
          const fpOps = result.iterations > 0 ? (result.iterations / result.futurePromises * 1000).toFixed(0) : '-';
          html += `<td class="${result.futurePromises === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar" style="width: ${fpPct}%; background: linear-gradient(90deg, #ffa502, #ffbe76);"></div></div>`;
          html += `${result.futurePromises.toFixed(1)}ms${fpOps !== '-' ? ` (${fpOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // Winner
        if (winner && result.lightning) {
          const speedup = (result.lightning / minMs).toFixed(2);
          html += `<td><strong>${winner.name}</strong><br><span style="color:${speedup >= 1 ? 'green' : 'red'}">${speedup}x vs LFS</span></td>`;
        } else if (winner) {
          html += `<td><strong>${winner.name}</strong></td>`;
        } else {
          html += '<td>-</td>';
        }
        html += '</tr>';
      }

      html += '</tbody></table>';

      // Summary
      const validResults = allResults.filter(r => r.tier2 > 0 || (r.tier1 !== null && r.tier1 > 0) || (r.tier1Promises !== null && r.tier1Promises > 0) || (r.vfsSync !== null && r.vfsSync > 0) || (r.vfsPromises !== null && r.vfsPromises > 0) || (r.futureSync !== null && r.futureSync > 0) || (r.futurePromises !== null && r.futurePromises > 0));
      const avgSpeedup = validResults.length > 0
        ? validResults.reduce((acc, r) => {
            const best = Math.min(r.tier1 || Infinity, r.tier1Promises || Infinity, r.tier2 || Infinity, r.vfsSync || Infinity, r.vfsPromises || Infinity, r.futureSync || Infinity, r.futurePromises || Infinity);
            if (!isFinite(best) || best <= 0 || !r.lightning) return acc;
            return acc + (r.lightning / best);
          }, 0) / validResults.filter(r => r.lightning > 0).length
        : 0;

      html += `<div class="summary">`;
      html += `<h3>Summary</h3>`;
      html += `<p>Average OPFS speedup vs LightningFS: <strong style="color:${avgSpeedup >= 1 ? 'green' : 'red'}">${avgSpeedup.toFixed(2)}x</strong></p>`;
      html += `</div>`;

      container.innerHTML = html;
    }

    // Export to window for button handlers
    window.allResults = [];

    window.runBenchmark = async (type) => {
      try {
        setStatus('Initializing...', 'running');
        if (!fs) await init();

        let result;
        if (type === 'write') {
          setStatus('Running write benchmark...', 'running');
          result = await benchmarkWrite(100, 1024);
        } else if (type === 'read') {
          setStatus('Running read benchmark...', 'running');
          result = await benchmarkRead(100, 1024);
        } else if (type === 'large') {
          setStatus('Running large file benchmark...', 'running');
          result = await benchmarkLargeFile(10, 1);
        } else if (type === 'batch-write') {
          setStatus('Running batch write benchmark...', 'running');
          result = await benchmarkBatchWrite(500, 256);
        } else if (type === 'batch-read') {
          setStatus('Running batch read benchmark...', 'running');
          result = await benchmarkBatchRead(500, 256);
        } else if (type === 'git-clone') {
          setStatus('Running git clone benchmark...', 'running');
          result = await benchmarkGitClone();
        } else if (type === 'git-status') {
          setStatus('Running git status benchmark...', 'running');
          result = await benchmarkGitStatus(10);
        }

        window.allResults.push(result);
        renderResults(window.allResults);
        setStatus('Benchmark complete!', 'complete');
      } catch (e) {
        log(`Error: ${e.message}`, 'error');
        setStatus(`Error: ${e.message}`, 'error');
      }
    };

    window.runAllBenchmarks = async () => {
      try {
        setStatus('Initializing...', 'running');
        if (!fs) await init();

        window.allResults = [];

        setStatus('Running write benchmark (1KB)...', 'running');
        window.allResults.push(await benchmarkWrite(100, 1024));
        renderResults(window.allResults);

        setStatus('Running write benchmark (4KB)...', 'running');
        window.allResults.push(await benchmarkWrite(100, 4096));
        renderResults(window.allResults);

        setStatus('Running read benchmark (1KB)...', 'running');
        window.allResults.push(await benchmarkRead(100, 1024));
        renderResults(window.allResults);

        setStatus('Running read benchmark (4KB)...', 'running');
        window.allResults.push(await benchmarkRead(100, 4096));
        renderResults(window.allResults);

        setStatus('Running large file benchmark (1MB)...', 'running');
        window.allResults.push(await benchmarkLargeFile(10, 1));
        renderResults(window.allResults);

        setStatus('Running batch write benchmark (500 x 256B)...', 'running');
        window.allResults.push(await benchmarkBatchWrite(500, 256));
        renderResults(window.allResults);

        setStatus('Running batch read benchmark (500 x 256B)...', 'running');
        window.allResults.push(await benchmarkBatchRead(500, 256));
        renderResults(window.allResults);

        setStatus('All benchmarks complete!', 'complete');
        log('All benchmarks completed successfully!', 'success');
      } catch (e) {
        log(`Error: ${e.message}`, 'error');
        setStatus(`Error: ${e.message}`, 'error');
      }
    };

    // Export results for Playwright
    window.getBenchmarkResults = () => window.allResults;
  </script>
</body>
</html>
