<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OPFS Benchmark Suite</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 { color: #333; border-bottom: 2px solid #007bff; padding-bottom: 10px; }
    h2 { color: #555; margin-top: 30px; }
    .status { padding: 10px; border-radius: 4px; margin: 10px 0; }
    .status.running { background: #fff3cd; color: #856404; }
    .status.complete { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      background: white;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    th, td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    th { background: #007bff; color: white; font-weight: 600; }
    tr:hover { background: #f8f9fa; }
    .winner { background: #d4edda !important; font-weight: bold; }
    .loser { background: #fff3cd; }

    .bar-container {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .bar {
      height: 24px;
      background: linear-gradient(90deg, #007bff, #00d4ff);
      border-radius: 4px;
      min-width: 4px;
      transition: width 0.3s ease;
    }
    .bar.lightning { background: linear-gradient(90deg, #ffc107, #ff9800); }

    .legend {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
    }

    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      margin: 10px 5px 10px 0;
    }
    button:hover { background: #0056b3; }
    button:disabled { background: #ccc; cursor: not-allowed; }

    .summary {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .metric {
      display: inline-block;
      margin: 10px 20px 10px 0;
      padding: 10px 15px;
      background: #e9ecef;
      border-radius: 4px;
    }
    .metric-value { font-size: 24px; font-weight: bold; color: #007bff; }
    .metric-label { font-size: 12px; color: #666; }

    #log {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 13px;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .log-success { color: #4ec9b0; }
    .log-error { color: #f14c4c; }
    .log-info { color: #569cd6; }

    .debug-toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin: 10px 15px 10px 0;
      font-size: 14px;
      color: #555;
      cursor: pointer;
    }
    .debug-toggle input { cursor: pointer; }

    .perop-table {
      width: 100%;
      border-collapse: collapse;
      margin: 8px 0 16px;
      background: #fafafa;
      font-size: 13px;
    }
    .perop-table th {
      background: #495057;
      color: white;
      font-weight: 500;
      padding: 6px 10px;
      font-size: 12px;
    }
    .perop-table td {
      padding: 5px 10px;
      border-bottom: 1px solid #eee;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 12px;
    }
    .perop-toggle {
      cursor: pointer;
      color: #007bff;
      font-size: 12px;
      margin-top: 4px;
      display: inline-block;
    }
    .perop-toggle:hover { text-decoration: underline; }
  </style>
</head>
<body>
  <h1>OPFS-FS Benchmark Suite</h1>

  <div class="summary">
    <h3>Environment</h3>
    <div class="metric">
      <div class="metric-value" id="env-isolated">-</div>
      <div class="metric-label">Cross-Origin Isolated</div>
    </div>
    <div class="metric">
      <div class="metric-value" id="env-sab">-</div>
      <div class="metric-label">SharedArrayBuffer</div>
    </div>
    <div class="metric">
      <div class="metric-value" id="env-atomics">-</div>
      <div class="metric-label">Atomics</div>
    </div>
    <div class="metric">
      <div class="metric-value" id="env-opfs">-</div>
      <div class="metric-label">OPFS Available</div>
    </div>
  </div>

  <div>
    <button id="btn-run-all" onclick="runAllBenchmarks()">Run All Benchmarks</button>
    <button id="btn-run-write" onclick="runBenchmark('write')">Write Test</button>
    <button id="btn-run-read" onclick="runBenchmark('read')">Read Test</button>
    <button id="btn-run-large" onclick="runBenchmark('large')">Large File Test</button>
    <button id="btn-run-batch-write" onclick="runBenchmark('batch-write')">Batch Write</button>
    <button id="btn-run-batch-read" onclick="runBenchmark('batch-read')">Batch Read</button>
    <button id="btn-run-git-clone" onclick="runBenchmark('git-clone')" style="background:#6f42c1">Git Clone</button>
    <button id="btn-run-git-status" onclick="runBenchmark('git-status')" style="background:#6f42c1">Git Status</button>
    <label class="debug-toggle"><input type="checkbox" id="debug-mode"> Debug (VFS timing in console)</label>
    <label class="debug-toggle"><input type="checkbox" id="flush-mode"> Flush (call handle.flush after writes)</label>
    <label class="debug-toggle"><input type="checkbox" id="opfs-sync-mode" checked> OPFS Sync (mirror VFS to real OPFS)</label>
  </div>

  <div id="status" class="status" style="display:none;"></div>

  <div class="legend">
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #ffc107, #ff9800);"></div> LightningFS (IndexedDB)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #20c997, #0dcaf0);"></div> memfs (in-memory)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #6f42c1, #a855f7);"></div> VFS Sync (SAB + Atomics.wait)</div>
    <div class="legend-item"><div class="legend-color" style="background: linear-gradient(90deg, #d63384, #e879a8);"></div> VFS Promises (async relay)</div>
  </div>

  <h2>Results</h2>
  <div id="results"></div>

  <h2>Log</h2>
  <div id="log"></div>

  <script type="module">
    // Check environment
    document.getElementById('env-isolated').textContent = crossOriginIsolated ? 'Yes' : 'No';
    document.getElementById('env-sab').textContent = typeof SharedArrayBuffer !== 'undefined' ? 'Yes' : 'No';
    document.getElementById('env-atomics').textContent = typeof Atomics !== 'undefined' ? 'Yes' : 'No';
    document.getElementById('env-opfs').textContent = 'storage' in navigator ? 'Yes' : 'No';

    const log = (msg, type = '') => {
      const el = document.getElementById('log');
      const span = document.createElement('span');
      span.className = type ? `log-${type}` : '';
      span.textContent = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      el.appendChild(span);
      el.scrollTop = el.scrollHeight;
    };

    const setStatus = (msg, type) => {
      const el = document.getElementById('status');
      el.style.display = 'block';
      el.className = `status ${type}`;
      el.textContent = msg;
    };

    // Import libraries
    let LightningFS, git, http;
    let memfsModule = null; // { memfs } factory function
    let vfs = null;
    let vfsReady = false;

    // Small test repo URL - using GitHub's official example repository
    // This is tiny (just a README) and guaranteed to be public
    const TEST_REPO_URL = 'https://github.com/octocat/Hello-World';
    const CORS_PROXY = 'https://cors.isomorphic-git.org';
    // Note: CORS proxy is required for browser-based git operations

    async function init() {
      log('Loading LightningFS...', 'info');
      const lfsModule = await import('https://esm.sh/@isomorphic-git/lightning-fs@4.6.0');
      LightningFS = lfsModule.default;
      log('LightningFS loaded', 'success');

      log('Loading isomorphic-git...', 'info');
      const gitModule = await import('https://esm.sh/isomorphic-git@1.27.1');
      git = gitModule.default;
      http = (await import('https://esm.sh/isomorphic-git@1.27.1/http/web')).default;
      log('isomorphic-git loaded', 'success');

      log('Loading memfs...', 'info');
      try {
        const mod = await import('https://esm.sh/memfs@4');
        console.log('[memfs] exports:', Object.keys(mod));
        // memfs v4 export structure varies — detect the right factory
        if (typeof mod.memfs === 'function') {
          memfsModule = { create: () => mod.memfs().fs };
        } else if (typeof mod.Volume === 'function') {
          memfsModule = { create: () => mod.createFsFromVolume(new mod.Volume()) };
        } else if (typeof mod.default?.memfs === 'function') {
          memfsModule = { create: () => mod.default.memfs().fs };
        } else if (typeof mod.default?.Volume === 'function') {
          memfsModule = { create: () => mod.default.createFsFromVolume(new mod.default.Volume()) };
        } else {
          throw new Error('Could not find memfs factory — exports: ' + Object.keys(mod).join(', '));
        }
        log('memfs loaded', 'success');
      } catch (e) {
        log('memfs failed to load: ' + e.message, 'error');
      }

      // Clean corrupted VFS binaries from OPFS before init
      try {
        const opfsRoot = await navigator.storage.getDirectory();
        // Clean root-level VFS files
        for await (const [name] of opfsRoot.entries()) {
          if (name.startsWith('.vfs')) {
            await opfsRoot.removeEntry(name);
            log(`Removed stale OPFS file: ${name}`, 'info');
          }
        }
        // Clean VFS binary inside vfs-bench subdir
        try {
          const vfsBenchDir = await opfsRoot.getDirectoryHandle('vfs-bench');
          await vfsBenchDir.removeEntry('.vfs.bin');
          log('Removed stale OPFS file: vfs-bench/.vfs.bin', 'info');
        } catch (e) {} // dir or file doesn't exist — fine
      } catch (e) {}

      // Initialize VFS — works with or without crossOriginIsolated
      // Sync API requires crossOriginIsolated (SAB); Promises API works in both modes via MessagePort fallback
      {
        const debugMode = document.getElementById('debug-mode').checked;
        const opfsSyncMode = document.getElementById('opfs-sync-mode').checked;
        log(`Initializing VFS${debugMode ? ' (debug mode)' : ''}${opfsSyncMode ? ' (OPFS sync)' : ''}${!crossOriginIsolated ? ' (promises only — no COEP)' : ''}...`, 'info');
        try {
          const vfsModule = await import('/index.js');
          vfs = new vfsModule.VFSFileSystem({ root: '/vfs-bench', debug: debugMode, opfsSync: opfsSyncMode });
          await Promise.race([
            vfs.init(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('VFS init timeout (10s) - check browser console for [VFS] Sync-relay init failed')), 10000))
          ]);
          // Clean up stale state from previous benchmark runs
          const vfsDirs = ['/bench-vfs', '/bench-vfs-p', '/bench-vfs-read', '/bench-vfs-read-p',
            '/bench-vfs-large', '/bench-vfs-large-p', '/bench-vfs-batch', '/bench-vfs-batch-p',
            '/bench-vfs-batch-read', '/bench-vfs-batch-read-p', '/git-bench-vfs', '/git-status-vfs'];
          for (const d of vfsDirs) {
            try { await vfs.promises.rm(d, { recursive: true, force: true }); } catch {}
          }
          vfsReady = true;
          log('VFS ready' + (!crossOriginIsolated ? ' (promises only)' : ''), 'success');
        } catch (e) {
          log('VFS init failed: ' + e.message, 'error');
        }
      }
    }

    // Create fs wrapper for isomorphic-git (expects specific format)
    // Converts errors to Node.js-style errors that isomorphic-git expects
    function createGitFs(fsInstance) {
      // Helper to convert errors to Node.js format
      const wrapError = (err, method, args) => {
        if (err.code !== 'ENOENT' && err.name !== 'NotFoundError' &&
            err.code !== 'ENOTDIR' && err.name !== 'TypeMismatchError') {
          console.log(`[git-fs] ${method} error:`, err, 'args:', args);
        }
        if (err.name === 'NotFoundError' || err.code === 'ENOENT') {
          const e = new Error(err.message || 'ENOENT: no such file or directory');
          e.code = 'ENOENT';
          return e;
        }
        if (err.name === 'NotAllowedError' || err.code === 'EACCES') {
          const e = new Error(err.message || 'EACCES: permission denied');
          e.code = 'EACCES';
          return e;
        }
        if (err.name === 'TypeMismatchError' || err.code === 'ENOTDIR') {
          const e = new Error(err.message || 'ENOTDIR: not a directory');
          e.code = 'ENOTDIR';
          return e;
        }
        if (err.code) {
          const e = new Error(err.message);
          e.code = err.code;
          return e;
        }
        return err;
      };

      const wrap = (fn, name) => async (...args) => {
        try {
          return await fn(...args);
        } catch (err) {
          throw wrapError(err, name, args);
        }
      };

      return {
        promises: {
          readFile: wrap(async (filepath, options) => {
            return await fsInstance.promises.readFile(filepath, options);
          }, 'readFile'),
          writeFile: wrap((filepath, data, options) => fsInstance.promises.writeFile(filepath, data, options), 'writeFile'),
          unlink: wrap((filepath) => fsInstance.promises.unlink(filepath), 'unlink'),
          readdir: wrap((filepath, options) => fsInstance.promises.readdir(filepath, options), 'readdir'),
          mkdir: wrap((filepath, options) => fsInstance.promises.mkdir(filepath, options), 'mkdir'),
          rmdir: wrap((filepath, options) => fsInstance.promises.rmdir(filepath, options), 'rmdir'),
          stat: wrap(async (filepath) => {
            const stat = await fsInstance.promises.stat(filepath);
            return {
              ...stat,
              isFile: () => stat.isFile ? stat.isFile() : stat.type === 'file',
              isDirectory: () => stat.isDirectory ? stat.isDirectory() : stat.type === 'directory',
              isSymbolicLink: () => false,
              mode: stat.mode || 0o100644,
              size: stat.size || 0,
              mtimeMs: stat.mtimeMs || Date.now(),
            };
          }, 'stat'),
          lstat: wrap(async (filepath) => {
            const stat = await fsInstance.promises.stat(filepath);
            return {
              ...stat,
              isFile: () => stat.isFile ? stat.isFile() : stat.type === 'file',
              isDirectory: () => stat.isDirectory ? stat.isDirectory() : stat.type === 'directory',
              isSymbolicLink: () => false,
              mode: stat.mode || 0o100644,
              size: stat.size || 0,
              mtimeMs: stat.mtimeMs || Date.now(),
            };
          }, 'lstat'),
          readlink: async () => {
            const e = new Error('ENOENT: readlink not supported');
            e.code = 'ENOENT';
            throw e;
          },
          symlink: async () => {
            const e = new Error('ENOENT: symlink not supported');
            e.code = 'ENOENT';
            throw e;
          },
          chmod: async () => { /* no-op */ },
        },
      };
    }

    // Per-operation stats helper
    function computeStats(times) {
      if (!times || times.length === 0) return null;
      const sorted = [...times].sort((a, b) => a - b);
      const n = sorted.length;
      return {
        avg: sorted.reduce((a, b) => a + b, 0) / n,
        min: sorted[0],
        max: sorted[n - 1],
        p50: sorted[Math.floor(n * 0.5)],
        p95: sorted[Math.floor(n * 0.95)],
      };
    }

    // Benchmark functions
    async function benchmarkWrite(iterations = 100, fileSize = 1024) {
      const data = new Uint8Array(fileSize).fill(65);
      const results = { perOp: {} };
      const flushMode = document.getElementById('flush-mode').checked;
      const flushOpt = flushMode ? { flush: true } : undefined;

      // LightningFS
      const lfs = new LightningFS(`bench-write-${Date.now()}`);
      log(`Testing LightningFS write (${iterations} x ${fileSize} bytes)...`, 'info');
      const lTimes = [];
      for (let i = 0; i < iterations; i++) {
        const t = performance.now();
        await lfs.promises.writeFile(`/write-${i}.bin`, data);
        lTimes.push(performance.now() - t);
      }
      results.lightning = lTimes.reduce((a, b) => a + b, 0);
      results.perOp.lightning = computeStats(lTimes);
      log(`LightningFS: ${results.lightning.toFixed(2)}ms (avg ${results.perOp.lightning.avg.toFixed(3)}ms/op)`, 'success');

      // memfs (in-memory)
      if (memfsModule) {
        log(`Testing memfs write (${iterations} x ${fileSize} bytes)...`, 'info');
        const mfs = memfsModule.create();
        const mTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          mfs.writeFileSync(`/write-${i}.bin`, data);
          mTimes.push(performance.now() - t);
        }
        results.memfs = mTimes.reduce((a, b) => a + b, 0);
        results.perOp.memfs = computeStats(mTimes);
        log(`memfs: ${results.memfs.toFixed(2)}ms (avg ${results.perOp.memfs.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.memfs = null;
      }

      // VFS Sync (SAB + Atomics.wait) — requires crossOriginIsolated
      if (vfsReady && crossOriginIsolated) {
        log(`Testing VFS Sync write (${iterations} x ${fileSize} bytes)${flushMode ? ' [flush]' : ''}...`, 'info');
        vfs.mkdirSync('/bench-vfs', { recursive: true });
        const vsTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          vfs.writeFileSync(`/bench-vfs/write-${i}.bin`, data, flushOpt);
          vsTimes.push(performance.now() - t);
        }
        results.vfsSync = vsTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsSync = computeStats(vsTimes);
        vfs.rmSync('/bench-vfs', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms (avg ${results.perOp.vfsSync.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises (async relay)
      if (vfsReady) {
        log(`Testing VFS Promises write (${iterations} x ${fileSize} bytes)${flushMode ? ' [flush]' : ''}...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-p', { recursive: true });
        const vpTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          await vfs.promises.writeFile(`/bench-vfs-p/write-${i}.bin`, data, flushOpt);
          vpTimes.push(performance.now() - t);
        }
        results.vfsPromises = vpTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsPromises = computeStats(vpTimes);
        await vfs.promises.rm('/bench-vfs-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms (avg ${results.perOp.vfsPromises.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsPromises = null;
      }

      return { ...results, iterations, fileSize, operation: 'write' };
    }

    async function benchmarkRead(iterations = 100, fileSize = 1024) {
      const data = new Uint8Array(fileSize).fill(65);
      const results = { perOp: {} };

      // Setup files for LightningFS
      const lfs = new LightningFS(`bench-read-${Date.now()}`);
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.writeFile(`/read-${i}.bin`, data);
      }

      // LightningFS
      log(`Testing LightningFS read (${iterations} x ${fileSize} bytes)...`, 'info');
      const lTimes = [];
      for (let i = 0; i < iterations; i++) {
        const t = performance.now();
        await lfs.promises.readFile(`/read-${i}.bin`);
        lTimes.push(performance.now() - t);
      }
      results.lightning = lTimes.reduce((a, b) => a + b, 0);
      results.perOp.lightning = computeStats(lTimes);
      log(`LightningFS: ${results.lightning.toFixed(2)}ms (avg ${results.perOp.lightning.avg.toFixed(3)}ms/op)`, 'success');

      // memfs (in-memory)
      if (memfsModule) {
        log(`Testing memfs read (${iterations} x ${fileSize} bytes)...`, 'info');
        const mfs = memfsModule.create();
        for (let i = 0; i < iterations; i++) {
          mfs.writeFileSync(`/read-${i}.bin`, data);
        }
        const mTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          mfs.readFileSync(`/read-${i}.bin`);
          mTimes.push(performance.now() - t);
        }
        results.memfs = mTimes.reduce((a, b) => a + b, 0);
        results.perOp.memfs = computeStats(mTimes);
        log(`memfs: ${results.memfs.toFixed(2)}ms (avg ${results.perOp.memfs.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.memfs = null;
      }

      // VFS Sync (SAB + Atomics.wait) — requires crossOriginIsolated
      if (vfsReady && crossOriginIsolated) {
        log(`Testing VFS Sync read (${iterations} x ${fileSize} bytes)...`, 'info');
        vfs.mkdirSync('/bench-vfs-read', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          vfs.writeFileSync(`/bench-vfs-read/read-${i}.bin`, data);
        }
        const vsTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          vfs.readFileSync(`/bench-vfs-read/read-${i}.bin`);
          vsTimes.push(performance.now() - t);
        }
        results.vfsSync = vsTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsSync = computeStats(vsTimes);
        vfs.rmSync('/bench-vfs-read', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms (avg ${results.perOp.vfsSync.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises (async relay)
      if (vfsReady) {
        log(`Testing VFS Promises read (${iterations} x ${fileSize} bytes)...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-read-p', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.writeFile(`/bench-vfs-read-p/read-${i}.bin`, data);
        }
        const vpTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          await vfs.promises.readFile(`/bench-vfs-read-p/read-${i}.bin`);
          vpTimes.push(performance.now() - t);
        }
        results.vfsPromises = vpTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsPromises = computeStats(vpTimes);
        await vfs.promises.rm('/bench-vfs-read-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms (avg ${results.perOp.vfsPromises.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsPromises = null;
      }

      return { ...results, iterations, fileSize, operation: 'read' };
    }

    async function benchmarkLargeFile(iterations = 10, fileSizeMB = 1) {
      const fileSize = fileSizeMB * 1024 * 1024;
      const data = new Uint8Array(fileSize).fill(65);
      const results = { perOp: {} };
      const flushMode = document.getElementById('flush-mode').checked;
      const flushOpt = flushMode ? { flush: true } : undefined;

      // LightningFS
      const lfs = new LightningFS(`bench-large-${Date.now()}`);
      log(`Testing LightningFS large write (${iterations} x ${fileSizeMB}MB)...`, 'info');
      const lTimes = [];
      for (let i = 0; i < iterations; i++) {
        const t = performance.now();
        await lfs.promises.writeFile(`/large-${i}.bin`, data);
        lTimes.push(performance.now() - t);
      }
      results.lightning = lTimes.reduce((a, b) => a + b, 0);
      results.perOp.lightning = computeStats(lTimes);
      log(`LightningFS: ${results.lightning.toFixed(2)}ms (avg ${results.perOp.lightning.avg.toFixed(3)}ms/op)`, 'success');

      // memfs (in-memory)
      if (memfsModule) {
        log(`Testing memfs large write (${iterations} x ${fileSizeMB}MB)...`, 'info');
        const mfs = memfsModule.create();
        const mTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          mfs.writeFileSync(`/large-${i}.bin`, data);
          mTimes.push(performance.now() - t);
        }
        results.memfs = mTimes.reduce((a, b) => a + b, 0);
        results.perOp.memfs = computeStats(mTimes);
        log(`memfs: ${results.memfs.toFixed(2)}ms (avg ${results.perOp.memfs.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.memfs = null;
      }

      // VFS Sync (SAB + Atomics.wait) for large files — requires crossOriginIsolated
      if (vfsReady && crossOriginIsolated) {
        log(`Testing VFS Sync large write (${iterations} x ${fileSizeMB}MB)${flushMode ? ' [flush]' : ''}...`, 'info');
        vfs.mkdirSync('/bench-vfs-large', { recursive: true });
        const vsTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          vfs.writeFileSync(`/bench-vfs-large/large-${i}.bin`, data, flushOpt);
          vsTimes.push(performance.now() - t);
        }
        results.vfsSync = vsTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsSync = computeStats(vsTimes);
        vfs.rmSync('/bench-vfs-large', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms (avg ${results.perOp.vfsSync.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises for large files
      if (vfsReady) {
        log(`Testing VFS Promises large write (${iterations} x ${fileSizeMB}MB)${flushMode ? ' [flush]' : ''}...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-large-p', { recursive: true });
        const vpTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          await vfs.promises.writeFile(`/bench-vfs-large-p/large-${i}.bin`, data, flushOpt);
          vpTimes.push(performance.now() - t);
        }
        results.vfsPromises = vpTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsPromises = computeStats(vpTimes);
        await vfs.promises.rm('/bench-vfs-large-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms (avg ${results.perOp.vfsPromises.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsPromises = null;
      }

      return { ...results, iterations, fileSize, fileSizeMB, operation: 'large-write' };
    }

    // Batch write - many small files, measuring batch throughput
    async function benchmarkBatchWrite(iterations = 500, fileSize = 256) {
      const data = new Uint8Array(fileSize).fill(65);
      const results = { perOp: {} };
      const flushMode = document.getElementById('flush-mode').checked;
      const flushOpt = flushMode ? { flush: true } : undefined;

      // LightningFS
      const lfs = new LightningFS(`bench-batch-write-${Date.now()}`);
      log(`Testing LightningFS batch write (${iterations} x ${fileSize} bytes)...`, 'info');
      const lTimes = [];
      for (let i = 0; i < iterations; i++) {
        const t = performance.now();
        await lfs.promises.writeFile(`/batch-${i}.bin`, data);
        lTimes.push(performance.now() - t);
      }
      results.lightning = lTimes.reduce((a, b) => a + b, 0);
      results.perOp.lightning = computeStats(lTimes);
      log(`LightningFS: ${results.lightning.toFixed(2)}ms (avg ${results.perOp.lightning.avg.toFixed(3)}ms/op)`, 'success');

      // memfs (in-memory)
      if (memfsModule) {
        log(`Testing memfs batch write (${iterations} x ${fileSize} bytes)...`, 'info');
        const mfs = memfsModule.create();
        const mTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          mfs.writeFileSync(`/batch-${i}.bin`, data);
          mTimes.push(performance.now() - t);
        }
        results.memfs = mTimes.reduce((a, b) => a + b, 0);
        results.perOp.memfs = computeStats(mTimes);
        log(`memfs: ${results.memfs.toFixed(2)}ms (avg ${results.perOp.memfs.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.memfs = null;
      }

      // VFS Sync batch write — requires crossOriginIsolated
      if (vfsReady && crossOriginIsolated) {
        log(`Testing VFS Sync batch write (${iterations} x ${fileSize} bytes)${flushMode ? ' [flush]' : ''}...`, 'info');
        vfs.mkdirSync('/bench-vfs-batch', { recursive: true });
        const vsTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          vfs.writeFileSync(`/bench-vfs-batch/batch-${i}.bin`, data, flushOpt);
          vsTimes.push(performance.now() - t);
        }
        results.vfsSync = vsTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsSync = computeStats(vsTimes);
        vfs.rmSync('/bench-vfs-batch', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms (avg ${results.perOp.vfsSync.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises batch write
      if (vfsReady) {
        log(`Testing VFS Promises batch write (${iterations} x ${fileSize} bytes)${flushMode ? ' [flush]' : ''}...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-batch-p', { recursive: true });
        const vpTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          await vfs.promises.writeFile(`/bench-vfs-batch-p/batch-${i}.bin`, data, flushOpt);
          vpTimes.push(performance.now() - t);
        }
        results.vfsPromises = vpTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsPromises = computeStats(vpTimes);
        await vfs.promises.rm('/bench-vfs-batch-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms (avg ${results.perOp.vfsPromises.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsPromises = null;
      }

      return { ...results, iterations, fileSize, operation: 'batch-write' };
    }

    // Batch read - many small files, measuring batch throughput
    async function benchmarkBatchRead(iterations = 500, fileSize = 256) {
      const data = new Uint8Array(fileSize).fill(65);
      const results = { perOp: {} };

      // Setup files for LightningFS
      const lfs = new LightningFS(`bench-batch-read-${Date.now()}`);
      for (let i = 0; i < iterations; i++) {
        await lfs.promises.writeFile(`/batch-${i}.bin`, data);
      }

      // LightningFS
      log(`Testing LightningFS batch read (${iterations} x ${fileSize} bytes)...`, 'info');
      const lTimes = [];
      for (let i = 0; i < iterations; i++) {
        const t = performance.now();
        await lfs.promises.readFile(`/batch-${i}.bin`);
        lTimes.push(performance.now() - t);
      }
      results.lightning = lTimes.reduce((a, b) => a + b, 0);
      results.perOp.lightning = computeStats(lTimes);
      log(`LightningFS: ${results.lightning.toFixed(2)}ms (avg ${results.perOp.lightning.avg.toFixed(3)}ms/op)`, 'success');

      // memfs (in-memory)
      if (memfsModule) {
        log(`Testing memfs batch read (${iterations} x ${fileSize} bytes)...`, 'info');
        const mfs = memfsModule.create();
        for (let i = 0; i < iterations; i++) {
          mfs.writeFileSync(`/batch-${i}.bin`, data);
        }
        const mTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          mfs.readFileSync(`/batch-${i}.bin`);
          mTimes.push(performance.now() - t);
        }
        results.memfs = mTimes.reduce((a, b) => a + b, 0);
        results.perOp.memfs = computeStats(mTimes);
        log(`memfs: ${results.memfs.toFixed(2)}ms (avg ${results.perOp.memfs.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.memfs = null;
      }

      // VFS Sync batch read — requires crossOriginIsolated
      if (vfsReady && crossOriginIsolated) {
        log(`Testing VFS Sync batch read (${iterations} x ${fileSize} bytes)...`, 'info');
        vfs.mkdirSync('/bench-vfs-batch-read', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          vfs.writeFileSync(`/bench-vfs-batch-read/batch-${i}.bin`, data);
        }
        const vsTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          vfs.readFileSync(`/bench-vfs-batch-read/batch-${i}.bin`);
          vsTimes.push(performance.now() - t);
        }
        results.vfsSync = vsTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsSync = computeStats(vsTimes);
        vfs.rmSync('/bench-vfs-batch-read', { recursive: true, force: true });
        log(`VFS Sync: ${results.vfsSync.toFixed(2)}ms (avg ${results.perOp.vfsSync.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsSync = null;
      }

      // VFS Promises batch read
      if (vfsReady) {
        log(`Testing VFS Promises batch read (${iterations} x ${fileSize} bytes)...`, 'info');
        await vfs.promises.mkdir('/bench-vfs-batch-read-p', { recursive: true });
        for (let i = 0; i < iterations; i++) {
          await vfs.promises.writeFile(`/bench-vfs-batch-read-p/batch-${i}.bin`, data);
        }
        const vpTimes = [];
        for (let i = 0; i < iterations; i++) {
          const t = performance.now();
          await vfs.promises.readFile(`/bench-vfs-batch-read-p/batch-${i}.bin`);
          vpTimes.push(performance.now() - t);
        }
        results.vfsPromises = vpTimes.reduce((a, b) => a + b, 0);
        results.perOp.vfsPromises = computeStats(vpTimes);
        await vfs.promises.rm('/bench-vfs-batch-read-p', { recursive: true, force: true });
        log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms (avg ${results.perOp.vfsPromises.avg.toFixed(3)}ms/op)`, 'success');
      } else {
        results.vfsPromises = null;
      }

      return { ...results, iterations, fileSize, operation: 'batch-read' };
    }

    // Git Clone benchmark - clones a small repo
    async function benchmarkGitClone() {
      const results = {};
      const repoUrl = TEST_REPO_URL;
      const corsProxy = CORS_PROXY;

      // LightningFS
      log(`Testing LightningFS git clone (${repoUrl})...`, 'info');
      const lfs = new LightningFS(`git-clone-${Date.now()}`);
      const startL = performance.now();
      try {
        await git.clone({
          fs: lfs,
          http,
          dir: '/repo',
          url: repoUrl,
          corsProxy,
          singleBranch: true,
          depth: 1,
        });
        results.lightning = performance.now() - startL;
        log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');
      } catch (e) {
        log(`LightningFS git clone failed: ${e.message} (code: ${e.code})`, 'error');
        console.error('LightningFS clone error:', e);
        results.lightning = null;
      }

      // memfs git clone
      if (memfsModule) {
        log(`Testing memfs git clone...`, 'info');
        const mfs = memfsModule.create();
        const memGitFs = createGitFs({ promises: mfs.promises });
        const startM = performance.now();
        try {
          await git.clone({
            fs: memGitFs,
            http,
            dir: '/repo',
            url: repoUrl,
            corsProxy,
            singleBranch: true,
            depth: 1,
          });
          results.memfs = performance.now() - startM;
          log(`memfs: ${results.memfs.toFixed(2)}ms`, 'success');
        } catch (e) {
          log(`memfs git clone failed: ${e.message}`, 'error');
          results.memfs = null;
        }
      } else {
        results.memfs = null;
      }

      // VFS Sync not applicable (git requires async)
      results.vfsSync = null;

      // VFS Promises git clone
      if (vfsReady) {
        log(`Testing VFS Promises git clone...`, 'info');
        const vfsGitFs = createGitFs(vfs);
        try { await vfs.promises.rm('/git-bench-vfs', { recursive: true, force: true }); } catch {}
        await vfs.promises.mkdir('/git-bench-vfs', { recursive: true });
        const startVP = performance.now();
        try {
          await git.clone({
            fs: vfsGitFs,
            http,
            dir: '/git-bench-vfs',
            url: repoUrl,
            corsProxy,
            singleBranch: true,
            depth: 1,
            onMessage: (msg) => log(`[git VFS] ${msg}`, 'info'),
          });
          results.vfsPromises = performance.now() - startVP;
          log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
        } catch (e) {
          log(`VFS Promises git clone failed: ${e.message}`, 'error');
          results.vfsPromises = null;
        }
        try { await vfs.promises.rm('/git-bench-vfs', { recursive: true, force: true }); } catch {}
      } else {
        results.vfsPromises = null;
      }

      return { ...results, iterations: 1, fileSize: 0, operation: 'git-clone' };
    }

    // Git Status benchmark - runs git status on a cloned repo multiple times
    async function benchmarkGitStatus(iterations = 10) {
      const results = {};
      const repoUrl = TEST_REPO_URL;
      const corsProxy = CORS_PROXY;

      // Setup: Clone repo for each fs
      log('Setting up repos for git status benchmark...', 'info');

      // LightningFS setup
      const lfs = new LightningFS(`git-status-${Date.now()}`);
      try {
        await git.clone({
          fs: lfs,
          http,
          dir: '/repo',
          url: repoUrl,
          corsProxy,
          singleBranch: true,
          depth: 1,
        });
      } catch (e) {
        log(`LightningFS clone for status failed: ${e.message}`, 'error');
        return { lightning: null, vfsSync: null, vfsPromises: null, iterations, fileSize: 0, operation: 'git-status' };
      }

      // LightningFS status benchmark
      log(`Testing LightningFS git status (${iterations}x)...`, 'info');
      const startL = performance.now();
      for (let i = 0; i < iterations; i++) {
        await git.statusMatrix({ fs: lfs, dir: '/repo' });
      }
      results.lightning = performance.now() - startL;
      log(`LightningFS: ${results.lightning.toFixed(2)}ms`, 'success');

      // memfs git status
      if (memfsModule) {
        const mfs = memfsModule.create();
        const memGitFs = createGitFs({ promises: mfs.promises });
        try {
          await git.clone({
            fs: memGitFs,
            http,
            dir: '/repo-status',
            url: repoUrl,
            corsProxy,
            singleBranch: true,
            depth: 1,
          });
          log(`Testing memfs git status (${iterations}x)...`, 'info');
          const startM = performance.now();
          for (let i = 0; i < iterations; i++) {
            await git.statusMatrix({ fs: memGitFs, dir: '/repo-status' });
          }
          results.memfs = performance.now() - startM;
          log(`memfs: ${results.memfs.toFixed(2)}ms`, 'success');
        } catch (e) {
          log(`memfs git status failed: ${e.message}`, 'error');
          results.memfs = null;
        }
      } else {
        results.memfs = null;
      }

      // VFS Sync not applicable (git requires async)
      results.vfsSync = null;

      // VFS Promises git status
      if (vfsReady) {
        const vfsGitFs = createGitFs(vfs);
        try { await vfs.promises.rm('/git-status-vfs', { recursive: true, force: true }); } catch {}
        await vfs.promises.mkdir('/git-status-vfs', { recursive: true });
        try {
          await git.clone({
            fs: vfsGitFs,
            http,
            dir: '/git-status-vfs',
            url: repoUrl,
            corsProxy,
            singleBranch: true,
            depth: 1,
          });
          log(`Testing VFS Promises git status (${iterations}x)...`, 'info');
          const startVP = performance.now();
          for (let i = 0; i < iterations; i++) {
            await git.statusMatrix({ fs: vfsGitFs, dir: '/git-status-vfs' });
          }
          results.vfsPromises = performance.now() - startVP;
          log(`VFS Promises: ${results.vfsPromises.toFixed(2)}ms`, 'success');
        } catch (e) {
          log(`VFS Promises git status failed: ${e.message}`, 'error');
          results.vfsPromises = null;
        }
        try { await vfs.promises.rm('/git-status-vfs', { recursive: true, force: true }); } catch {}
      } else {
        results.vfsPromises = null;
      }

      return { ...results, iterations, fileSize: 0, operation: 'git-status' };
    }

    function renderResults(allResults) {
      const container = document.getElementById('results');

      let html = '<table><thead><tr>';
      html += '<th>Test</th><th>LightningFS</th><th>memfs</th><th>VFS Sync</th><th>VFS Promises</th><th>Best</th>';
      html += '</tr></thead><tbody>';

      for (const result of allResults) {
        const values = [
          { name: 'LightningFS', ms: result.lightning, class: 'lightning' },
          { name: 'memfs', ms: result.memfs, class: 'memfs' },
          { name: 'VFS Sync', ms: result.vfsSync, class: 'vfs' },
          { name: 'VFS Promises', ms: result.vfsPromises, class: 'vfs' },
        ].filter(v => v.ms !== null && v.ms !== undefined);

        const minMs = Math.min(...values.map(v => v.ms));
        const maxMs = Math.max(...values.map(v => v.ms));
        const winner = values.find(v => v.ms === minMs);

        const testName = result.operation === 'write'
          ? `Write ${result.iterations} x ${result.fileSize}B`
          : result.operation === 'read'
          ? `Read ${result.iterations} x ${result.fileSize}B`
          : result.operation === 'large-write'
          ? `Large ${result.iterations} x ${result.fileSizeMB}MB`
          : result.operation === 'batch-write'
          ? `Batch Write ${result.iterations} x ${result.fileSize}B`
          : result.operation === 'batch-read'
          ? `Batch Read ${result.iterations} x ${result.fileSize}B`
          : result.operation === 'git-clone'
          ? `Git Clone (shallow)`
          : result.operation === 'git-status'
          ? `Git Status ${result.iterations}x`
          : `Unknown`;

        html += '<tr>';
        html += `<td><strong>${testName}</strong></td>`;

        // LightningFS
        if (result.lightning !== null && result.lightning !== undefined) {
          const lPct = (result.lightning / maxMs * 100).toFixed(0);
          const lOps = result.iterations > 0 ? (result.iterations / result.lightning * 1000).toFixed(0) : '-';
          html += `<td class="${result.lightning === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar lightning" style="width: ${lPct}%"></div></div>`;
          html += `${result.lightning.toFixed(1)}ms${lOps !== '-' ? ` (${lOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // memfs
        if (result.memfs !== null && result.memfs !== undefined) {
          const mPct = (result.memfs / maxMs * 100).toFixed(0);
          const mOps = result.iterations > 0 ? (result.iterations / result.memfs * 1000).toFixed(0) : '-';
          html += `<td class="${result.memfs === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar" style="width: ${mPct}%; background: linear-gradient(90deg, #20c997, #0dcaf0);"></div></div>`;
          html += `${result.memfs.toFixed(1)}ms${mOps !== '-' ? ` (${mOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // VFS Sync
        if (result.vfsSync !== null && result.vfsSync !== undefined) {
          const vsPct = (result.vfsSync / maxMs * 100).toFixed(0);
          const vsOps = result.iterations > 0 ? (result.iterations / result.vfsSync * 1000).toFixed(0) : '-';
          html += `<td class="${result.vfsSync === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar" style="width: ${vsPct}%; background: linear-gradient(90deg, #6f42c1, #a855f7);"></div></div>`;
          html += `${result.vfsSync.toFixed(1)}ms${vsOps !== '-' ? ` (${vsOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // VFS Promises
        if (result.vfsPromises !== null && result.vfsPromises !== undefined) {
          const vpPct = (result.vfsPromises / maxMs * 100).toFixed(0);
          const vpOps = result.iterations > 0 ? (result.iterations / result.vfsPromises * 1000).toFixed(0) : '-';
          html += `<td class="${result.vfsPromises === minMs ? 'winner' : ''}">`;
          html += `<div class="bar-container"><div class="bar" style="width: ${vpPct}%; background: linear-gradient(90deg, #d63384, #e879a8);"></div></div>`;
          html += `${result.vfsPromises.toFixed(1)}ms${vpOps !== '-' ? ` (${vpOps} ops/s)` : ''}</td>`;
        } else {
          html += '<td style="color:#999">N/A</td>';
        }

        // Winner
        if (winner && result.lightning) {
          const speedup = (result.lightning / minMs).toFixed(2);
          html += `<td><strong>${winner.name}</strong><br><span style="color:${speedup >= 1 ? 'green' : 'red'}">${speedup}x vs LFS</span></td>`;
        } else if (winner) {
          html += `<td><strong>${winner.name}</strong></td>`;
        } else {
          html += '<td>-</td>';
        }
        html += '</tr>';

        // Per-op stats row (collapsible)
        if (result.perOp && Object.keys(result.perOp).length > 0) {
          const detailId = `perop-${allResults.indexOf(result)}`;
          html += `<tr><td colspan="6" style="padding: 2px 15px;">`;
          html += `<span class="perop-toggle" onclick="document.getElementById('${detailId}').style.display = document.getElementById('${detailId}').style.display === 'none' ? 'block' : 'none'">Per-op timing details</span>`;
          html += `<div id="${detailId}" style="display:none;">`;
          html += `<table class="perop-table"><thead><tr><th>Implementation</th><th>Avg</th><th>Min</th><th>P50</th><th>P95</th><th>Max</th></tr></thead><tbody>`;
          const statKeys = [
            ['lightning', 'LightningFS'],
            ['memfs', 'memfs'],
            ['vfsSync', 'VFS Sync'],
            ['vfsPromises', 'VFS Promises'],
          ];
          for (const [key, label] of statKeys) {
            const s = result.perOp[key];
            if (!s) continue;
            html += `<tr><td>${label}</td>`;
            html += `<td>${s.avg.toFixed(3)}ms</td>`;
            html += `<td>${s.min.toFixed(3)}ms</td>`;
            html += `<td>${s.p50.toFixed(3)}ms</td>`;
            html += `<td>${s.p95.toFixed(3)}ms</td>`;
            html += `<td>${s.max.toFixed(3)}ms</td></tr>`;
          }
          html += `</tbody></table></div></td></tr>`;
        }
      }

      html += '</tbody></table>';

      // Summary
      const validResults = allResults.filter(r => (r.vfsSync !== null && r.vfsSync > 0) || (r.vfsPromises !== null && r.vfsPromises > 0));
      const avgSpeedup = validResults.length > 0
        ? validResults.reduce((acc, r) => {
            const best = Math.min(r.vfsSync || Infinity, r.vfsPromises || Infinity);
            if (!isFinite(best) || best <= 0 || !r.lightning) return acc;
            return acc + (r.lightning / best);
          }, 0) / validResults.filter(r => r.lightning > 0).length
        : 0;

      html += `<div class="summary">`;
      html += `<h3>Summary</h3>`;
      html += `<p>Average speedup vs LightningFS: <strong style="color:${avgSpeedup >= 1 ? 'green' : 'red'}">${avgSpeedup.toFixed(2)}x</strong></p>`;
      html += `</div>`;

      container.innerHTML = html;
    }

    // Export to window for button handlers
    window.allResults = [];

    window.runBenchmark = async (type) => {
      try {
        setStatus('Initializing...', 'running');
        if (!LightningFS) await init();

        let result;
        if (type === 'write') {
          setStatus('Running write benchmark...', 'running');
          result = await benchmarkWrite(100, 1024);
        } else if (type === 'read') {
          setStatus('Running read benchmark...', 'running');
          result = await benchmarkRead(100, 1024);
        } else if (type === 'large') {
          setStatus('Running large file benchmark...', 'running');
          result = await benchmarkLargeFile(10, 1);
        } else if (type === 'batch-write') {
          setStatus('Running batch write benchmark...', 'running');
          result = await benchmarkBatchWrite(500, 256);
        } else if (type === 'batch-read') {
          setStatus('Running batch read benchmark...', 'running');
          result = await benchmarkBatchRead(500, 256);
        } else if (type === 'git-clone') {
          setStatus('Running git clone benchmark...', 'running');
          result = await benchmarkGitClone();
        } else if (type === 'git-status') {
          setStatus('Running git status benchmark...', 'running');
          result = await benchmarkGitStatus(10);
        }

        window.allResults.push(result);
        renderResults(window.allResults);
        setStatus('Benchmark complete!', 'complete');
      } catch (e) {
        log(`Error: ${e.message}`, 'error');
        setStatus(`Error: ${e.message}`, 'error');
      }
    };

    window.runAllBenchmarks = async () => {
      try {
        setStatus('Initializing...', 'running');
        if (!LightningFS) await init();

        window.allResults = [];

        setStatus('Running write benchmark (1KB)...', 'running');
        window.allResults.push(await benchmarkWrite(100, 1024));
        renderResults(window.allResults);

        setStatus('Running write benchmark (4KB)...', 'running');
        window.allResults.push(await benchmarkWrite(100, 4096));
        renderResults(window.allResults);

        setStatus('Running read benchmark (1KB)...', 'running');
        window.allResults.push(await benchmarkRead(100, 1024));
        renderResults(window.allResults);

        setStatus('Running read benchmark (4KB)...', 'running');
        window.allResults.push(await benchmarkRead(100, 4096));
        renderResults(window.allResults);

        setStatus('Running large file benchmark (1MB)...', 'running');
        window.allResults.push(await benchmarkLargeFile(10, 1));
        renderResults(window.allResults);

        setStatus('Running batch write benchmark (500 x 256B)...', 'running');
        window.allResults.push(await benchmarkBatchWrite(500, 256));
        renderResults(window.allResults);

        setStatus('Running batch read benchmark (500 x 256B)...', 'running');
        window.allResults.push(await benchmarkBatchRead(500, 256));
        renderResults(window.allResults);

        setStatus('All benchmarks complete!', 'complete');
        log('All benchmarks completed successfully!', 'success');
      } catch (e) {
        log(`Error: ${e.message}`, 'error');
        setStatus(`Error: ${e.message}`, 'error');
      }
    };

    // Export results for Playwright
    window.getBenchmarkResults = () => window.allResults;
  </script>
</body>
</html>
